<!--🎮 Zombie Survivor  ✨ Version: 1.2  🖋️ Tác giả: Dang -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Zombie Survivor - Dang</title>
<style>
  :root {
  /* 🎨 Màu sắc chính */
  --color-bg-dark: #111;
  --color-primary: #00ffff;
  --color-accent: gold;
  --color-danger: #ff4c4c;
  --color-text: #e0f7fa;
  --color-hover-bg: #22404c;
  --color-hover-border: #3d6c78;
  --color-title: #aefeff;
  --glow-title: 0 0 6px #7f7fff, 0 0 12px #4d4dfb;
 
  /* 🌈 Màu sắc giao diện */
  --menu-width: 26rem;
  --menu-min-height: 20rem;
  --menu-radius: 1rem;
  --menu-padding: 2rem 1.5rem;

  /* 🔘 Màu button riêng */
  --btn-bg: #1a2b33;
  --btn-border: #294e5a;

  /* 🔤 Kích thước font chữ */
  --font-xs: 0.75rem;
  --font-sm: 0.9rem;
  --font-md: 1rem;
  --font-lg: 1.25rem;
  --font-xl: 1.5rem;
  --font-xxl: 2.5rem;

  /* 📏 Kích thước padding/margin chuẩn */
  --space-xs: 0.4rem;
  --space-sm: 0.6rem;
  --space-md: 1rem;
  --space-lg: 1.5rem;
  --space-xl: 2rem;

  /* 🌟 Độ sáng bóng / hiệu ứng */
  --glow-primary: 0 0 8px var(--color-primary);
  --glow-accent: 0 0 8px var(--color-accent);
}

  body { margin: 0; background: #111; overflow: hidden; font-family: sans-serif;
  background-image: url('images/foggy-graveyard.png');
  background-size: cover;
  background-position: center center;
  background-repeat: no-repeat;
  background-attachment: fixed;}
  canvas { display: block; margin: auto; transition: background 1s ease; }
/* 🎯 Giao diện chính */
#ui {
  position: absolute;
  top: 0vh; /* cách top theo chiều cao màn hình */
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 0.2rem; /* khoảng cách giữa các nút */
  padding: 0.2rem 0.2rem; 
  background: rgb(0, 0, 0); /* nền trong suốt */
  width: 90%; /* tỷ lệ theo chiều ngang */
  max-width: 60rem; /* giới hạn tối đa */
  justify-content: center;
  z-index: 1000;
  flex-wrap: wrap;
  border-radius: 10px;
}
/* Style chung cho cả hai logo */
.ui-logo {
  position: fixed; /* Định vị cố định trên màn hình */
  top: 1.2rem;     /* Vị trí cách đỉnh */
  color: var(--color-title);
  font-family: 'Segoe UI', sans-serif;
  font-weight: bold;
  text-shadow: 0 0 4px var(--color-primary);
  z-index: 1001;   /* Luôn nổi lên trên thanh UI */
  pointer-events: none; /* Cho phép click xuyên qua logo */
}

/* Style riêng cho logo bên trái */
.left-logo {
  left: 18.1rem; /* Vị trí cách lề trái */
  line-height: 1;
  font-size: 0.8rem;
  text-align: center;
}

/* Style riêng cho logo bên phải */
.right-logo {
  right: 18.1rem; /* Vị trí cách lề phải */
  line-height: 1;
  font-size: 0.8rem;
  text-align: center;
}
/* 🔘 Nút trong UI (nhỏ gọn hơn nút mặc định) */
#ui button {
  padding: 0.6rem 0.6rem;
  font-size: 0.75rem;
  min-width: 4.5rem;
  margin-bottom: 0.6rem;
  margin-top: 0.6rem;
}

/* 🔘 Nút mặc định cho toàn giao diện */
button {
  font-family: 'Segoe UI', sans-serif;
  padding: 0.65rem 1.25rem;
  font-size: 1rem;
  cursor: pointer;
  min-width: 5rem;
  text-align: center;
  background-color: #1a2b33;
  border: 0.125rem solid #294e5a;
  border-radius: 0.5rem;
  color: #e0f7fa;
  transition: all 0.2s ease;
  box-shadow: 0 0.125rem 0.3rem rgba(0, 0, 0, 0.2);
}

/* 🔁 Hiệu ứng hover cho nút */
button:hover {
  background-color: #22404c;
  border-color: #3d6c78;
  color: #ffffff;
  transform: translateY(-0.06rem);
}

/* 🖱 Hiệu ứng khi click giữ */
button:active {
  transform: scale(0.97);
  box-shadow: 0 0.06rem 0.2rem rgba(0, 0, 0, 0.3);
}

/* ✳️ Nút đang active */
button.active {
  border-color: #00ffff;
  box-shadow: 0 0 0.5rem #00ffffaa;
}

/* Trạng thái active dùng cho nhiều thành phần */
.active {
  outline: 0rem solid gold;
  border-radius: 2.5rem;
}

/* 📊 Vùng hiển thị điểm số hoặc thông tin */
#score {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-width: 7.5rem;
  text-align: center;
  color: white;
  font-size: 0.8rem;
  padding: 0.2rem 0.2rem;
}

/* 🔄 Nút restart đặc biệt */
#restartBtn {
  padding: 0.75rem 1.75rem;
  font-weight: bold;
  background-color: #1c2e36;
  border: 0.125rem solid #3a6b75;
  border-radius: 0.5rem;
  font-size: 1rem;
  color: #aefeff;
  cursor: pointer;
  transition: 0.25s ease;
}

/* 🖱 Hover cho restart */
#restartBtn:hover {
  background-color: #28515f;
  color: white;
  transform: translateY(-0.06rem);
}

/* ⏳ Hiển thị đồng hồ đếm wave */
#waveTimerDisplay {
  position: fixed;
  top: 10vh;
  left: 48.5%;
  transform: translateX(-50%);
  font-size: 1.2rem;
  color: gold;
  z-index: 10;
  text-shadow: 0 0 8px gold;
  font-weight: bold;
  font-family: 'Courier New', monospace;
  letter-spacing: 0.1rem;
  pointer-events: none;
}

/* 🌊 Popup khi bắt đầu Wave */
#wavePopup {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 2.5rem;
  font-weight: bold;
  color: #fff3b0;
  text-shadow:
    0 0 6px #ffd54f,
    0 0 12px #ffb300;
  background: none;
  border: none;
  pointer-events: none;
  z-index: 1000;
  transition: opacity 0.5s ease;
  opacity: 0;
}

/* ✨ Animation xuất hiện mềm mượt */
@keyframes waveFade {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.7); }
  50% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
  100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
}

/* 📋 Menu bắt đầu game */
#startMenu {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  width: 90%;
  position: fixed;
  top: 55%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  border-radius: var(--menu-radius);
  padding: var(--menu-padding);
  max-width: var(--menu-width);
  min-height: 26rem;
  text-align: center;
  background: linear-gradient(to bottom, #0e1a26, #0a121a);
  backdrop-filter: blur(6px);
  border: 1px solid #446688;
  box-shadow:
    0 0 8px rgba(102, 170, 255, 0.1),
    inset 0 0 6px rgba(102, 170, 255, 0.05);
  z-index: 999;
}
#startMenu:hover {
  box-shadow:
    0 0 12px rgb(0, 153, 255),
    inset 0 0 8px rgba(0, 187, 255, 0.393);
}
#startMenu .btn-group {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 1rem;
}
#startMenu button {
  min-width: 14rem;
}
#startMenu button:hover {
  border-radius: 2.5rem;
}
/* 🌟 Popup khi lên cấp */
#levelUpPopup {
  position: fixed;
  top: 40%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 2.5rem;
  color: gold;
  font-weight: bold;
  text-shadow: 0 0 15px #ffff00;
  display: none;
  z-index: 10003;
}

/* 💀 Panel Game Over hiển thị khi thua */
.gameOverPanel {
  max-width: var(--menu-width);
  min-height: var(--menu-min-height);
  min-width: 20rem;
  position: fixed;
  top: 50%;
  left: 50%;
  /* Bắt đầu ẩn và nhỏ */
  transform: translate(-50%, -50%) scale(0.7);
  opacity: 0;
  visibility: hidden; /* Dùng visibility để ẩn hoàn toàn */

  color: white;
  display: flex; /* Giữ lại flex để căn giữa nội dung */
  flex-direction: column;
  align-items: center;
  gap: var(--space-md);
  backdrop-filter: blur(6px);
  z-index: 2000;
  padding: var(--menu-padding);
  border: 2px solid #ff5722;
  background: linear-gradient(145deg, #1a0f0f, #300d0d);
  box-shadow: 0 0 1rem #ff572288;
  border-radius: var(--menu-radius);
  text-align: center;
  
  /* Hiệu ứng chuyển động */
  transition: opacity 0.4s ease-out, transform 0.4s ease-out, visibility 0.4s;
}
.gameOverPanel button {
  width: 14rem; /* Chiều rộng cố định */
}
.gameOverPanel:hover {
  box-shadow: 0 0 2.5rem #ff5722aa;
}
.gameOverPanel button:hover {
  box-shadow: 0 0 1.5rem #ff5722aa;
  border-radius: 2.5rem;
}
/* Khi có class 'visible', panel sẽ hiện ra */
.gameOverPanel.visible {
  opacity: 1;
  visibility: visible;
  transform: translate(-50%, -50%) scale(1);
}

/* 🎯 Tiêu đề Game Over */
.gameOverTitle {
  color: #ff5722;
  font-size: 3.5rem;
  text-shadow: 0 0 4px #ffff00, 0 0 4px #ffff00;
  margin-bottom: 1rem;
}

/* 🔁 Nút Chơi lại trong Game Over Panel */
.restartButton {
  margin-top: 1rem;
  padding: 0.65rem 1.25rem;
  font-size: 1.2rem;
  font-weight: 300;
  background-color: #330000;
  color: #fff5cc;
  border: 2px solid #ff9800;
  border-radius: 0.75rem;
  cursor: pointer;
  box-shadow: 0 0 0.5rem #ff5722aa;
  transition: all 0.25s ease;
  text-shadow: 0 0 3px #ffaa00;
}

.restartButton:hover {
  background-color: #551100;
  color: #ffffff;
  transform: scale(1.05);
  box-shadow: 0 0 1rem #ff5722cc;
}

/* 🕹️ Tiêu đề game ở menu bắt đầu */
.gameTitle {
  font-size: 2.5rem;
  font-weight: 900;
  color: var(--color-title);
  text-shadow: var(--glow-title);
  margin-bottom: 1.5rem;
  font-family: 'Segoe UI', sans-serif;
}

/* ⚠️ Popup cảnh báo (dùng cho showWarning) */
.warningPopup{
  position:fixed;
  top:20%;                /* ① đặt tâm dọc  */
  left:50%;               /* ② đặt tâm ngang */
  transform:translate(-50%,-50%); /* ③ kéo ngược lại 50 % kích thước chính nó */
  background:rgba(0,32,64,.9);
  color:var(--color-text);
  padding:var(--space-sm) var(--space-lg);
  border-radius:.75rem;
  font:var(--font-md) 'Segoe UI',sans-serif;
  font-weight:500;
  z-index:9999;
  box-shadow:0 0 10px #00bcd4aa;
  pointer-events:none;
  animation:popupFade 1.5s ease-out forwards;
  max-width:70vw;         /* nếu text quá dài sẽ tự xuống hàng */
  text-align:center;
}

/*  Vì transform nay đã chứa translate(-50%,-50%),
    animation chỉ lắc trục Y thêm một chút  */
@keyframes popupFade{
  0%   {opacity:0; transform:translate(-50%,-30%);}
  10%  {opacity:1; transform:translate(-50%,-50%);}
  90%  {opacity:1; transform:translate(-50%,-50%);}
  100% {opacity:0; transform:translate(-50%,-70%);}
}
#notificationContainer{
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translate(-50%, -50%); /* căn giữa khay */
  display: flex;
  flex-direction: column;             /* xếp dọc */
  align-items: center;                /* mỗi popup vẫn giữa ngang */
  gap: .5rem;                         /* khoảng cách giữa các popup */
  pointer-events: none;
  z-index: 10000;
}

/* ✨ Popup bên trong khay */
#notificationContainer .warningPopup{
  position: relative;                 /* relative → theo khay */
  left: auto; top: 0;
  transform: none;                    /* khay đã lo căn giữa */
  animation: popupFadeStack 1.5s ease-out forwards;
}

@keyframes popupFadeStack{
  0%   {opacity:0;   transform: translateY(20px);}
  10%  {opacity:1;   transform: translateY(0);}
  90%  {opacity:1;}
  100% {opacity:0;   transform: translateY(-20px);}
}

/* 🌟 Giao diện popup nâng cấp */
#upgradePopup {
  /* display: none; */ /* Bỏ display none để dùng opacity và visibility */
  opacity: 0;
  visibility: hidden;
  transform: translate(-50%, -50%) scale(0.9); /* Bắt đầu nhỏ hơn một chút */
  transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s; /* Hiệu ứng chuyển động */
  
  position: fixed;
  top: 50%;
  left: 50%;
  background: rgba(0, 0, 0, 0.85);
  border: 2px solid gold;
  padding: 2rem;
  border-radius: 1rem;
  z-index: 9999;
  max-width: 42rem;
  width: 90%;
  text-align: center;
  box-shadow: 0 0 15px gold;
}

/* Thêm class .visible để kích hoạt hiệu ứng */
#upgradePopup.visible {
    opacity: 1;
    visibility: visible;
    transform: translate(-50%, -50%) scale(1);
}
.upgradeTitle {
  color: gold;
  font-size: 1.8rem;
  font-weight: bold;
  margin-bottom: 1.5rem;
  text-shadow: 0 0 6px gold;
  margin-top: 1rem;
}

.upgradeChoices {
  display: flex;
  justify-content: space-evenly;
  gap: 1rem;
  flex-wrap: wrap;
}

.upgradeChoices button {
  padding: 0.8rem 1.2rem;
  border: 2px solid #ccc;
  border-radius: 0.6rem;
  background: #111;
  color: white;
  font-size: 1rem;
  font-weight: bold;
  min-width: 8rem;
  cursor: pointer;
  transition: 0.2s ease;
}

.upgradeChoices button:hover {
  background: #22404c;
  border-color: gold;
  color: #fff;
  box-shadow: 0 0 10px gold;
  border-radius: 2.5rem;
}

/* 📊 Overlay thống kê */
#statsOverlay {
  position: fixed;
  top: 0.2rem;
  right: 0.5rem;
  bottom: 0.5rem;
  background: rgba(0, 0, 0, 0.7);
  border: 2px solid #00ffff;
  border-radius: 1rem;
  padding: 1rem;
  color: #e0f7fa;
  font-size: 0.95rem;
  line-height: 1.5;
  z-index: 9999;
  width: 15rem;
  font-family: 'Segoe UI', sans-serif;
}

#statsOverlay h3 {
  font-size: 1rem;
  margin-top: 0;
  margin-bottom: 0.5rem;
  color: gold;
  text-align: center;
}

#statsOverlay.hidden {
  display: yes;
}
/* 📚 Giao diện bảng kỹ năng active */
#skillsOverlay {
  position: fixed;
  top: 0.2rem;
  left: 0.5rem;
  bottom: 0.5rem;
  background: rgba(0, 0, 0, 0.7);
  border: 2px solid #00ffff;
  border-radius: 1rem;
  padding: 1rem;
  color: #e0f7fa;
  font-size: 0.95rem;
  line-height: 1.5;
  z-index: 9999;
  width: 15rem;
  font-family: 'Segoe UI', sans-serif;
}

#skillsOverlay h3 {
  font-size: 1rem;
  margin-top: 0;
  margin-bottom: 0.5rem;
  color: gold;
  text-align: center;
}

#skillsOverlay.hidden {
  display: yes;
}
/* Safe Zone: khoá nút kỹ năng */
.skill-item.disabled {
  opacity: 0.8;
  filter: grayscale(0.8);
  z-index: 10001;
}
/* Khóa nút ở thanh trên khi trong Safe Zone */

.safe-ui-btn-disabled {
  opacity: 0.8;
  filter: grayscale(0.8);
  z-index: 10001;
}
.skill-item {
  margin-bottom: 0.5rem;
  padding: 0.4rem;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 0.5rem;
  cursor: pointer;
  transition: background 0.3s;
}

.skill-item:hover {
  background: rgba(0, 255, 255, 0.3);
  border-radius: 2.5rem;
}

.skill-icon {
  font-size: 1.2rem;
  margin-right: 0.5rem;
}
#skillPopup {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 32, 64, 0.9);
  border: 2px solid #00ffff;
  padding: 2rem;
  border-radius: 1rem;
  z-index: 9999;
  max-width: 42rem;
  width: 90%;
  text-align: center;
  box-shadow: 0 0 15px #00ffffaa;
}

#skillPopup h3 {
  color: #00ffff;
  font-size: 1.6rem;
  font-weight: bold;
  margin-bottom: 1.2rem;
  text-shadow: 0 0 6px #00ffff;
}

#skillPopup .upgradeChoices {
  display: flex;
  justify-content: space-evenly;
  gap: 1rem;
  flex-wrap: wrap;
}

#skillPopup .upgradeChoices button {
  padding: 0.8rem 1rem;
  border: 2px solid #0d1aa0; /* màu kỹ năng active */
  border-radius: 0.6rem;
  background: #001f2f;
  color: white;
  font-size: 1rem;
  font-weight: bold;
  min-width: 9rem;
  cursor: pointer;
  transition: 0.2s ease;
}
#skillPopup .upgradeChoices button:hover {
  background: #003344;
  border-color: cyan;
  box-shadow: 0 0 10px cyan;
  border-radius: 2.5rem;
}

.skill-item.active {
  border: 0px solid #00ffff;
  background: rgba(0, 255, 255, 0.2);
  box-shadow: 0 0 4px cyan;
  pointer-events: none; /* không cho click vào kỹ năng đã chọn */
  border-radius: 2.5rem;
}
.infoOverlay {
  position: fixed;
  top: 55%; left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(10, 25, 40, 0.95); /* xanh đen dịu */
  border: 2px solid #446688;
  border-radius: var(--menu-radius);
  max-width: 26rem;
  min-height: 26rem;
  width: 90%;
  padding: var(--menu-padding);
  box-shadow: 0 0 10px rgba(50, 100, 150, 0.3);
  color: #eef;
  z-index: 9999;
  font-family: 'Segoe UI', sans-serif;
  font-size: 0.95rem;
  line-height: 1.6; /* khoảng cách dòng */
  text-align: center;
}
.spacer {
  height: 5rem;  /* hoặc 4rem tùy độ cao bạn muốn */
}
/* 🔧 Spacer cân bằng layout trong overlay hướng dẫn */
.spacerguide {
  height: 4rem; /* khoảng cách giữa các mục */
}

.infoOverlay button {
  min-width: 14rem;
}
.infoOverlay button:hover {
  border-radius: 2.5rem;
}
.custom-input {
  font-family: 'Segoe UI', sans-serif;
  padding: 0.65rem 1.25rem;
  font-size: 0.9rem;
  min-width: 10rem;
  width: 100%;
  max-width: 11.5rem;
  text-align: center;
  background-color: #1a2b33;
  border: 0.125rem solid #294e5a;
  border-radius: 0.5rem;
  color: #e0f7fa;
  transition: all 0.2s ease;
  box-shadow: 0 0.125rem 0.3rem rgba(0, 0, 0, 0.2);
}

.custom-input:focus {
  outline: none;
  background-color: #22404c;
  border-color: #3d6c78;
  color: #ffffff;
  box-shadow: 0 0 0.625rem #00ffffaa;
  border-radius: 2.5rem;
}
#waveNumberDisplay {
  position: fixed;
  top: 14vh; /* giống waveTimerDisplay */
  left: 48.5%; /* lệch phải so với thời gian ở 50% */
  transform: translateX(-50%);
  font-size: 1.1rem;
  color: #aefeff;
  font-weight: bold;
  text-shadow: 0 0 6px #00ffff;
  z-index: 10;
  pointer-events: none;
}
#miniMap {
  position: fixed;
  top: 6.5rem;
  right: 18rem;
  width: 150px;
  height: 150px;
  border: 2px solid #00ffff;
  border-radius: 0.5rem;
  background: rgba(0, 0, 0, 0.4);
  z-index: 9999;
  display: none; /* ẩn mini map ban đầu */
}
/* Tooltip cho item trong bảng kỹ năng (phím X) */
.skill-item[data-tooltip] {
  position: relative;
}
.skill-item[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  left: 105%;               /* hiện bên phải bảng */
  top: -2rem;
  transform: translateY(var(--tip-shift,0)); /* DỊCH theo biến */
  margin-left: .6rem;
  min-width: 18rem;
  white-space: pre-line;    /* xuống dòng theo \n */
  padding: .55rem .7rem;
  font-size: .8rem;
  background: rgba(0,0,0,.85);
  color: #e0f7fa;
  border: 1px solid #00ffff;
  border-radius: .5rem;
  pointer-events: none;
  opacity: 0;
  transition: opacity .25s;
  z-index: 10000;
}
.skill-item:hover::after { opacity: 1; }
#bigBossRespawnDisplay {
    position: fixed;
    top: 10vh;
    left: 29.1vw;
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid violet;
    border-radius: 0.5rem;
    padding: 0.4rem 0.6rem;
    color: violet;
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    text-align: center;
    min-width: 6rem;
    z-index: 10;
    text-shadow: 0 0 5px violet;
}
/* CSS cho bộ đếm ngày mới */
#dayCounterDisplay {
    position: fixed;
    top: 10vh; /* Cùng độ cao với BigBoss */
    left: 23.2vw; /* Đặt ở vị trí bên phải của BigBoss */
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid gold;
    border-radius: 0.5rem;
    padding: 0.4rem 0.6rem;
    color: gold;
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    text-align: center;
    min-width: 4rem;
    z-index: 10;
    text-shadow: 0 0 5px gold;
}
#ui button[data-tooltip] {
  position: relative;
}

#ui button[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  left: 110%;
  top: 3.5rem;
  transform: translateX(-40%);
  margin-left: .6rem;
  min-width: 18rem;
  white-space: pre-line;
  padding: .55rem .7rem;
  font-size: .8rem;
  background: rgba(0, 0, 0, 0.85);
  color: #e0f7fa;
  border: 1px solid #00ffff;
  border-radius: .5rem;
  pointer-events: none;
  opacity: 0;
  transition: opacity .25s;
  text-align: left; /* chữ canh trái */
  z-index: 10000;
}

#ui button:hover::after {
  opacity: 1;
}
#ui button:hover {
  border-radius: 2.5rem; /* bo tròn khi hover */
}
/* --- CSS cho Debug Menu --- */
#debugMenu {
  max-width: 26rem;
  width: 90%;
  padding-bottom: 1rem;
  
  /* Giới hạn chiều cao và dùng Flexbox */
  display: flex;
  flex-direction: column;
  max-height: 80vh; /* Chiều cao */
  z-index: 10009;
}
.debug-buttons {
  display: flex;
  justify-content: center; /* Căn giữa theo chiều ngang */
  align-items: center; /* Căn giữa theo chiều dọc */
  gap: 10px;
  margin-top: 15px; /* Tạo khoảng cách với các phần tử phía trên */
}

#applyDebugChanges,
#closeDebugMenu {
  padding: 8px 16px;
  font-size: 1rem;
  cursor: pointer;
  border: 1px solid transparent;
  transition: all 0.3s ease;
}
.debug-grid {
  display: grid;
  grid-template-columns: auto 1fr; 
  gap: 0.8rem 1rem;
  align-items: center;
  margin-bottom: 1rem;
  text-align: left;

  /* Cho phép cuộn dọc khi nội dung dài hơn */
  overflow-y: auto;
  padding-right: 1rem; /* Thêm khoảng đệm nhỏ tránh nội dung sát viền */

  /* --- Các thuộc tính để ẩn thanh cuộn --- */
  /* Cho Firefox */
  scrollbar-width: none;
  /* Cho Internet Explorer và Edge */
  -ms-overflow-style: none;
}

/* Cho các trình duyệt Webkit (Chrome, Safari, Edge mới) */
.debug-grid::-webkit-scrollbar {
    display: none;
}

/* Thêm định nghĩa để ẩn Debug Menu khi có class 'hidden' */
#debugMenu.hidden {
    display: none;
}
.debug-subtitle {
  grid-column: 1 / -1; /* Tiêu đề chiếm trọn chiều rộng của grid */
  text-align: center;
  color: gold;
  margin-top: 1rem;
  margin-bottom: 0.5rem;
  border-top: 1px solid #446688;
  padding-top: 1rem;
}
/* Chỉnh lại chiều rộng cho ô nhập số Kill */
#debug-kill.debug-input {
    width: 10em; /* Giới hạn chiều rộng */
    justify-self: start; /* Căn lề trái trong ô layout */
}

/* --- CSS cho khu vực debug kỹ năng active --- */
.debug-skill-grid {
  grid-column: 1 / -1; /* Chiếm trọn chiều rộng của grid cha */
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.debug-skill-wrapper {
  background: rgba(0,0,0,0.2);
  padding: 0.75rem;
  border-radius: 0.5rem;
  border: 1px solid #294e5a;
}

.debug-skill-wrapper h5 {
  margin: 0 0 0.75rem 0;
  color: white;
  font-weight: 600;
  font-size: 1.1rem;
}

.debug-skill-controls {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 0.8rem 1rem;
    align-items: center;
    font-size: 0.9rem;
}
/* CSS cho bộ đếm Xu (Coin) */
#coinCounterDisplay {
  position: fixed;
  top: 10vh; /* Cùng độ cao với Wave */
  left: 41%; /* Vị trí bên phải của Wave */
  border: 2px solid gold;
  border-radius: 0.5rem;
  padding: 0.3rem 0.6rem;
  transform: translateX(-50%);
  font-size: 0.8rem;
  color: gold; /* Màu vàng cho hợp với coin */
  font-weight: normal;
  text-shadow: 0 0 2px gold;
  z-index: 10;
  pointer-events: none;
}
/* Style chung cho hiển thị buff */
.buff-display {
  position: fixed;
  top: 10vh;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.6);
  border-radius: 0.5rem;
  padding: 0.4rem 0.4rem;
  font-family: 'Segoe UI', sans-serif;
  font-size: 0.8rem;
  font-weight: normal;
  color: white;
  border: 2px solid;
  z-index: 10;
  pointer-events: auto;
}
/* Tooltip cho các ô hiển thị buff (reuse data-tooltip) */
.buff-display[data-tooltip] { position: fixed; z-index: 10000;}
.buff-display[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  left: 50%;
  top: 115%;               /* hiện ngay dưới ô buff */
  transform: translateX(-50%);
  min-width: 14rem;
  white-space: pre-line;
  padding: .55rem .7rem;
  font-size: .8rem;
  background: rgba(0,0,0,.85);
  color: #e0f7fa;
  border: 1px solid var(--btn-border,#294e5a);
  border-radius: .5rem;
  pointer-events: none;
  opacity: 0;
  transition: opacity .2s;
  z-index: 10000;
}
.buff-display:hover::after { opacity: 1; }

.buff-display.inactive {
  opacity: 0.4; /* Làm mờ đi */
}
/* Vị trí riêng cho từng buff */
#luckyBuffDisplay { 
  left: 56.9%; /* Vị trí bên trái của Wave 68% */
  border-color: #22c55e; 
}
#powerBuffDisplay { 
  left: 64.1%; /* Vị trí bên trái của Lucky */
  border-color: #ef4444; 
}
#crazyBuffDisplay { 
  left: 71.2%; /* Vị trí bên trái của Power */
  border-color: #f59e0b; 
}
#expBuffDisplay { 
  left: 77.9%; /* Vị trí bên trái của Power */
  border-color: #ffeb3b; /* Màu vàng cho buff EXP */
}
#magnetBuffDisplay { 
  top: 15vh; /* Cùng độ cao với Wave */
  left: 56.7%; 
  border-color: #8b5cf6; /* Màu tím */
}

@keyframes pulsing-glow-magnet {
  0% { box-shadow: 0 0 4px #8b5cf6, inset 0 0 4px #8b5cf6; }
  50% { box-shadow: 0 0 14px #a78bfa, inset 0 0 14px #a78bfa; }
  100% { box-shadow: 0 0 4px #8b5cf6, inset 0 0 4px #8b5cf6; }
}

#magnetBuffDisplay.active-glow {
    animation: pulsing-glow-magnet 2s infinite;
}
#crazymadnesstimeBuffDisplay { 
  top: 15vh; /* Cùng độ cao với Wave */
  left: 65.7%; 
  border-color: #0613c5; /* Màu xanh dương */
}
@keyframes pulsing-glow-crazymadness {
  0%   { box-shadow: 0 0 4px #3b82f6, inset 0 0 4px #3b82f6; }
  50%  { box-shadow: 0 0 14px #60a5fa, inset 0 0 14px #60a5fa; }
  100% { box-shadow: 0 0 4px #3b82f6, inset 0 0 4px #3b82f6; }
}

/* Áp dụng animation khi có class active-glow */
#crazymadnesstimeBuffDisplay.active-glow {
    animation: pulsing-glow-crazymadness 1.5s infinite;
}
/* --- BẮT ĐẦU: CSS cho hiệu ứng viền sáng --- */

/* Định nghĩa animation cho buff Lucky (màu xanh lá) */
@keyframes pulsing-glow-lucky {
  0% { box-shadow: 0 0 4px #22c55e, inset 0 0 4px #22c55e; }
  50% { box-shadow: 0 0 14px #34d399, inset 0 0 14px #34d399; }
  100% { box-shadow: 0 0 4px #22c55e, inset 0 0 4px #22c55e; }
}

/* Định nghĩa animation cho buff Power (màu đỏ) */
@keyframes pulsing-glow-power {
  0% { box-shadow: 0 0 4px #ef4444, inset 0 0 4px #ef4444; }
  50% { box-shadow: 0 0 14px #f87171, inset 0 0 14px #f87171; }
  100% { box-shadow: 0 0 4px #ef4444, inset 0 0 4px #ef4444; }
}
/* Định nghĩa animation cho buff Crazy (màu vàng cam) */
@keyframes pulsing-glow-crazy {
  0% { box-shadow: 0 0 4px #f59e0b, inset 0 0 4px #f59e0b; }
  50% { box-shadow: 0 0 14px #fbbf24, inset 0 0 14px #fbbf24; }
  100% { box-shadow: 0 0 4px #f59e0b, inset 0 0 4px #f59e0b; }
}
@keyframes pulsing-glow-exp {
  0% { box-shadow: 0 0 4px #ffeb3b, inset 0 0 4px #ffeb3b; }
  50% { box-shadow: 0 0 14px #fff176, inset 0 0 14px #fff176; }
  100% { box-shadow: 0 0 4px #ffeb3b, inset 0 0 4px #ffeb3b; }
}

/* Áp dụng animation khi có class 'active-glow' */
#expBuffDisplay.active-glow {
    animation: pulsing-glow-exp 2s infinite;
}

/* Áp dụng animation khi có class 'active-glow' */
#crazyBuffDisplay.active-glow {
    animation: pulsing-glow-crazy 2s infinite;
}

/* Áp dụng animation khi có class 'active-glow' */
#luckyBuffDisplay.active-glow {
    /* Tên animation, thời gian 2 giây, lặp lại vô hạn */
    animation: pulsing-glow-lucky 2s infinite;
}

#powerBuffDisplay.active-glow {
    animation: pulsing-glow-power 2s infinite;
}

/* --- KẾT THÚC: CSS cho hiệu ứng viền sáng --- */

/* --- CSS cho Pause Menu (Gọn hơn) --- */
#pauseMenu {
  top: 55%;
  max-width: 24rem; /* Giảm chiều rộng tối đa */
  padding: 1.5rem; /* Giảm padding tổng thể */
  border-radius: 0.75rem; /* Bo tròn nhẹ hơn */
}

#pauseMenu h2 {
  font-size: 2rem; /* Giảm kích thước tiêu đề */
  margin-bottom: 1rem;
  margin-top: -1rem;
}

.settings-section {
  margin-bottom: 0.5rem; /* Giảm margin */
  padding-bottom: 0.5rem; /* Giảm padding */
  border-bottom: 1px solid #446688;
}

.settings-section h3 {
  font-size: 1rem; /* Giảm kích thước tiêu đề phụ */
  margin-bottom: 0.5rem;
}

.debug-grid label {
  font-size: 0.9rem; /* Giảm kích thước label */
}

.range-container input {
  width: 70%; /* Điều chỉnh chiều rộng thanh trượt */
}

.range-container .range-value {
  font-size: 0.9rem; /* Giảm kích thước giá trị */
}

.pause-menu-buttons {
  display: grid;
  grid-template-columns: 1fr; /* <-- Sửa thành 1fr để chỉ có 1 cột dọc */
  gap: 0.75rem;
  margin-top: 0.5rem;
  justify-items: center;
}

.pause-menu-buttons button {
  width: 14rem; /* Chiều rộng cố định */
  max-width: 90%; /* Đảm bảo không quá to trên màn hình hẹp */
  font-size: 0.9rem; /* Giảm kích thước chữ nút */
  padding: 0.6rem 1rem; /* Giảm padding nút */
}

#resumeBtn {
  grid-column: 1 / -1;
  padding: 0.75rem 1.2rem; /* Tăng padding nút Tiếp tục một chút */
}
#pauseMenu.hidden {
    display: none;
}
#guideOverlay, #infoOverlay {
    z-index: 10001;
}

/* --- CSS cho Cửa hàng (Shop) --- */
#shopOverlay {
  max-width: 40rem;
  min-height: auto;
}

#shopOverlay.hidden {
  display: none;
}

.shop-balance {
  font-size: 1.2rem;
  color: gold;
  margin-bottom: 1rem;
  text-shadow: 0 0 5px gold;
}

.shop-grid {
  display: grid;
  /* Giới hạn chiều rộng tối thiểu và tối đa của mỗi ô */
  grid-template-columns: repeat(auto-fill, minmax(6rem, 1fr)); 
  gap: 0.75rem;
  margin-bottom: 1.5rem;
  max-height: 50vh;
  overflow-y: auto;
  padding: 0.5rem;
}

/* Ẩn thanh cuộn cho shop grid */
.shop-grid::-webkit-scrollbar { display: none; }
.shop-grid { -ms-overflow-style: none; scrollbar-width: none; }

.shop-item {
  background: #1a2b33;
  border: 1px solid #294e5a;
  border-radius: 0.5rem;
  /* Giảm padding để thu nhỏ ô vật phẩm */
  padding: 0.5rem; 
  text-align: center;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  transition: all 0.2s ease;
}

.shop-item:hover {
    transform: translateY(-3px);
    border-color: var(--color-primary);
}

.shop-item .icon {
  font-size: 1.8rem;
}

.shop-item .name {
  font-weight: 500;
  margin: 0.4rem 0;
  font-size: 0.8rem;
  min-height: 2.2em;
}

.shop-item button {
  min-width: 6rem; /* Đảm bảo nút không quá nhỏ */
  padding: 0.5rem 1rem;
  /* Giảm padding để thu nhỏ nút bấm */
  margin: 0 auto; 
  font-size: 0.8rem;
  font-weight: bold;
  width: fit-content;
}
/* CSS để hiển thị tooltip cho thanh EXP/HP */
#score-top[data-tooltip] {
  position: relative;
}
#score-top[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  left: 50%;
  top: 110%; /* Hiển thị ngay bên dưới thanh trạng thái */
  transform: translateX(-50%);
  
  /* Các style khác cho tooltip */
  min-width: 10rem;
  white-space: pre-line;
  padding: .55rem .7rem;
  font-size: .8rem;
  background: rgba(0,0,0,.85);
  color: #e0f7fa;
  border: 1px solid #00ffff;
  border-radius: .5rem;
  pointer-events: none;
  opacity: 0;
  transition: opacity .25s;
  z-index: 10000;
}
#score-top:hover::after {
  opacity: 1;
}
/* ✨ CSS cho màn hình loading */
#loadingOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--color-bg-dark);
  background-color: var(--color-bg-dark); 
  background-image: url('images/neon-night.png');
  background-size: cover;
  background-position: center;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10002; /* Luôn nổi lên trên cùng */
  transition: opacity 0.5s ease-out; /* Hiệu ứng mờ dần khi ẩn */
}

#loadingOverlay.hidden {
    opacity: 0;
    pointer-events: none; /* Vô hiệu hóa click khi đang ẩn */
}

.loading-content {
  text-align: center;
}

#loadingText {
  color: var(--color-primary);
  font-size: var(--font-lg);
  margin-top: 1.5rem;
  animation: pulse 1.5s infinite ease-in-out;
}

/* Hiệu ứng nhấp nháy cho chữ loading */
@keyframes pulse {
  0% { opacity: 0.6; }
  50% { opacity: 1; }
  100% { opacity: 0.6; }
}

/* CSS cho hiển thị số lượng đạn */
#ammoDisplay {
  position: fixed;
  bottom: 0.1rem;
  left: 18.8rem;
  background: rgba(0, 0, 0, 0.7);
  border: 2px solid var(--color-primary);
  border-radius: 0.25rem;
  padding: 0.1rem 0.1rem;
  color: var(--color-text);
  font-family: 'Segoe UI', sans-serif;
  font-size: 0.8rem;
  font-weight: bold;
  z-index: 9998;
  pointer-events: none;
  transition: opacity 0.3s ease;
  opacity: 0; /* Mặc định ẩn đi */
}
/* CSS cho thanh loading bar */
.loading-bar-container {
    width: 100%; /* Độ rộng của khung chứa thanh loading */
    height: 20px;
    background-color: #333;
    border-radius: 10px;
    overflow: hidden; /* Quan trọng để thanh bên trong không tràn ra ngoài */
    margin-top: 20px;
}

.loading-bar {
    height: 100%;
    width: 0%; /* Bắt đầu với chiều rộng 0% */
    background-color: #4CAF50; /* Màu của thanh loading */
    transition: width 0.3s ease; /* Tạo hiệu ứng chuyển động mượt mà */
}
/* --- CSS cho bản tin chạy chữ --- */
#newsTickerContainer {
    position: fixed;
    top: 15vh;
    left: 22.5%;
    transform: translateX(-50%);
    width: 90%;
    max-width: 25rem;
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid var(--color-hover-border);
    border-radius: 6px;
    color: gold;
    font-size: 0.85rem;
    height: 1.5rem;
    line-height: 1.5rem;
    overflow: hidden;
    white-space: nowrap;
    z-index: 999;
    font-family: 'Segoe UI', sans-serif;
    text-shadow: 0 0 4px gold;
    transition: opacity 0.3s ease; /* Thêm hiệu ứng mờ */
}

/* MỚI: CSS để ẩn thanh thông báo */
#newsTickerContainer.hidden {
    opacity: 0;
    pointer-events: none; /* Vô hiệu hóa tương tác khi bị ẩn */
}

#newsTickerText {
    position: absolute;
    display: inline-block;
    /* Animation sẽ được điều khiển bởi tệp news_ticker.js */
}

/* Định nghĩa animation chạy chữ từ phải qua trái */
@keyframes scrollTicker {
  from { transform: translateX(var(--scroll-start, 100%)); }
  to   { transform: translateX(var(--scroll-end, -100%)); }
}

/* kết thúc style */
</style>
</head>
<body>
  <div id="loadingOverlay">
  <div class="loading-content">
    <h2 class="gameTitle">Zombie Survivor</h2>
    <p id="loadingText">Đang khởi tạo...</p>
      <div class="loading-bar-container">
         <div class="loading-bar"></div>
      </div>
  </div>
</div>
<div class="ui-logo left-logo">Zombie<br>Survivor</div>
<div class="ui-logo right-logo">Bubble<br>Ver: 1.2</div>
<div id="ui">
  <button id="autoBtn" data-tooltip="⚙️ Auto:
- Tự động tấn công zombie gần nhất
- Có thể tắt bật kích hoạt mọi lúc
- Nâng cấp để tăng tốc độ tấn công
- Tăng cấp để tăng sát thương
- Yêu cầu level 1
- Sát thương: 1
- Tiêu hao: 0 ⚡">⚙️ Auto</button>

  <button id="bladeBtn" data-tooltip="🔪 Kỹ năng Đao:
- Tạo 2~20 thanh đao xoay quanh player
- Tối đa tạo được 20 đao
- Bay vào zombie gần nhất
- Yêu cầu level 1
- Sát thương: 1
- Hiệu lực: 60s ⏱
- Tiêu hao: 5 ⚡">🔪 Đao</button>

  <button id="swordBtn" data-tooltip="⚔️ Kỹ năng Kiếm:
- Tạo mưa kiếm rơi từng đợt
- Số lượng kiếm tăng theo level
- Bay vào zombie gần nhất
- Yêu cầu level 2
- Sát thương: 1
- Hiệu lực: 60s ⏱
- Tiêu hao: 6 ⚡">⚔️ Kiếm</button>

  <button id="fireBtn" data-tooltip="🔥 Kỹ năng Lửa:
- Tạo 2 quả cầu lửa quay quanh
- Tạo được tối đa 10 quả cầu lửa
- Tiêu diệt zombie chạm vào
- Yêu cầu level 3
- Sát thương: 1
- Hiệu lực: 60s ⏱
- Tiêu hao: 8 ⚡">🔥 Lửa</button>

  <button id="iceBtn" data-tooltip="❄️ Kỹ năng Băng:
- Tạo 2 quả cầu băng lớn xoay quanh
- Tạo được tối đa 10 quả cầu băng
- Gây sát thương diện rộng
- Yêu cầu level 3
- Sát thương: 1
- Hiệu lực: 60s ⏱
- Tiêu hao: 12 ⚡">❄️ Băng</button>

  <button id="thunderBtn" data-tooltip="🔵 Kỹ năng thunder:
- Tạo 2 quả cầu lôi xoay quanh
- Tạo được tối đa 6 quả cầu
- Gây sát thương và làm choáng
- Yêu cầu level 5
- Sát thương: 1
- Hiệu lực: 60s ⏱
- Tiêu hao: 18 ⚡">🔵 Lôi</button>

<button id="supportAuraBtn" data-tooltip="✨ Kỹ năng hào quang:
- Tạo một vùng phép thuật dưới chân.
- Tăng 20% tốc độ chạy và tốc độ bắn.
- Giảm 50% sát thương từ mọi nguồn.
- Hồi 1 HP mỗi giây.
- Yêu cầu level 6
- Hiệu lực: 60s ⏱
- Tiêu hao: 15 ⚡">✨ Heal</button>

<button id="fairyBtn" data-tooltip="🦋 Kỹ năng Fairy:
- Triệu hồi Fairy hỗ trợ.
- Hồi máu mỗi 2s. Giúp hồi sinh player.
- Tăng sát thương player.
- Giảm sát thương zombie.
- Yêu cầu level 7
- Hiệu lực: 60s ⏱
- Tiêu hao: 25 ⚡">🦋 Fairy</button>

  <button id="PetBtn" data-tooltip="🐰 Kỹ năng Pet:
- Triệu hồi 1 rabbit cute đi theo player
- Hỗ trợ: nhặt vật phẩm
- Hỗ trợ: tăng sát thương
- Bắn carrot làm choáng zombie.
- Hỗ trợ: Hồi 1 HP mỗi 3s
- Hiệu lực: 60s ⏱
- Tiêu hao: 5 ⚡">🐰 Pet</button>

  <div id="score">
    <div id="score-top" data-tooltip="Exp cấp tiếp theo: --">Exp: 0000 |❤️: 0010</div>
    <div id="score-bottom">Level: 0001 |⚡: 0000</div>
  </div>
<div id="newsTickerContainer" class="hidden">
  <span id="newsTickerText"></span>
</div>
</div>
<canvas id="game" width="960" height="720"></canvas>

<!-- 📋 Menu bắt đầu game -->
<div id="startMenu">
  <h2 class="gameTitle">Zombie Survivor</h2>
<input type="text" id="playerNameInput" placeholder="Nhập tên của bạn" class="custom-input" />
  <button id="continueBtn" style="display: none;" onclick="continueGame()">Chơi tiếp</button>
  <button onclick="startGame()">Chơi mới</button>
  <button onclick="showGuide()">📘 Hướng dẫn</button>
  <button onclick="showInfo()">ℹ️ Thông tin</button>
</div>
<div id="guideOverlay" class="infoOverlay" style="display: none;">
<h3 style="margin-top: 0; color: #66aaff;">📘 Hướng dẫn chơi</h3>
  <ul style="text-align: left;">
    <li>Tiêu diệt zombie để lên cấp</li>
    <li>Mỗi wave, level sẽ được nâng cấp kỹ năng</li>
    <li>Trùm cuối siêu khó nên tránh xa khi còn yếu</li>
    <li>Nhặt vật phẩm để tăng máu, mana, năng lượng</li>
    <li>Nhấn phím Space để sử dụng kỹ năng đặc biệt</li>
    <li>Bấm X: mở danh sách kỹ năng</li>
    <li>Bấm Z: mở bảng thống kê</li>
    <li>Bấm M: mở bảng bản đồ</li>
    <li>Bấm O: mở Shop. ESC: mở Menu</li>
    <li>Vật phẩm trong game: Energy, Mana, HP, Box</li>
  </ul>
  <div class="spacerguide"></div> <!-- 👈 dòng đệm -->
  <button onclick="hideGuide()">Đóng</button>
</div>
<div id="infoOverlay" class="infoOverlay" style="display: none;">
  <h3 style="margin-top: 0; color: #66aaff;">ℹ️ Thông tin</h3>
  <div class="infoContent">
    <p>Phiên bản: 1.2<br>
       Tác giả: Dang<br>
       Cập nhật: 2025-08-27</p>
    <p style="margin: 0; text-align: left;"><strong style="color: #00cc66;">🆕 New</strong></p>
    <!-- Phần có thể cuộn và canh trái -->
    <div style="max-height: 128px;overflow-y: auto;scrollbar-width: none;
    -ms-overflow-style: none;text-align: left;">
      <ul style="padding-left: 20px;margin-top: 2px;list-style-type: disc;">
        <li>Thêm minimap</li>
        <li>Tăng giới hạn bản đồ</li>
        <li>Tăng giới hạn số lượng Zombie</li>
        <li>Thêm Boss to hơn</li>
        <li>Cải tiến một số kỹ năng</li>
        <li>Thêm hệ thống ngày đêm</li>
        <li>Thêm kỹ năng hỗ trợ</li>
        <li>Thêm Shop và Menu cài đặt</li>
        <li>Thêm vật phẩm mới: Coin, lucky, power, crazy</li>
        <!-- Các mục mới có thể thêm ở đây -->
      </ul>
    </div>
    <!-- Ẩn scrollbar trên Chrome/Safari -->
    <style>
      .infoContent div::-webkit-scrollbar {
        display: none;
      }
    </style>
  </div>
  <div class="spacer"></div>
  <button onclick="hideInfo()">Đóng</button>
</div>

<!-- 💀 Game Over Panel -->
<div id="gameOverPanel" class="gameOverPanel">
    <h2 class="gameOverTitle">Game Over</h2>
    <button onclick="revivePlayer()" class="restartButton">Hồi sinh</button>
    <button onclick="resetGame()" class="restartButton">Chơi lại</button>
    <button onclick="window.location.reload()" class="restartButton">Menu</button>
</div>

<!-- 🌊 Popup khi bắt đầu mỗi Wave -->
<div id="wavePopup">Wave 1</div>

<!-- ⏳ Đồng hồ đếm thời gian wave -->
<div id="dayCounterDisplay">Ngày: 1</div>
<div id="bigBossRespawnDisplay">BigBoss: zZzz..</div>
<div id="waveTimerDisplay">01:30:00</div>
<div id="waveNumberDisplay">Wave: 1</div>
<div id="coinCounterDisplay">🪙: 00000</div>
<div id="luckyBuffDisplay" class="buff-display">🍀 LuckyUp: <span>--</span>-</div>
<div id="powerBuffDisplay" class="buff-display">🍁 PowerUp: <span>--</span>-</div>
<div id="crazyBuffDisplay" class="buff-display">🍂 CarzyUp: <span>--</span>-</div>
<div id="expBuffDisplay" class="buff-display">🌿 ExpUp: <span>--</span>-</div>
<div id="magnetBuffDisplay" class="buff-display">🧲 Magnet: <span>---</span></div>
<div id="crazymadnesstimeBuffDisplay" class="buff-display">💢 CrazyMadnessTime: <span>---</span></div>

<!-- Mini map -->
<canvas id="miniMap" width="150" height="150"></canvas>
<script>
// --- BẮT ĐẦU: HỆ THỐNG ÂM THANH & NHẠC NỀN HOÀN CHỈNH ---

// Danh sách ID và file nhạc
const normalMusicTracks = ['music-background', 'music-background-2', 'music-background-3'];
const bossMusicId = 'music-boss';
const luckyMusicId = 'sfx-lucky-loop';
const powerMusicId = 'sfx-power-loop';
const crazyMusicId = 'sfx-crazy-loop';
const expMusicId = 'sfx-exp-loop';
const crazyMadnessMusicId = 'sfx-power-loop'; // Dùng chung với Power
// Biến trạng thái
let currentMusicState = '';
let currentNormalTrackId = '';

// Cập nhật âm lượng cho tất cả các track nhạc
function updateAllMusicVolume() {
    // Tính toán âm lượng cuối cùng dựa trên thanh trượt Tổng và Nhạc nền
    const finalMusicVol = musicVolume * masterVolume;
    // Áp dụng âm lượng cho tất cả các thẻ audio dùng cho nhạc
    document.querySelectorAll('audio[id^="music-"], audio[id^="sfx-"][loop]').forEach(audio => {
        if (audio) audio.volume = finalMusicVol;
    });
}

// Hàm phát hiệu ứng âm thanh (SFX)
function playSound(id, baseVolume = 1.0) {
    const soundData = sfxPool[id];
    
    // Nếu không tìm thấy âm thanh trong kho, không làm gì cả
    if (!soundData || soundData.pool.length === 0) {
        return;
    }

    // Lấy đối tượng Audio tiếp theo trong kho theo kiểu xoay vòng (Round-robin)
    let audio = soundData.pool[soundData.currentIndex];

    // Cập nhật con trỏ cho lần gọi tiếp theo
    soundData.currentIndex = (soundData.currentIndex + 1) % soundData.pool.length;
    
    // Đặt lại thời gian và âm lượng, sau đó phát
    audio.currentTime = 0;
    audio.volume = baseVolume * sfxVolume * masterVolume;
    audio.play().catch(e => {
        // Lỗi này thường xảy ra khi người dùng chưa tương tác với trang, có thể bỏ qua
    });
}

// Hàm dừng tất cả nhạc nền
function stopAllMusic() {
    document.querySelectorAll('audio[id^="music-"], audio[id^="sfx-"][loop]').forEach(audio => {
        if(audio) { audio.pause(); audio.currentTime = 0; }
    });
}

// Hàm phát nhạc nền ngẫu nhiên
function playRandomNormalMusic() {
    const list = normalMusicTracks;
    const n = list.length;

    // 0 bài: thoát ngay
    if (n === 0) return;

    // 1 bài: chỉ phát nếu khác bài hiện tại
    if (n === 1) {
        const id = list[0];
        if (id !== currentNormalTrackId) {
            const el = document.getElementById(id);
            if (el) {
                updateAllMusicVolume();
                // Chỉ dừng nhạc khi chắc chắn có bài mới để phát
                stopAllMusic();
                // ⛔ THÊM DELAY Ở ĐÂY
                setTimeout(() => {
                    el.play().catch(e => console.error("Lỗi phát nhạc:", e));
                }, 50); // Khoảng chờ nhỏ (ví dụ: 50ms)
                currentNormalTrackId = id;
                currentMusicState = 'normal';
            }
        }
        return;
    }

    // n >= 2
    const cur = list.indexOf(currentNormalTrackId);

    let idx;
    if (cur === -1) {
        // lần đầu/chưa khớp danh sách: bốc tự do 0..n-1 (đều xác suất)
        idx = (Math.random() * n) | 0;
    } else {
        // bốc đều trong (n-1) bài khác: 0..n-2 rồi nhảy qua cur
        const r = (Math.random() * (n - 1)) | 0; // 0..n-2
        idx = (r >= cur) ? r + 1 : r;
    }

    const id = list[idx];
    if (id === currentNormalTrackId) return; // phòng hờ

    const el = document.getElementById(id);
    if (!el) {
        console.warn("Không tìm thấy phần tử audio:", id);
        return;
    }

    updateAllMusicVolume();
    stopAllMusic();
    // ⛔ THÊM DELAY Ở ĐÂY
    setTimeout(() => {
        el.play().catch(e => console.error("Lỗi phát nhạc:", e));
    }, 50); // Khoảng chờ nhỏ (ví dụ: 50ms)
    currentNormalTrackId = id;
    currentMusicState = 'normal';
}

// Hàm cập nhật nhạc nền chính
function updateMusic() {
    const now = Date.now();
    const bigBoss = zombies.find(z => z.active && z.isBigBoss);
    
    // Tìm buff có thời gian kết thúc xa nhất (được nhặt sau cùng)
    let latestBuffEndTime = 0;
    let highestPriorityState = null;

    // Lấy thời gian kết thúc của các buff
    if (now < expBuffEndTime && expBuffEndTime > latestBuffEndTime) {
        latestBuffEndTime = expBuffEndTime;
        highestPriorityState = 'exp';
    }
    if (now < crazyBuffEndTime && crazyBuffEndTime > latestBuffEndTime) {
        latestBuffEndTime = crazyBuffEndTime;
        highestPriorityState = 'crazy';
    }
    if (now < powerBuffEndTime && powerBuffEndTime > latestBuffEndTime) {
        latestBuffEndTime = powerBuffEndTime;
        highestPriorityState = 'power';
    }
    if (now < luckyBuffEndTime && luckyBuffEndTime > latestBuffEndTime) {
        latestBuffEndTime = luckyBuffEndTime;
        highestPriorityState = 'lucky';
    }

    //  BƯỚC 1: THÊM CRAZYMADNESSTIME VÀO DANH SÁCH KIỂM TRA
    if (now < crazyMadnessTimeEndTime && crazyMadnessTimeEndTime > latestBuffEndTime) {
        latestBuffEndTime = crazyMadnessTimeEndTime;
        highestPriorityState = 'crazymadness';
    }

    // Xác định trạng thái nhạc cuối cùng
    let desiredState = 'normal';
    // Nếu có buff nào đang hoạt động, ưu tiên buff đó
    if (highestPriorityState) {
        desiredState = highestPriorityState;
    } else if (bigBoss) {
        desiredState = 'boss';
    }

    // Chỉ đổi nhạc khi trạng thái thay đổi
if (desiredState !== currentMusicState) {
        stopAllMusic();
        let trackToPlayId = null;

        // BƯỚC 2: CẬP NHẬT ID PHÁT NHẠC DỰA TRÊN TRẠNG THÁI
        if (desiredState === 'crazymadness') trackToPlayId = crazyMadnessMusicId; 
        else if (desiredState === 'exp') trackToPlayId = expMusicId;
        else if (desiredState === 'crazy') trackToPlayId = crazyMusicId;
        else if (desiredState === 'lucky') trackToPlayId = luckyMusicId;
        else if (desiredState === 'power') trackToPlayId = powerMusicId;
        else if (desiredState === 'boss') trackToPlayId = bossMusicId;
        else { 
            playRandomNormalMusic(); 
            return; 
        }
        
        const trackElement = document.getElementById(trackToPlayId);
        if (trackElement) {
            updateAllMusicVolume();
            trackElement.play().catch(e => console.error(`Lỗi phát nhạc cho trạng thái '${desiredState}':`, e));
        }
        currentMusicState = desiredState;
    }
}
// --- KẾT THÚC: HỆ THỐNG ÂM THANH & NHẠC NỀN ---
// 🧱 1. Biến toàn cục – Cấu hình & Khởi tạo
const safeZones = [
    { id: 1, name: "Safe Zone 1", x: 1500, y: 1000, radius: 150, active: false, tempActiveUntil: 0 },
    { id: 2, name: "Safe Zone 2", x: 400, y: 400, radius: 120, active: false, tempActiveUntil: 0 },
    { id: 3, name: "Safe Zone 3", x: 2600, y: 400, radius: 120, active: false, tempActiveUntil: 0 },
    { id: 4, name: "Safe Zone 4", x: 400, y: 1600, radius: 120, active: false, tempActiveUntil: 0 },
    { id: 5, name: "Safe Zone 5", x: 2600, y: 1600, radius: 120, active: false, tempActiveUntil: 0 }
];
// Mặc định bật Zone ID=2 khi vào game
for (const z of safeZones) { 
  const on = z.id === 2;
  z.active = on;          // có hiệu lực gameplay
  z.visible = on;         // có vẽ vòng tròn hay không
  z.expireAt = on ? Infinity : 0;  // nếu bạn có dùng expireAt
}
let safeZoneSchedule = {};
let SHOP_NPCS = [];
let currentActiveSafeZoneId = null;
let lastSafeZoneChangeHour = -1;

function initializeSafeZoneSystem() {
    // Create an NPC for each safe zone
    SHOP_NPCS = safeZones.map(zone => ({
        parentZoneId: zone.id,
        x: zone.x + Math.min(60, Math.max(36, Math.round(zone.radius * 0.40))),
        y: zone.y - Math.min(80, Math.max(24, Math.round(zone.radius * 0.45))),
        r: 22,
        icon: '🛒',
        name: 'Shop',
    }));
}

function updateSafeZoneStatus() {
    const now = Date.now();
    const hour = Math.floor(dayTime * 24) % 24;

    // Logic thay đổi zone mỗi 2 giờ chẵn
    const currentHourBlock = Math.floor(hour / 2);
    const lastHourBlock = Math.floor(lastSafeZoneChangeHour / 2);

    if (currentHourBlock !== lastHourBlock && lastSafeZoneChangeHour !== -1) {
        lastSafeZoneChangeHour = hour;

        // Tạo danh sách các zone có thể chọn (loại trừ zone hiện tại)
        const possibleNextZones = safeZones.filter(z => z.id !== currentActiveSafeZoneId);
        
        // Chọn ngẫu nhiên một zone mới từ danh sách
        const newZone = possibleNextZones[Math.floor(Math.random() * possibleNextZones.length)];
        
        if (newZone) {
            currentActiveSafeZoneId = newZone.id;
            
            // Gửi thông báo lên bản tin
            if (window.NewsTicker && typeof window.NewsTicker.pushMessage === 'function') {
                window.NewsTicker.pushMessage(`⚠️ Vùng an toàn đã di chuyển đến ${newZone.name}!`, true);
            }
        }
    }
    
    // Cập nhật trạng thái active cho tất cả các zone
    safeZones.forEach(zone => {
        // Ưu tiên kích hoạt tạm thời khi hồi sinh
        if (zone.tempActiveUntil > 0) {
            if (now < zone.tempActiveUntil) {
                zone.active = true;
                return;
            } else {
                zone.tempActiveUntil = 0;
            }
        }
        
        // Kích hoạt theo zone ngẫu nhiên đã được chọn
        zone.active = (zone.id === currentActiveSafeZoneId);
    });
}
let __npcHover = null; // Biến lưu NPC đang được trỏ chuột vào

function drawShopNPC(ctx) {
    safeZones.forEach(zone => {
        if (zone.active) {
            const n = SHOP_NPCS.find(npc => npc.parentZoneId === zone.id);
            if (!n) return;

            const isHovered = __npcHover && __npcHover.parentZoneId === zone.id;

            ctx.save();
            ctx.beginPath();
            ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
            ctx.fillStyle = '#1f2633';
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = isHovered ? '#ffd54f' : 'rgba(255,255,255,0.5)';
            ctx.stroke();
            ctx.font = '18px Segoe UI Emoji';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';
            ctx.fillText(n.icon, n.x, n.y);
            ctx.font = 'bold 12px Segoe UI';
            ctx.textBaseline = 'top';
            ctx.fillStyle = '#ffd54f';
            ctx.fillText('Shop', n.x, n.y + n.r + 4);
            ctx.restore();
        }
    });
}

function npcHitTestWorld(x, y) {
    for (const zone of safeZones) {
        if (zone.active) {
            const n = SHOP_NPCS.find(npc => npc.parentZoneId === zone.id);
            if (n) {
                const dx = x - n.x;
                const dy = y - n.y;
                const R = n.r + 10;
                if ((dx * dx + dy * dy) <= R * R) {
                    return n; // Trả về đối tượng NPC nếu trúng
                }
            }
        }
    }
    return null; // Trả về null nếu không trúng
}
// --- END: Safe Zone System ---

// Đặt ngay sau khối mã trên
initializeSafeZoneSystem();

// chuyển click -> toạ độ thế giới (không cấp phát rác)
function getMouseWorld(ev){
  const rect = canvas.getBoundingClientRect();
  const sx = canvas.width / rect.width;
  const sy = canvas.height / rect.height;
  const cx = (ev.clientX - rect.left) * sx;
  const cy = (ev.clientY - rect.top) * sy;
  return { x: cx + camera.x, y: cy + camera.y };
}

// mở shop (không "toggle" khi đã mở)
function openShopFromNPC(){
  const el = document.getElementById('shopOverlay');
  try { if (typeof populateShop === 'function') populateShop(); } catch {}
  if (el && (getComputedStyle(el).display === 'none' || el.classList.contains('hidden'))) {
    if (typeof toggleShop === 'function') toggleShop();
  } else if (el) {
    el.classList.remove('hidden');
  }
}

let lastStamina = 0;
let lastStaminaRegenTime = 0;
const STAMINA_REGEN_INTERVAL = 5000; // 5 giây
const STAMINA_REGEN_VALUE = 1;
let lastHpRegenTime = 0;       // Lưu mốc thời gian hồi máu lần cuối.
const HP_REGEN = 5000;          // Thời gian chờ giữa 2 lần hồi máu (10000ms = 10 giây).
const HP_REGEN_VALUE = 1;        // Lượng máu được hồi mỗi lần.
// ==== PATCH: helper tính giá trị hồi dựa vào trang bị ====
function getEffectiveSpRegen() {
  // +SP mỗi tick: base + trang bị
  return STAMINA_REGEN_VALUE + (window.player?.equipSpRegen || 0);
}
function getEffectiveHpRegen() {
  // +HP mỗi tick: base + trang bị
  return HP_REGEN_VALUE + (window.player?.equipHpRegen || 0);
}
function getEffectiveStaminaMax() {
  // Trần SP: base + bonus từ trang bị (nếu bạn đang dùng staminaMax)
  const base = (window.player?.staminaMax ?? 10);
  return base + (window.player?.equipStaminaMaxBonus || 0);
}

let camera = { x: 0, y: 0 }; // 📷 Vị trí camera
let backgroundStars = [];
let backgroundBirds = [];
let backgroundTrees = [];
let backgroundClouds = [];
let backgroundPlanes = [];
let backgroundMushrooms = [];
let backgroundRocks = [];
let backgroundBalloons = [];
let backgroundSeeds = [];
let dayTime = 0.25; // 0.25 = 6h Thời gian ban đầu
let dayDirection = 1; 
const dayDuration = 600; // 600 giây = 10 phút cho 1 chu kỳ ngày đêm
let lastUpdateTime = Date.now();
let prevIsNight = isNight();
let backgroundBigStars = [];
let globalDeltaTime = 0;
let currentDay = 1; // ✨ biến đếm số ngày trôi qua
// 🦋 Trạng thái kỹ năng Fairy
let fairyActive = false;
let fairyEndTime = 0;
let fairies = []; // Mảng chứa các Fairy
let lastFairyHealTime = 0;
let fairyDamageBonus = 0; // Lưu lại mức sát thương cộng thêm
let fairyDeathDefyAvailable = false; // Cờ cho cơ chế hồi sinh
let lastShieldBlockSoundTime = 0;
let luckyBuffEndTime = 0;
let powerBuffEndTime = 0;
let isPowerBuffActive = false; // Biến cờ để tránh nhân/chia sát thương nhiều lần
let crazyBuffEndTime = 0;
let isCrazyBuffActive = false;
let expBuffEndTime = 0;
let magnetBuffEndTime = 0;
let crazyMadnessTimeEndTime = 0;
let isCrazyMadnessTimeActive = false;
let crazyMadnessTimeBuffStats = {};
let supplyDrops = []; // Mảng chứa các kiện hàng 🪂
let morningDropTriggered = false; // Cờ để đảm bảo chỉ rơi 1 lần mỗi 9h sáng
let morningDropTriggered12h = false;    // Cho 12h
let morningDropTriggered15h = false;    // Cho 15h
// Dữ liệu quản lý hiệu ứng đóm sáng cho các buff
const buffEffects = {
    power:  { color: "#ef4444", active: false, angle: 0 }, // Đỏ (Power)
    crazy:  { color: "#f59e0b", active: false, angle: 0 }, // Vàng cam (Crazy)
    lucky:  { color: "#22c55e", active: false, angle: 0 }, // Xanh lá (Lucky)
    exp:    { color: "#ffeb3b", active: false, angle: 0 }, // Vàng (Exp)
    magnet: { color: "#8b5cf6", active: false, angle: 0 }, // Tím (Magnet)
    crazymadness: { color: "#3b82f6", active: false, angle: 0 }, // Xanh dương (CrazyMadnessTime)
    critRate: { color: "orange", active: false, angle: 0 }, // Cam (Crit Rate)
    critDmg:  { color: "#c084fc", active: false, angle: 0 }, // Tím nhạt (Crit Dmg)
// Thêm các buff khác nếu cần
};
// --- Tỉ lệ rơi vật phẩm trong game ---
const itemDropTable = [
  // --- Vật phẩm Siêu hiếm ---
  { type: 'crazymadnesstime', chance: 0.002 }, // 0.2%

  // --- Vật phẩm Hiếm ---
  { type: 'box',              chance: 0.006 }, // 0.6%
  { type: 'magnet',           chance: 0.003 }, // 0.3%
  { type: 'secret',           chance: 0.196 }, // 19.6%
  { type: 'potion',           chance: 0.015 }, // 1.5%

  // --- Buff (đã giảm) ---
  { type: 'lucky',            chance: 0.003 }, // 0.3%
  { type: 'power',            chance: 0.003 }, // 0.3%
  { type: 'crazy',            chance: 0.003 }, // 0.3%
  { type: 'exp',              chance: 0.003 }, // 0.3%
  { type: 'critRateBuff',     chance: 0.003 }, // 0.3%
  { type: 'critDmgBuff',      chance: 0.003 }, // 0.3%
  // --- Thường ---
  { type: 'expBonus',         chance: 0.010 }, // 1.0%
  { type: 'hp',               chance: 0.050 }, // 5.0%

  // ⭐ Điều chỉnh tại đây
  { type: 'coin',             chance: 0.200 }, // 20%
  { type: 'mana',             chance: 0.250 }, // 25%
  { type: 'energy',           chance: 0.250 } // 25%

];
// Tạo một bảng rơi đồ tạm thời cho việc test
/*const testDropTable = [
  { type: 'secret', chance: 1.0 } // 100% rơi vật phẩm này
];*/

// Biến để lưu trữ lượng chỉ số cộng thêm từ buff, giúp gỡ bỏ chính xác
let powerBuffDamageBonus = 0;
let crazyBuffStats = { speed: 0, bulletSpeed: 0, damage: 0 };

let debugKeyTimer = null; // Biến để lưu timer của phím Debug
// Menu ESC
let masterVolume = 1.0;
let musicVolume = 0.5;
let sfxVolume = 0.8;
// --- Cấu hình vật phẩm trong Shop ---
const shopItems = [
    { id: 'buy_10_mana',   name: '10 Mana',   icon: '💠', cost: 1, type: 'resource', value: 10 },
    { id: 'buy_10_energy', name: '10 Energy', icon: '⚡', cost: 1, type: 'resource', value: 10 },
    { id: 'buy_5_hp',      name: '5 HP',      icon: '❤️', cost: 1, type: 'resource', value: 5 },
    { id: 'buy_12_hp',      name: '12 HP',      icon: '❤️', cost: 2, type: 'resource', value: 12 },
    { id: 'buy_damage',    name: 'Dmg +0.2', icon: '💥', cost: 3, type: 'permanent_upgrade', value: 0.2 },
    // --- Mua đạn ---
    { id:'crit_rate_30s', name:'Crit Rate +15%', icon:'💥', type:'crit', sub:'rate', value:0.15, durationMs:60000, cost:4 },
    { id:'crit_dmg_30s',  name:'Crit Dmg +25%',  icon:'💥', type:'crit', sub:'dmg',  value:0.25, durationMs:60000, cost:4 },
    { id: 'buy_ice_arrow_speed', name: '+0.5 speed', icon: '🏹', cost: 3, type: 'permanent_upgrade' },
    { id: 'buy_ice_rate',   name: '+0.5 att.speed', icon: '🏹', cost: 10, type: 'ice', value: 0.5 },
    { id: 'buy_ice_damage', name: '+1 dmg',           icon: '🏹', cost: 5, type: 'ice', value: 1   },
    { id: 'buy_ammo_spiral', name: '+50 Xoắn ốc', icon: '🔄', cost: 10, type: 'ammo', value: 50, targetAmmoIndex: 0 },
    { id: 'buy_ammo_zigzag', name: '+75 Zigzag', icon: '↔️', cost: 10, type: 'ammo', value: 75, targetAmmoIndex: 1 },
    { id: 'buy_ammo_spiral_fwd', name: '+50 Xoắn', icon: '🎯', cost: 15, type: 'ammo', value: 50, targetAmmoIndex: 2 },
    { id: 'buy_ammo_piercing', name: '+25 Xuyên', icon: '🎯', cost: 20, type: 'ammo', value: 25, targetAmmoIndex: 3 },
    { id: 'buy_ammo_laser', name: '+10 Laze', icon: '💥', cost: 25, type: 'ammo', value: 10, targetAmmoIndex: 4 },
    // thêm các vật phẩm khác vào đây
    { id: 'buy_lucky',   name: 'Lucky',   icon: '🍀', cost: 15, type: 'buff' },
    { id: 'buy_power',   name: 'Power',   icon: '🍁', cost: 15, type: 'buff' },
    { id: 'buy_crazy',   name: 'Crazy',   icon: '🍂', cost: 15, type: 'buff' },
    { id: 'buy_exp',     name: 'EXP',     icon: '🌿', cost: 15, type: 'buff' },
    { id: 'buy_magnet',  name: 'Magnet',  icon: '🧲', cost: 10, type: 'buff' },
    { id: 'buy_madness', name: 'Madness', icon: '💢', cost: 25, type: 'buff' },
    // --- Nâng cấp Đao ---
{ id: 'buy_blade_dmg_1', name: 'Dmg +0.2', icon: '🔪', cost: 5, type: 'skill_damage_upgrade', value: 0.2, skillTarget: 'bladeDamage' },
{ id: 'buy_blade_dmg_2', name: 'Dmg +0.5', icon: '🔪', cost: 10, type: 'skill_damage_upgrade', value: 0.5, skillTarget: 'bladeDamage' },
{ id: 'buy_blade_dmg_3', name: 'Dmg +1',   icon: '🔪', cost: 18, type: 'skill_damage_upgrade', value: 1,   skillTarget: 'bladeDamage' },

// --- Nâng cấp Kiếm ---
{ id: 'buy_sword_dmg_1', name: 'Dmg +0.2', icon: '⚔️', cost: 5, type: 'skill_damage_upgrade', value: 0.2, skillTarget: 'swordDamage' },
{ id: 'buy_sword_dmg_2', name: 'Dmg +0.5', icon: '⚔️', cost: 10, type: 'skill_damage_upgrade', value: 0.5, skillTarget: 'swordDamage' },
{ id: 'buy_sword_dmg_3', name: 'Dmg +1',   icon: '⚔️', cost: 18, type: 'skill_damage_upgrade', value: 1,   skillTarget: 'swordDamage' },

// --- Nâng cấp Lửa ---
{ id: 'buy_fire_dmg_1', name: 'Dmg +0.2', icon: '🔥', cost: 5, type: 'skill_damage_upgrade', value: 0.2, skillTarget: 'fireDamage' },
{ id: 'buy_fire_dmg_2', name: 'Dmg +0.5', icon: '🔥', cost: 10, type: 'skill_damage_upgrade', value: 0.5, skillTarget: 'fireDamage' },
{ id: 'buy_fire_dmg_3', name: 'Dmg +1',   icon: '🔥', cost: 18, type: 'skill_damage_upgrade', value: 1,   skillTarget: 'fireDamage' },

// --- Nâng cấp Băng ---
{ id: 'buy_ice_dmg_1', name: 'Dmg +0.2', icon: '❄️', cost: 5, type: 'skill_damage_upgrade', value: 0.2, skillTarget: 'iceDamage' },
{ id: 'buy_ice_dmg_2', name: 'Dmg +0.5', icon: '❄️', cost: 10, type: 'skill_damage_upgrade', value: 0.5, skillTarget: 'iceDamage' },
{ id: 'buy_ice_dmg_3', name: 'Dmg +1',   icon: '❄️', cost: 18, type: 'skill_damage_upgrade', value: 1,   skillTarget: 'iceDamage' },

// --- Nâng cấp Lôi ---
{ id: 'buy_thunder_dmg_1', name: 'Dmg +0.2', icon: '🔵', cost: 5, type: 'skill_damage_upgrade', value: 0.2, skillTarget: 'thunderDamage' },
{ id: 'buy_thunder_dmg_2', name: 'Dmg +0.5', icon: '🔵', cost: 10, type: 'skill_damage_upgrade', value: 0.5, skillTarget: 'thunderDamage' },
{ id: 'buy_thunder_dmg_3', name: 'Dmg +1',   icon: '🔵', cost: 18, type: 'skill_damage_upgrade', value: 1,   skillTarget: 'thunderDamage' },
// --- Nâng cấp Vệ tinh laze ---
{ id: 'buy_satellite_dmg_1', name: 'Dmg +0.2', icon: '🛰️', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'Vệ tinh laze' },
{ id: 'buy_satellite_dmg_2', name: 'Dmg +0.5', icon: '🛰️', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'Vệ tinh laze' },
{ id: 'buy_satellite_dmg_3', name: 'Dmg +1',   icon: '🛰️', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'Vệ tinh laze' },

// --- Nâng cấp Tên lửa F18 ---
{ id: 'buy_missile_dmg_1', name: 'Dmg +0.2', icon: '🚀', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'Tên lửa F18' },
{ id: 'buy_missile_dmg_2', name: 'Dmg +0.5', icon: '🚀', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'Tên lửa F18' },
{ id: 'buy_missile_dmg_3', name: 'Dmg +1',   icon: '🚀', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'Tên lửa F18' },

// --- Nâng cấp UFO tấn công ---
{ id: 'buy_ufo_dmg_1', name: 'Dmg +0.2', icon: '🛸', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'UFO tấn công' },
{ id: 'buy_ufo_dmg_2', name: 'Dmg +0.5', icon: '🛸', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'UFO tấn công' },
{ id: 'buy_ufo_dmg_3', name: 'Dmg +1',   icon: '🛸', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'UFO tấn công' },

// --- Nâng cấp Bão sét ---
{ id: 'buy_lightning_dmg_1', name: 'Dmg +0.2', icon: '🌩️', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'Bão sét' },
{ id: 'buy_lightning_dmg_2', name: 'Dmg +0.5', icon: '🌩️', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'Bão sét' },
{ id: 'buy_lightning_dmg_3', name: 'Dmg +1',   icon: '🌩️', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'Bão sét' },

// --- Nâng cấp Bom B52 ---
{ id: 'buy_b52_dmg_1', name: 'Dmg +0.2', icon: '💣', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'Bom B52' },
{ id: 'buy_b52_dmg_2', name: 'Dmg +0.5', icon: '💣', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'Bom B52' },
{ id: 'buy_b52_dmg_3', name: 'Dmg +1',   icon: '💣', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'Bom B52' },

// --- Nâng cấp Ảo ảnh phân thân ---
{ id: 'buy_clone_dmg_1', name: 'Dmg +0.2', icon: '🎭', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'Ảo ảnh phân thân' },
{ id: 'buy_clone_dmg_2', name: 'Dmg +0.5', icon: '🎭', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'Ảo ảnh phân thân' },
{ id: 'buy_clone_dmg_3', name: 'Dmg +1',   icon: '🎭', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'Ảo ảnh phân thân' },

// --- Nâng cấp Hố đen ---
{ id: 'buy_blackhole_dmg_1', name: 'Dmg +0.2', icon: '🕳️', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'Hố đen' },
{ id: 'buy_blackhole_dmg_2', name: 'Dmg +0.5', icon: '🕳️', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'Hố đen' },
{ id: 'buy_blackhole_dmg_3', name: 'Dmg +1',   icon: '🕳️', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'Hố đen' },

// --- Nâng cấp Boom hạt nhân ---
{ id: 'buy_nuke_dmg_1', name: 'Dmg +10', icon: '☢️', cost: 10, type: 'active_skill_damage_upgrade', value: 10, skillName: 'Boom hạt nhân' },
{ id: 'buy_nuke_dmg_2', name: 'Dmg +25', icon: '☢️', cost: 20, type: 'active_skill_damage_upgrade', value: 25, skillName: 'Boom hạt nhân' },
{ id: 'buy_nuke_dmg_3', name: 'Dmg +50', icon: '☢️', cost: 35, type: 'active_skill_damage_upgrade', value: 50, skillName: 'Boom hạt nhân' },

// --- Nâng cấp Quả cầu hấp huyết ---
{ id: 'buy_bloodorb_dmg_1', name: 'Dmg +0.2', icon: '🩸', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'Quả cầu hấp huyết' },
{ id: 'buy_bloodorb_dmg_2', name: 'Dmg +0.5', icon: '🩸', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'Quả cầu hấp huyết' },
{ id: 'buy_bloodorb_dmg_3', name: 'Dmg +1',   icon: '🩸', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'Quả cầu hấp huyết' },

// --- Nâng cấp Cổng Không Gian ---
{ id: 'buy_spacegate_dmg_1', name: 'Dmg +0.2', icon: '🌀', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'Cổng Không Gian' },
{ id: 'buy_spacegate_dmg_2', name: 'Dmg +0.5', icon: '🌀', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'Cổng Không Gian' },
{ id: 'buy_spacegate_dmg_3', name: 'Dmg +1',   icon: '🌀', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'Cổng Không Gian' },

];
// ✨ DANH SÁCH CÁC LOẠI ZOMBIE ✨
const zombieTypes = [ // 52 loại zombie
    "Walker", "Brute", "Spitter", "Mutant",
    "Cyber", "Hunter", "Shadow", "Arcanist", "Soldier", "Robot",
    "Knight", "Rogue", "Wraith", "Astronaut", "Beast", "Spectre",
    "Ninja", "Samurai", "Alien", "Skeleton", "Mage", "Ghost",
    "Monk", "Cyborg", "Shaman", "Demon", "Angel", "Guardian",
    "Pilot", "Engineer", "Android", "Starfighter", "Commander", "Medic",
    "Barbarian", "Paladin", "Druid", "Necromancer", "Archer", "Sorcerer",
    "Bard", "Cleric", "Vampire", "Werewolf", "Goblin", "Elf",
    "Dwarf", "Orc", "Detective", "Swat", "Firefighter", "Doctor",
    "Wastelander", "Scavenger", "Hunter", "Plaguebearer", "Gravekeeper", "Revenant", "Stalker", "Abomination", "Wraith", "Butcher",
];
let lastBigBossTimerUpdate = performance.now();
let bigBossRespawnTimer = 0;
const bigBossRespawnInterval = 3; // Thời gian hồi sinh bigboss - giây
// TẠO BIẾN CHỨA KHO ÂM THANH
const sfxPool = {}; // Mỗi key là một ID âm thanh, value là một mảng các đối tượng Audio

/**
 * TẠO HÀM KHỞI TẠO KHO ÂM THANH
 * Hàm này sẽ chạy một lần duy nhất khi game bắt đầu.
 * Nó sẽ tạo sẵn một số lượng đối tượng Audio cho mỗi hiệu ứng âm thanh.
 * @param {number} poolSize - Số lượng đối tượng Audio tạo sẵn cho mỗi âm thanh.
 */
function initAudioPool(poolSize = 5, onProgress, onComplete) {
    console.log("Initializing audio resources...");
    
    // Tìm tất cả các thẻ audio cần tải trước
    const sfxElements = document.querySelectorAll('audio[id^="sfx-"]');
    const musicElements = document.querySelectorAll('audio[id^="music-"]');
    
    let totalToLoad = (sfxElements.length * poolSize) + musicElements.length;
    let loadedCount = 0;

    // Hàm này được gọi mỗi khi một file audio tải xong
    const handleLoad = () => {
        loadedCount++;
        if (onProgress) {
            onProgress(loadedCount, totalToLoad); // Gửi tiến trình ra ngoài
        }
        if (loadedCount >= totalToLoad && onComplete) {
            onComplete(); // Gọi callback khi hoàn tất
        }
    };

    // Xử lý các file hiệu ứng SFX (tạo thành kho)
    sfxElements.forEach(audioElement => {
        const id = audioElement.id;
        sfxPool[id] = {
            pool: [],
            currentIndex: 0
        };
        for (let i = 0; i < poolSize; i++) {
            const audio = new Audio(audioElement.src);
            // Lắng nghe sự kiện canplaythrough để biết khi nào có thể phát
            audio.addEventListener('canplaythrough', handleLoad, { once: true });
            audio.load();
            sfxPool[id].pool.push(audio);
        }
    });

    // Xử lý các file nhạc nền (chỉ cần tải 1 lần)
    musicElements.forEach(audioElement => {
        audioElement.addEventListener('canplaythrough', handleLoad, { once: true });
        audioElement.load();
    });

    // Xử lý trường hợp không có audio nào để tải
    if (totalToLoad === 0 && onComplete) {
        onComplete();
    }
}

// 🔫 Cấu hình bắn
let autoBurstIndex = 0;
let autoLastBurstTime = 0;
let clickShotMode = 5; // 0: xoắn ốc, 1: zigzag, 2: spiral, 3: xuyên thẳng, 4: mặc định

const autoBurstDelay = 100; // ms delay giữa từng viên trong auto

// 🧟 Thống kê – Kỹ năng & zombie
let zombieKillCount = 0;
let zombieSpawnedCount = 0;
let zombieByLevel = {};
for (let i = 1; i <= 10; i++) zombieByLevel[i] = 0;
zombieByLevel.boss = 0;
zombieByLevel.miniBoss = 0;
let skillStats = {};             // 📊 Thống kê kỹ năng
// 🎯 EXP lên cấp
const INITIAL_REQUIRED_EXP = 100; // EXP cần để lên cấp
// 🧍 Trạng thái người chơi
const player = {
  x: 480, y: 360, size: 20, speed: 1,
  hearts: 10, energy: 0, mana: 0,
  staminaMax: 10,
  stamina: 10,
  coins: 0,
  level: 1, score: 0,
  statPoints: 3, // Điểm nâng cấp
  maxHearts: 10,
  armor: 0, // Giáp
  exp: 0,
  currentLevelExp: 0, // EXP hiện tại của level
  requiredExp: INITIAL_REQUIRED_EXP,  // EXP cần để lên cấp
  hitTimer: 0,
  name: "Player",
  isDying: false,
  isTeleporting: false,      // Cờ báo hiệu đang trong quá trình dịch chuyển
  isGrowingAfterTeleport: false, // Cờ báo hiệu đang lớn dần ra sau khi dịch chuyển
  originalSize: 20,          // Dùng để lưu lại kích thước gốc
  // Lưu trữ số lượng đạn cho từng loại
  // Các key (0-4) tương ứng với clickShotMode
  ammo: {
    0: 100, // Đạn Xoắn ốc
    1: 150, // Đạn Zigzag
    2: 100, // Đạn Xoắn bay thẳng
    3: 50,  // Đạn Xuyên thẳng
    4: 20   // Đạn Laze
  }
};

// 🌟 Trạng thái nâng cấp
const playerUpgrades = {
  iceArrow: 1,          // 🏹 Ice Arrow
  damageBoost: 1,       // 💥 Sát thương cơ bản cộng thêm
  hpBoost: 0,           // ❤️ Số lần đã tăng máu
  bulletSpeed: 1,       // 💨 Tốc độ đạn
  lineBulletCount: 1    // 🧨 Số lượng đạn
};
// 🛒 Shop-only
const shopUpgrades = {
  iceArrowSpeedLevel: 0, // 0..3
};
// 🌟 Biến nâng cấp kỹ năng mặc định (🔪 Đao, ⚔️ Kiếm, 🔥 Lửa, ❄️ Băng)
const skillUpgrades = {
  // 🔪 Đao: số lượng đao và sát thương từng đao
  bladeCount: 2,           // bắt đầu 2 đao, tối đa 20
  bladeDamage: 1,          // sát thương từng đao

  // ⚔️ Kiếm: cấp độ mưa kiếm (số lượng + sát thương)
  swordLevel: 1,           // cấp độ mưa kiếm, tối đa 10
  swordDamage: 3,          // sát thương mỗi kiếm

  // 🔥 Lửa: số lượng cầu lửa và sát thương
  fireCount: 2,            // bắt đầu 2 quả cầu, tối đa 10
  fireDamage: 1,           // sát thương mỗi quả

  // ❄️ Băng: số lượng cầu băng và sát thương
  iceCount: 2,             // bắt đầu 2 quả cầu, tối đa 10
  iceDamage: 2,             // sát thương mỗi quả
  // Lôi
  thunderCount: 2,         // bắt đầu 2 quả cầu lôi, tối đa 6
  thunderDamage: 3,        // sát thương mỗi quả cầu lôi
  // 🦋 Nâng cấp kỹ năng Fairy
  fairyCount: 1,      // Số lượng Fairy, tối đa 3
  fairyHealLevel: 0,  // Cấp độ hồi máu
  fairyDamageLevel: 0, // Cấp độ tăng sát thương
  
  auraHealLevel: 0, // Cấp độ hồi máu của Hào quang, bắt đầu từ 0

};
let petActive = false;
let petEndTime = 0;
let petRabbit = null;
let petLastHealTime = 0;
/* ── chống chọn lại món đồ vừa bỏ ── */
let lastGiveUpId   = null;   // id món đồ vừa bị bỏ
let lastGiveUpTime = 0;      // mốc thời gian bỏ
const RESELECT_CD  = 2000;   // 2 000 ms → cấm chọn lại 2 s
let auraCrackLines = []; // Mảng chứa các đường nứt phát sáng dưới đất
let auraLightBeams = []; // Mảng chứa các cột sáng bay lên
let supportAuraActive = false;
let supportAuraEndTime = 0;
let lastAuraHealTime = 0;
// ⚙️ Trạng thái điều khiển & kỹ năng
let lastManualShootTime = 0;
const manualShootCooldown = 500; // Tốc độ bắn thủ công (click chuột)
let lastAutoShootTime = 0;
const autoShootCooldown = 500;
let playerLasers = []; // Mảng chứa các tia laze của người chơi

let keys = {};
let autoShoot = false;
let fireActive = false;
let iceActive = false;
let swordActive = false;
let bladeActive = false;
let frame = 0;
let gameOver = false;
let isPaused = false;
let pendingWave = null;
let uiVisible = true; // Trạng thái hiển thị UI
let swordRainClouds = [];
let nextFireIndex = 0; // Kỹ năng đao xoay

// Kỹ năng active
let satelliteActive = false;
let satelliteEndTime = 0;
let satellites = [];

let ufoActive = false; // Kỹ năng UFO
let ufoEndTime = 0;
let ufoCooldown = 0;
let ufoCount = 1;
let ufos = [];
// ========================= ⚡ Lightning – trạng thái & dữ liệu =========================
let lightningActive = false; // Kỹ năng sét - trạng thái & dữ liệu
let lightningEndTime = 0;
let lightningBolts = [];
let activeLightningStrikes = [];
let nextLightningStrikeTime = 0;
let disguiseActive = false;
let disguiseEndTime = 0;

let clones = []; // 🎭 Global – lưu các bản sao hiện tại
let clonesActive = false;
let clonesEndTime = 0;
let activeCloneLasers = []; // Mảng chứa các tia lazer của clone

let blackHoles = []; // Danh sách hố đen
let extraShockwaves = []; // 🌊 các vòng nổ phụ lan ra

let bloodOrbActive = false;
let bloodOrbEndTime = 0;
let bloodOrbs = []; // [{ angle, radius, x, y }]
let bloodOrbCount = 1; // về sau nâng cấp +1 quả cầu
let bloodOrbLastDrain = 0;
let particles = [];
let healEffects = []; // Tạo "Kho" Chứa Hiệu ứng

// 🚪 Trạng thái Cổng Không Gian
let spaceGate = null; // Biến chứa đối tượng cổng
let spaceGateActive = false;
let spaceGateEndTime = 0;
let lastTeleportTime = 0; // Lưu thời điểm dịch chuyển cuối
const GATE_COOLDOWN = 2000; // 1000ms = 1 giây chờ
// Quản lý trạng thái animation khi dịch chuyển
let playerTeleportState = {
    phase: null, // các giai đoạn: 'shrinking', 'growing'
    progress: 0, // tiến trình của hiệu ứng (từ 1.0 xuống 0.0 và ngược lại)
    originalPlayerSize: 0,
    originalGateRadius: 0,
};

// 🌊 Quản lý wave
let wave = 1;
let waveTime = 90; // Thời gian mỗi wave
let waveTimer = waveTime;
let lastWaveTime = null;
let gameStarted = false;

// ⏱ Thời gian kỹ năng
let fireEndTime = 0;
let iceEndTime = 0;
let swordEndTime = 0;
let bladeEndTime = 0;
let levelUpGlowTime = 0;
let nextBladeToAttack = 0; // Theo dõi thứ tự của đao sắp tấn công
let lastBladeLaunchTime = 0; // Mốc thời gian của lần phóng đao cuối

// 📱 Điều khiển cảm ứng
let touchStartX = null, touchStartY = null;
let touchMoveX = null, touchMoveY = null;

// 🎮 Danh sách các đối tượng trong game
let enemyBullets = []; // Zombie bắn trả
let zombies = [];
let bullets = [];
let swords = [];
let downwardSwords = [];
let fireballs = [];
let iceballs = [];
let thunderActive = false;
let thunderEndTime = 0;
let thunderBalls = [];
let items = [];
let explosions = [];
let missiles = []; // 🚀 Danh sách tên lửa đang bay
let expandingExplosions = []; // ☢️ Các vòng nổ lan rộng (dùng cho bom hạt nhân)
let nuclearBombs = []; // Mảng lưu trữ riêng bom hạt nhân
let bombsB52 = []; // 💣 Danh sách bom B52
let activePlanes = [];   // 🛬 Danh sách máy bay đang hoạt động

// 🔧 Vẽ Canvas
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
// === SHOP NPC input (capture để chặn bắn) ================================
canvas.addEventListener('mousemove', function(e){
  const p = getMouseWorld(e);
  const over = npcHitTestWorld(p.x, p.y);
  if (over !== __npcHover){ __npcHover = over; }
  if (over) canvas.style.cursor = 'pointer';
}, true);

canvas.addEventListener('mousedown', function(e){
  const p = getMouseWorld(e);
  if (npcHitTestWorld(p.x, p.y)) {
    e.preventDefault();
    e.stopImmediatePropagation(); // chặn handler bắn đạn phía sau
    openShopFromNPC();
  }
}, true);

// ========= Zombie Inspector — Hover to show popup (no Ctrl+Click) =========
(function ZombieInspectorHover() {
  const canvas = document.getElementById('game')
             || document.getElementById('gameCanvas')
             || document.getElementById('canvas')
             || document.querySelector('canvas');
  if (!canvas) { console.warn('[Inspector] Không tìm thấy canvas'); return; }

  // ====== Cấu hình kỹ năng mặc định ======
  // Kỹ năng mặc định theo LOẠI (có thể sửa/ mở rộng tuỳ ý)
  const SKILL_BY_TYPE = {
    normal:   ['Cắn'],
    elite:    ['Cắn mạnh'],
    miniBoss: ['Cắn rát'],
    boss:     ['Cắn sâu'],
    bigBoss:  ['Laze Cuồng nộ']
  };
  // Ghi đè theo TÊN cụ thể (ưu tiên cao hơn type). Ví dụ:
  // 'Zombie Băng': ['Đóng băng', 'Bắn mảnh băng']
  const SKILL_BY_NAME = {
    // Thêm: 'TênZombie': ['Skill A', 'Skill B']
    Ninja: ['Phi tiêu'],
  };

  const ZLIST = () => (typeof zombies !== 'undefined' ? zombies :
                      (window.zombies || window.enemyList || window.enemies || []));
  const CAMX  = () => (typeof camera  !== 'undefined' ? (camera.x||0) :
                      (window.camera?.x ?? window.camX ?? window.cameraX ?? 0));
  const CAMY  = () => (typeof camera  !== 'undefined' ? (camera.y||0) :
                      (window.camera?.y ?? window.camY ?? window.cameraY ?? 0));

  function fmtAbbr(n){ n=Math.max(0,Math.floor(n||0)); const t=v=>String(v.toFixed(1)).replace(/\.0$/,'');
    if(n>=1e9)return t(n/1e9)+'B'; if(n>=1e6)return t(n/1e6)+'M'; if(n>=1e3)return t(n/1e3)+'k'; return String(n); }

  function toCanvasSpace(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const sx = canvas.width  / rect.width;
    const sy = canvas.height / rect.height;
    return { x: (clientX-rect.left)*sx, y: (clientY-rect.top)*sy };
  }
  function worldToScreen(x, y){ return { x: x - CAMX(), y: y - CAMY() }; }

  function pickZombieAt(sx, sy){
    const list = ZLIST();
    let best=null, bestD=1e9;
    for (let i=0;i<list.length;i++){
      const z = list[i];
      if (!z || z.hp<=0 || z.active===false || z.dead) continue;
      const p = worldToScreen(z.x, z.y);
      const r = (z.radius || 16) + 12;
      const d = Math.hypot(p.x - sx, p.y - sy);
      if (d < r && d < bestD) { best = z; bestD = d; }
    }
    return best;
  }

  function ensurePopup(){
    let el = document.getElementById('zombieInfoPopup');
    if (!el){
      el = document.createElement('div');
      el.id='zombieInfoPopup';
      el.style.cssText = `
        position:fixed;z-index:9999;max-width:280px;padding:10px 12px;border-radius:10px;
        background:rgba(20,16,24,.92);border:1px solid #a855f7;box-shadow:0 8px 24px rgba(168,85,247,.25);
        color:#eee;font:12px/1.35 system-ui,Arial,sans-serif;backdrop-filter:blur(4px);
        display:none; pointer-events:none
      `;
      document.body.appendChild(el);
    }
    return el;
  }
  function hidePopup(){ const el = document.getElementById('zombieInfoPopup'); if (el) el.style.display='none'; }
  function placePopup(clientX, clientY){
    const el = document.getElementById('zombieInfoPopup');
    if (!el || el.style.display==='none') return;
    const r = el.getBoundingClientRect(), vw=innerWidth, vh=innerHeight;
    let L = clientX + 12, T = clientY + 12;
    if (L + r.width  > vw - 8) L = vw - r.width  - 8;
    if (T + r.height > vh - 8) T = vh - r.height - 8;
    el.style.left = L + 'px'; el.style.top = T + 'px';
  }

  // Lấy Max HP an toàn
  function getMaxHP(z) {
    const cur = Number(z.hp ?? z.health ?? 0);
    const cand = [ z.hpMax, z.maxHp, z.maxHP, z.baseHp, z.baseHP, z.maxHealth, z.healthMax, z.hp_cap, z.hp_max ]
      .map(v => Number(v ?? 0)).filter(v => v > 0);
    const best = cand.length ? Math.max(...cand) : 0;
    return Math.max(1, cur, best);
  }

  // Nhận diện LOẠI (trả về key & label; có cả 'normal')
  function getType(z) {
    const isBigBoss = !!(z.isBigBoss || z.bigBoss || z.rank === 'bigBoss' || z.type === 'bigBoss');
    const isBoss    = !isBigBoss && !!(z.isBoss || z.boss || z.rank === 'boss' || z.type === 'boss');
    const isMini    = !isBigBoss && !isBoss && !!(
      z.isMiniBoss || z.miniBoss || z.isMini || z.mini ||
      z.rank === 'miniBoss' || z.rank === 'mini_boss' ||
      z.type === 'miniBoss' || z.type === 'mini_boss' || z.level === 99
    );
    const isElite   = !!(z.isElite || z.elite || z.rank === 'elite' || z.tier === 'elite');

    /** Chọn duy nhất 1 loại chính để hiển thị & map skill */
    let typeKey = 'normal', typeLabel = 'Thường';
    if (isBigBoss) { typeKey = 'bigBoss'; typeLabel = 'Big Boss'; }
    else if (isBoss) { typeKey = 'boss'; typeLabel = 'Boss'; }
    else if (isMini) { typeKey = 'miniBoss'; typeLabel = 'Mini Boss'; }
    else if (isElite){ typeKey = 'elite'; typeLabel = 'Tinh anh'; }

    return { typeKey, typeLabel };
  }

  // Lấy danh sách kỹ năng theo ưu tiên:
  // 1) z.skills (nếu có)  >  2) override theo tên  >  3) theo loại  >  4) z.skillNames  >  []
  function getSkillsFor(z, typeKey) {
    const explicit = Array.isArray(z.skills) ? z.skills : (Array.isArray(z.skillNames) ? z.skillNames : null);
    if (explicit && explicit.length) return explicit;

    const nameKey = String(z.displayName || z.name || z.style || '').trim();
    if (nameKey && Array.isArray(SKILL_BY_NAME[nameKey])) return SKILL_BY_NAME[nameKey];

    const byType = SKILL_BY_TYPE[typeKey];
    return Array.isArray(byType) ? byType : [];
  }

  function tagHTML(t){
    return `<span style="display:inline-block;padding:1px 6px;border-radius:999px;border:1px solid rgba(255,255,255,.15);font-size:11px;margin-right:6px">${t}</span>`;
  }
// EXP cơ bản (trước ±10% và buff), bám đúng 3.1 bạn gửi
function calcExpBase(z){
  const w = (typeof wave !== 'undefined' ? wave : (globalThis.wave|0)) || 1;

  if (z.isBigBoss) return calculateScaledBossExp(1000, w);
  if (z.isBoss)    return calculateScaledBossExp(100,  w);
  if (z.type === 'miniBoss' || z.isMiniBoss) return calculateScaledBossExp(10, w);

  const base = z.isElite ? 5 : 1;
  const levelBonus = (z.level || 1) - 1;
  const waveBonus  = w - 1;
  return base + levelBonus + waveBonus;
}
  function showZombieInfo(z, clientX, clientY){
    const el = ensurePopup();
    const name = z.style || z.name || 'Zombie';
    const lv   = z.level ?? 1;

    const hp    = Number(z.hp ?? z.health ?? 0);
    const maxHp = getMaxHP(z);
    const pct   = maxHp > 0 ? Math.round(Math.min(1, hp / maxHp) * 100) : 0;

    // Loại + kỹ năng
    const { typeKey, typeLabel } = getType(z);
    const skills = getSkillsFor(z, typeKey);

    // ✅ EXP đúng số sẽ nhận nếu giết hiện tại
    const baseExp = calcExpBase(z);
// Hiển thị sát thương cơ bản của zombie (trước giáp & buff của player)
const atk = (typeof calculateZombieDamage === 'function')
  ? calculateZombieDamage(z)
  : Math.max(1, z.damage || z.baseDamage || 1);
  const armor = Math.max(0, Number(z.armor || 0));
    // 🏃 Speed: lấy speed hiện tại, kèm baseSpeed để so nhanh/chậm
    const spd  = Number(z.speed ?? z.baseSpeed ?? 0);
    const bspd = Number(z.baseSpeed ?? spd);
    el.innerHTML = `
      <h4 style="margin:0 0 6px;font-size:14px;color:#d9b8ff">${name} <span style="opacity:.8">Lv${lv}</span></h4>
      <div style="margin-top:2px">HP: ${fmtAbbr(hp)} / ${fmtAbbr(maxHp)} (${pct}%)</div>
      <div style="margin-top:2px">Giáp: ${fmtAbbr(armor)}</div>
      <div style="margin-top:2px">EXP: ${fmtAbbr(baseExp)} <span style="opacity:.8">(±10%)</span></div>
      <div style="margin-top:2px">ATK: ${fmtAbbr(atk)} <span style="opacity:.8">(+${z._atkRnd ?? 0} rng)</span></div>
      <div style="margin-top:2px">SPD: ${spd.toFixed(2)} <span style="opacity:.8">(chase ${bspd.toFixed(2)})</span></div>
      <div style="margin-top:6px">Zombie: ${tagHTML(typeLabel)}</div>
      <div style="margin-top:6px">Kỹ năng: ${
        (skills && skills.length) ? skills.map(s=>tagHTML(s)).join(' ') : '<span style="opacity:.8">—</span>'
      }</div>
      ${z.desc || z.description ? `<div style="margin-top:6px;opacity:.8">${z.desc || z.description}</div>` : ''}
    `;
    el.style.display='block';
    placePopup(clientX, clientY);
  }

  // Hover logic (re-render khi đổi wave)
  let lastShown=null, lastShowTs=0, lastShownWave = (typeof wave !== 'undefined' ? wave : (globalThis.wave|0)) || 1;

  canvas.addEventListener('mousemove', (e)=>{
    const {x,y} = toCanvasSpace(e.clientX, e.clientY);
    const cur = pickZombieAt(x, y);
    canvas.style.cursor = cur ? 'pointer' : 'default';
    if (!cur){ hidePopup(); lastShown=null; return; }

    const ts = performance.now();
    const wNow = (typeof wave !== 'undefined' ? wave : (globalThis.wave|0)) || 1;

    if (cur === lastShown && wNow === lastShownWave) { placePopup(e.clientX, e.clientY); return; }
    if (ts - lastShowTs < 50) { placePopup(e.clientX, e.clientY); return; }
    lastShown = cur; lastShowTs = ts; lastShownWave = wNow;
    showZombieInfo(cur, e.clientX, e.clientY);
  }, true);

  canvas.addEventListener('mouseleave', ()=>{ lastShown=null; hidePopup(); canvas.style.cursor='default'; }, true);
  console.info('[Inspector] Hover popup đã gắn vào', canvas);
})();
// ========= Equip Drop Hover — centralized in index =========
(function EquipDropHover(){
  const canvas = document.getElementById('game')
             || document.getElementById('gameCanvas')
             || document.querySelector('canvas');
  if (!canvas) return;

  // --- DOM: one-time popup for equip
  function ensureEquipPopup() {
    let el = document.getElementById('equipInfoPopup');
    if (!el) {
      el = document.createElement('div');
      el.id = 'equipInfoPopup';
      el.style.cssText = `
        position:fixed; z-index:10060; max-width:320px;
        padding:8px 10px; border-radius:10px;
        background:rgba(15,18,26,.96);
        border:1px solid rgba(255,255,255,.12);
        box-shadow:0 6px 24px rgba(0,0,0,.35);
        color:#fff; font:12px/1.35 system-ui,Segoe UI,Roboto;
        white-space:normal; pointer-events:none; display:none;
      `;
      document.body.appendChild(el);
    }
    return el;
  }
  function hideEquipPopup(){ const el = document.getElementById('equipInfoPopup'); if (el) el.style.display='none'; }
  function placeEquipPopup(clientX, clientY){
    const el = document.getElementById('equipInfoPopup');
    if (!el || el.style.display==='none') return;
    const r = el.getBoundingClientRect(), vw=innerWidth, vh=innerHeight;
    let L = clientX + 12, T = clientY + 12;
    if (L + r.width  > vw - 8) L = vw - r.width  - 8;
    if (T + r.height > vh - 8) T = vh - r.height - 8;
    el.style.left = L + 'px'; el.style.top = T + 'px';
  }

  // --- Helpers: dùng cùng camera/canvas với zombie tooltip
  const CAMX  = () => (typeof camera !== 'undefined' ? (camera.x||0) : (window.camera?.x ?? 0));
  const CAMY  = () => (typeof camera !== 'undefined' ? (camera.y||0) : (window.camera?.y ?? 0));
  function worldToScreen(x, y){ return { x: x - CAMX(), y: y - CAMY() }; }
  function toCanvasSpace(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const sx = canvas.width  / rect.width;
    const sy = canvas.height / rect.height;
    return { x: (clientX-rect.left)*sx, y: (clientY-rect.top)*sy };
  }

// --- Builder cho tooltip trang bị (string HTML) — dùng chung với Kho đồ
function buildEquipTooltipHTML(entry){
  // Ưu tiên dùng builder của Kho đồ để đồng bộ hoàn toàn
  if (typeof window.buildEquipTooltipHTML === 'function') {
    return window.buildEquipTooltipHTML(entry); // <- dùng chung
  }
  // Fallback rất gọn đề phòng character_panel chưa load
  const name   = entry?.name || 'Trang bị';
  const icon   = entry?.icon || '⬚';
  const tier   = Number(entry?.tier || 1);
  const rarity = String(entry?.rarity || 'common').toUpperCase();
  return `
    <div style="font-weight:700">${icon} ${name}</div>
    <div style="opacity:.8;margin-top:2px">Bậc ${tier} • ${rarity}</div>
  `;
}

  // --- Hover state (hysteresis)
  let lastClientX=-1, lastClientY=-1;
  let lastCamX=CAMX(), lastCamY=CAMY();
  let hovered = null; // {dropRef, enterR, leaveR}
  let nextScanAt = 0;

  canvas.addEventListener('mousemove', (ev)=>{
    lastClientX = ev.clientX;
    lastClientY = ev.clientY;
    nextScanAt = 0; // scan ngay
  }, {passive:true});
  canvas.addEventListener('mouseleave', ()=>{ hovered=null; hideEquipPopup(); }, {passive:true});

  function scan(){
    const api = window.EquipmentDropAPI;
    if (!api || (!api.getActiveDropsRef && !api.forEachActiveDrop)) return;

    const camx = CAMX(), camy = CAMY();
    const camMoved = (camx!==lastCamX) || (camy!==lastCamY);
    lastCamX=camx; lastCamY=camy;

    if (lastClientX<0 || lastClientY<0) { if (hovered) { hovered=null; hideEquipPopup(); } return; }

    const cvsPt = toCanvasSpace(lastClientX, lastClientY);
    const sx = cvsPt.x, sy = cvsPt.y;

    let best=null, bestD=1e9;
    const enterR = hovered? hovered.enterR : 24;
    const leaveR = hovered? hovered.leaveR : 32;

    // iterate drops — không tạo mảng mới
    if (api.forEachActiveDrop){
      api.forEachActiveDrop((d)=>{
        const p = worldToScreen(d.x, d.y);
        const dx=p.x - sx, dy=p.y - sy;
        const dist = Math.hypot(dx,dy);
        const r = (hovered && hovered.dropRef===d) ? leaveR : enterR;
        if (dist < r && dist < bestD){ best=d; bestD=dist; }
      });
    } else {
      const arr = api.getActiveDropsRef();
      for (let i=0;i<arr.length;i++){
        const d = arr[i];
        if (!d || !d.active) continue;
        const p = worldToScreen(d.x, d.y);
        const dx=p.x - sx, dy=p.y - sy;
        const dist = Math.hypot(dx,dy);
        const r = (hovered && hovered.dropRef===d) ? leaveR : enterR;
        if (dist < r && dist < bestD){ best=d; bestD=dist; }
      }
    }

    if (best){
      if (!hovered || hovered.dropRef!==best){
        const html = buildEquipTooltipHTML(best.entry || {});
        const el = ensureEquipPopup();
        el.innerHTML = html;
        // tô màu viền theo rarity
        const cfg = window.EquipmentDropAPI?.CONFIG || {};
        const rColor = (cfg.RARITY_COLOR && best.entry && cfg.RARITY_COLOR[best.entry.rarity]) || '#60a5fa';
        el.style.borderColor = rColor;
        el.style.boxShadow = `0 8px 24px ${rColor}40`;
        el.style.display='block';
        hovered = { dropRef:best, enterR:24, leaveR:32 };
      }
      placeEquipPopup(lastClientX, lastClientY);
    } else if (hovered){
      hovered=null;
      hideEquipPopup();
    }
  }

  // rAF loop — chỉ scan khi cần (50ms)
  (function loop(){
    requestAnimationFrame(loop);
    const now = performance.now();
    if (now < nextScanAt) return;
    nextScanAt = now + 50;
    scan();
  })();
})();
/* SunTimeTooltip — phiên bản tối ưu: không chạy khi ẩn, không update thừa */
(function(){
  const canvas = document.getElementById('game')
              || document.getElementById('gameCanvas')
              || document.querySelector('canvas');
  if (!canvas) return;

  let tip, visible = false, rafId = 0, lastText = "";

  function ensureTip(){
    if (tip) return tip;
    tip = document.createElement('div');
    tip.id = 'sunTimeTooltip';
    tip.style.cssText = `
      position:fixed; z-index:10040; padding:6px 8px; border-radius:8px;
      background:rgba(10,12,18,.92); border:1px solid rgba(255,255,255,.12);
      box-shadow:0 8px 24px rgba(0,0,0,.35);
      color:#fff; font:12px/1.35 system-ui,Segoe UI,Roboto;
      pointer-events:none; display:none; white-space:nowrap;`;
    document.body.appendChild(tip);
    return tip;
  }

  function toCanvasSpace(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const sx = canvas.width  / rect.width;
    const sy = canvas.height / rect.height;
    return { x: (clientX - rect.left) * sx, y: (clientY - rect.top) * sy };
  }

  // Vị trí icon mặt trời trên canvas
  const ICON_X = 28, ICON_Y = 82, HIT_R = 18;

  function fmtTime(){
    const total = Math.floor((dayTime * 24 * 3600) % 86400);
    const h = Math.floor(total / 3600);
    const m = Math.floor((total % 3600) / 60);
    const s = total % 60;
    const pad = n => String(n).padStart(2, '0');
    return `${pad(h)}:${pad(m)}:${pad(s)}`;
  }

  function startRAF(){
    if (rafId) return;
    const loop = () => {
      if (!visible) { rafId = 0; return; }
      const t = `Giờ: ${fmtTime()}`;
      if (t !== lastText) { lastText = t; tip.textContent = t; }
      rafId = requestAnimationFrame(loop);
    };
    rafId = requestAnimationFrame(loop);
  }

  function show(clientX, clientY){
    const el = ensureTip();
    lastText = ""; // buộc viết lại lần đầu
    el.style.display = 'block';
    // đặt vị trí cạnh trỏ & tránh tràn
    const r = el.getBoundingClientRect(), vw = innerWidth, vh = innerHeight;
    let L = clientX + 12, T = clientY + 12;
    if (L + r.width  > vw - 8) L = vw - r.width  - 8;
    if (T + r.height > vh - 8) T = vh - r.height - 8;
    el.style.left = L + 'px';
    el.style.top  = T + 'px';
    visible = true;
    startRAF();
  }

  function hide(){
    if (tip) tip.style.display = 'none';
    visible = false;
  }

  canvas.addEventListener('mousemove', (ev) => {
    const { x, y } = toCanvasSpace(ev.clientX, ev.clientY);
    const dx = x - ICON_X, dy = y - ICON_Y;
    if (dx*dx + dy*dy <= HIT_R*HIT_R) show(ev.clientX, ev.clientY);
    else hide();
  }, { passive: true });

  canvas.addEventListener('mouseleave', hide, { passive: true });
})();

// 🌀 Object Pooling
const bulletPool = [];
const explosionPool = [];
const zombiePool = [];
const swordPool = [];
const fireballPool = [];
const iceballPool = [];

//📲 2. Sự kiện điều khiển bàn phím, chuột, cảm ứng
// ⌨️ Bàn phím di chuyển
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

// 🖱 Click chuột để bắn
canvas.addEventListener("click", () => {
    if (window.isPlayerInSafeZone) { e.preventDefault(); return; } // ⛳ chặn bắn trong Safe Zone
  const now = Date.now();
  if (now - lastManualShootTime < manualShootCooldown) return;

  if (zombies.length === 0) return;

  // ✨ BƯỚC KIỂM TRA ĐẠN MỚI ✨
  // Nếu là loại đạn đặc biệt (không phải Mặc định)
  if (clickShotMode !== 5) { 
      if (player.ammo[clickShotMode] <= 0) {
          const modeNames = ["Xoắn ốc", "Zigzag", "Xoắn bay thẳng", "Xuyên thẳng", "Laze"];
          showWarning(`Hết đạn ${modeNames[clickShotMode]}!`);
          return; // Dừng, không cho bắn
      }
      // Nếu còn đạn, trừ đi 1 viên và cập nhật hiển thị
      player.ammo[clickShotMode]--;
      updateAmmoDisplay();
  }

  // Nếu đang ở chế độ laze, gọi hàm bắn laze và kết thúc
  if (clickShotMode === 4) {
      firePlayerLaser();
      return;
  }

  // Logic bắn đạn thường (giữ nguyên)
  lastManualShootTime = now; // Đặt lại cooldown cho đạn thường
  const target = zombies.reduce((a, b) =>
    distance(a, player) < distance(b, player) ? a : b
  );

  const angle = Math.atan2(target.y - player.y, target.x - player.x);
  const bullet = getBullet();
  bullet.x = player.x;
  bullet.y = player.y;
  bullet.speed = playerUpgrades.bulletSpeed;
  bullet.active = true;
  bullet.color = "cyan";
  bullet.piercing = true;
  bullet.rotation = 0;

  // ======= Kiểu bắn tùy theo clickShotMode =======
  if (clickShotMode === 0) {
    // 🔄 Xoắn ốc quanh player
    bullet.curveMode = true;
    bullet.angle = angle;
    bullet.curveRadius = 0;
    bullet.curveSpeed = 0.1 + Math.random() * 0.05;

  } else if (clickShotMode === 1) {
    // ↔️ Zigzag
    bullet.zigzagMode = true;
    bullet.baseAngle = angle;
    bullet.oscillatePhase = Math.random() * Math.PI * 2;
    bullet.oscillateSpeed = 0.2;
    bullet.oscillateAmplitude = 20;
    bullet.travel = 0;
    bullet.startX = player.x;
    bullet.startY = player.y;

  } else if (clickShotMode === 2) {
    // 🎯 Xoắn ốc bay thẳng
    bullet.spiralForwardMode = true;
    bullet.baseAngle = angle;
    bullet.travel = 0;
    bullet.spiralRadius = 15;
    bullet.spiralSpeed = 0.3;
    bullet.spiralPhase = Math.random() * Math.PI * 2;
    bullet.startX = player.x;
    bullet.startY = player.y;

  } else if (clickShotMode === 3) {
    // 🎯 Kiểu 3 – Xuyên thẳng
    bullet.dx = Math.cos(angle);
    bullet.dy = Math.sin(angle);
    bullet.piercing = true;

  } else if (clickShotMode === 5) { // Chuyển kiểu mặc định sang số 5
    // 🔵 Kiểu 5 – Giống auto shoot
    bullet.dx = Math.cos(angle);
    bullet.dy = Math.sin(angle);
    bullet.piercing = false; // ❗ không xuyên
  }
  // ================================================

  bullets.push(bullet);
});
// Gán sự kiện middle click (chuột giữa) để chuyển kiểu bắn
canvas.addEventListener("mousedown", (e) => {
    if (window.isPlayerInSafeZone) { e.preventDefault(); return; } // ⛳ chặn bắn trong Safe Zone
  if (e.button === 1) {
    clickShotMode = (clickShotMode + 1) % 6;
    const modeNames = [ "🔄 Xoắn ốc", "↔️ Zigzag", "🎯 Xoắn bay thẳng", "🎯 Xuyên thẳng", "💥 Laze", "🔵 Mặc định"];
    
    // Lấy số đạn để hiển thị trong thông báo
    let ammoInfo = '';
    if (clickShotMode !== 5) { // Nếu không phải loại Mặc định
        ammoInfo = ` (${player.ammo[clickShotMode]} )`;
    }

    showWarning(`Kiểu đạn: ${modeNames[clickShotMode]}`);
    
    // Cập nhật hiển thị cố định ở góc trái
    updateAmmoDisplay(); 
    
    e.preventDefault();
  }
});

// Sử dụng phím Space để bắn
document.addEventListener("keydown", e => {
  if (e.code === 'Space') {
  if (window.isPlayerInSafeZone) { e.preventDefault(); return; } // ⛳ chặn bắn trong Safe Zone
  shoot();
  }
});

// 📱 Điều khiển cảm ứng
canvas.addEventListener("touchstart", e => {
  const touch = e.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
});
canvas.addEventListener("touchmove", e => {
  const touch = e.touches[0];
  touchMoveX = touch.clientX;
  touchMoveY = touch.clientY;
  e.preventDefault(); // ngăn cuộn trang
});
canvas.addEventListener("touchend", () => {
  touchStartX = null;
  touchStartY = null;
  touchMoveX = null;
  touchMoveY = null;
});

// Hàm tiện ích để lấy một số nguyên ngẫu nhiên trong một khoảng
function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
// Hàm dọn dẹp các đối tượng không còn hoạt động
function cleanupInactiveObjects() {
  // Dọn dẹp zombies
  for (let i = zombies.length - 1; i >= 0; i--) {
    if (!zombies[i].active) {
      zombies.splice(i, 1);
    }
  }

  // Dọn dẹp đạn người chơi
  for (let i = bullets.length - 1; i >= 0; i--) {
    if (!bullets[i].active) {
      bullets.splice(i, 1);
    }
  }

  // Dọn dẹp đạn của địch
  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    if (!enemyBullets[i].active) {
      enemyBullets.splice(i, 1);
    }
  }

  // Dọn dẹp vật phẩm
  for (let i = items.length - 1; i >= 0; i--) {
    if (!items[i].active) {
      items.splice(i, 1);
    }
  }

  // Dọn dẹp hiệu ứng nổ
  for (let i = explosions.length - 1; i >= 0; i--) {
    if (!explosions[i].active) {
      explosions.splice(i, 1);
    }
  }
}
function updateAmmoDisplay() {
    const display = document.getElementById('ammoDisplay');
    const modeNames = ["🔄 Xoắn ốc", "↔️ Zigzag", "🎯 Xoắn bay thẳng", "🎯 Xuyên thẳng", "💥 Laze", "🔵 Mặc định"];
    
    // Nếu là chế độ mặc định (vô hạn) hoặc không có display thì ẩn đi
    if (clickShotMode === 5 || !display) {
        display.style.opacity = '0';
        return;
    }

    const currentAmmo = player.ammo[clickShotMode];
    const ammoText = currentAmmo > 0 ? currentAmmo.toString() : 'Hết đạn!';
    
    display.innerText = `${modeNames[clickShotMode]}: ${ammoText}`;
    display.style.opacity = '1'; // Hiện lên
}
/* ===== 🏹 ICE ARROW: state & helpers ===== */
let iceArrowRateShopSteps = 0;   // mỗi lần mua +1 step = +0.5x
let iceArrowDamageShop    = 0;   // dmg riêng mua thêm trong shop
const ICE_ARROW_RATE_STEP = 0.5; // mỗi lần mua +0.5x
const ICE_ARROW_RATE_MAX  = 3;   // max 3x
const ICE_ARROW_DMG_PER_LEVEL = 1; // mỗi cấp mũi tên +1 dmg riêng (có thể chỉnh)
window.manualShootCooldownBase ??= manualShootCooldown; // lưu cooldown gốc 1x

// Tốc độ bắn riêng của Ice Arrow (không phụ thuộc player nữa)
function getIceArrowRate() {
  // tốc độ chỉ tăng từ shop, base = 1.0
  return Math.min(ICE_ARROW_RATE_MAX, 1 + iceArrowRateShopSteps * ICE_ARROW_RATE_STEP);
}

// Cooldown riêng của phím Space (Ice Arrow)
function getIceArrowCooldown() {
  const r = getIceArrowRate();
  return Math.max(1, Math.round(manualShootCooldownBase / r));
}

// Sát thương cộng thêm riêng cho Ice Arrow (level + shop)
function getIceArrowBonusDamage() {
  // Lấy level mũi tên = iceArrow hiện tại (cấp 1 coi như bonus 0)
  const lvl = Math.max(0, (playerUpgrades.iceArrow || 1) - 1);
  const fromLevel = lvl * ICE_ARROW_DMG_PER_LEVEL;
  return fromLevel + iceArrowDamageShop;
}
// =================================================================
// --- BẮT ĐẦU: HỆ THỐNG LƯU GAME, TẢI GAME VÀ HỒI SINH ---
// =================================================================

const SAVE_KEY = 'zombieSurvivorSave';

/**
 * Lưu trạng thái hiện tại của game vào localStorage.
 */
function saveGame() {
    if (!gameStarted || player.isDying) return; // Không lưu khi chưa bắt đầu hoặc đang chết
    try {
        const gameState = {
            player: player,
            playerUpgrades: playerUpgrades,
            skillUpgrades: skillUpgrades,
            activeSkills: activeSkills,
            wave: wave,
            currentDay: currentDay,
            dayTime: dayTime,
            shopUpgrades: shopUpgrades,
            iceArrowRateShopSteps: iceArrowRateShopSteps,
            iceArrowDamageShop: iceArrowDamageShop,
            // Lưu trạng thái từ các module ngoài
            Equip: window.Equip,
            CharacterPanelState: window.CharacterPanelState,
        };
        localStorage.setItem(SAVE_KEY, JSON.stringify(gameState));
        console.log("Game Saved!");
    } catch (error) {
        console.error("Lỗi khi lưu game:", error);
    }
}

/**
 * Tải trạng thái game từ localStorage.
 * @returns {boolean} Trả về true nếu tải thành công, ngược lại là false.
 */
function loadGame() {
    try {
        const savedData = localStorage.getItem(SAVE_KEY);
        if (!savedData) return false;

        const gameState = JSON.parse(savedData);

        // Khôi phục các đối tượng chính
        Object.assign(player, gameState.player);
        Object.assign(playerUpgrades, gameState.playerUpgrades);
        Object.assign(skillUpgrades, gameState.skillUpgrades);
        Object.assign(shopUpgrades, gameState.shopUpgrades);

        // Khôi phục các biến
        activeSkills.length = 0; // Xóa mảng cũ trước khi push
        gameState.activeSkills.forEach(skill => activeSkills.push(skill));
        wave = gameState.wave;
        currentDay = gameState.currentDay;
        dayTime = gameState.dayTime;
        iceArrowRateShopSteps = gameState.iceArrowRateShopSteps || 0;
        iceArrowDamageShop = gameState.iceArrowDamageShop || 0;
        
// Khôi phục module (giữ reference gốc để mọi nơi vẫn thấy cùng một object)
if (window.Equip && gameState.Equip) {
  Object.assign(window.Equip, gameState.Equip);
} else {
  // merge saved Equip để giữ nguyên reference & binding
Object.assign(window.Equip, gameState.Equip || {});
window.recalcEquipStats?.();
window.CharacterPanel?.refresh?.();
}

Object.assign(window.CharacterPanelState.spent, (gameState.CharacterPanelState?.spent || {}));
window.CharacterPanelState.baseline = gameState.CharacterPanelState?.baseline ?? null;

        // Cập nhật lại toàn bộ UI để hiển thị đúng dữ liệu đã tải
        updateUI();
        updateStatsOverlay();
        updateSkillsList();
        if (window.CharacterPanel) {
            window.CharacterPanel.refresh();
        }
        recalcEquipStats(); // Tính lại chỉ số từ trang bị
        console.log("Game Loaded!");
        return true;
    } catch (error) {
        console.error("Lỗi khi tải game:", error);
        localStorage.removeItem(SAVE_KEY); // Xóa save bị lỗi
        return false;
    }
}

/**
 * Xử lý logic khi người chơi chọn hồi sinh.
 */
function revivePlayer() {
// 1. Trừ chi phí
// Trừ 50% EXP hiện có và thêm 100 điểm cố định
const totalExpLoss = Math.round(player.exp * 0.5) + 100;
player.exp = Math.max(0, player.exp - totalExpLoss);
// Trừ đi lượng EXP đã mất khỏi EXP của cấp hiện tại
player.currentLevelExp = Math.max(0, player.currentLevelExp - totalExpLoss);
// Trừ 10 xu và thêm 10% của số dư hiện có
    const fixedCoinLoss = 10;
    const percentCoinLoss = Math.round(player.coins * 0.1);
    const totalCoinLoss = fixedCoinLoss + percentCoinLoss;
    player.coins = player.coins - totalCoinLoss; // Không dùng Math.max để có thể trừ âm
// Trừ 10 mana và thêm 10% của số dư hiện có
player.mana -= 10;
const manaLoss = Math.round(player.mana * 0.1);
player.mana = Math.max(0, player.mana - manaLoss);
// Trừ 10 energy và thêm 10% của số dư hiện có
player.energy -= 10;
const energyLoss = Math.round(player.energy * 0.1);
player.energy = Math.max(0, player.energy - energyLoss);
    // 2. Ẩn panel và reset trạng thái
    document.getElementById('gameOverPanel').classList.remove('visible');
    gameOver = false;
    player.isDying = false;

    // 3. Hồi đầy máu và tài nguyên
    player.hearts = player.maxHearts;
    player.stamina = player.staminaMax;

    // 4. Dịch chuyển đến 1 trong 5 safe zone ngẫu nhiên
    const respawnZone = safeZones[Math.floor(Math.random() * safeZones.length)];
    player.x = respawnZone.x;
    player.y = respawnZone.y;
    camera.x = Math.max(0, Math.min(worldWidth - canvas.width, player.x - canvas.width / 2));
    camera.y = Math.max(0, Math.min(worldHeight - canvas.height, player.y - canvas.height / 2));
    // BỔ SUNG ĐOẠN NÀY: Kích hoạt tạm thời safe zone trong 15s
    respawnZone.tempActiveUntil = Date.now() + 15000;
    respawnZone.active = true; // Kích hoạt ngay lập tức cho frame hiện tại

    // 5. Dọn dẹp màn chơi để bắt đầu lại wave
    zombies.length = 0;
    bullets.length = 0;
    enemyBullets.length = 0;
    items.length = 0;
    explosions.length = 0;
    // ... thêm các mảng object khác nếu có ...

    // 6. Reset lại wave timer và bắt đầu lại wave
    lastWaveTime = Date.now();
    waveTimer = waveTime;
    
    playRandomNormalMusic(); // Bật lại nhạc nền
    saveGame(); // Lưu lại trạng thái ngay sau khi hồi sinh
    showWarning("Đã hồi sinh! Tiếp tục chiến đấu.");
}

/**
 * Bắt đầu game từ dữ liệu đã lưu.
 */
function continueGame() {
    if (loadGame()) {
        document.getElementById('startMenu').style.display = 'none';
        gameStarted = true;
        isPaused = false;
        lastWaveTime = Date.now(); // Bắt đầu đếm giờ cho wave
        playRandomNormalMusic();
    } else {
        showWarning("Không tìm thấy dữ liệu đã lưu hoặc dữ liệu bị lỗi.");
    }
}

// =================================================================
// --- KẾT THÚC: HỆ THỐNG LƯU GAME, TẢI GAME VÀ HỒI SINH ---
// =================================================================
//💥 3. Hàm hỗ trợ tiện ích
/**
 * THÊM MỚI: Hàm cập nhật logic hồi máu tự động cho player.
 * Hàm này được gọi mỗi frame từ vòng lặp chính (update).
 * @param {number} now - Thời gian hiện tại (timestamp) từ Date.now().
 */
/**
 * Cập nhật logic hồi máu tự động cho player, đã bao gồm bonus từ trang bị.
 * @param {number} now - Thời gian hiện tại (timestamp).
 */
function updatePlayerRegen(now) {
    // Chỉ thực hiện khi game đã bắt đầu và mốc thời gian đã được khởi tạo
    if (!gameStarted || !lastHpRegenTime) {
        lastHpRegenTime = now; // Khởi tạo mốc thời gian lần đầu
        return;
    }

    // Kiểm tra xem đã đủ thời gian chờ hay chưa
    if (now - lastHpRegenTime >= HP_REGEN) {
        // Tính tổng lượng máu sẽ hồi = Gốc + Trang bị
        // (player.equipHpRegen || 0) đảm bảo code không bị lỗi nếu chưa có trang bị
        let totalHealAmount = HP_REGEN_VALUE + (player.equipHpRegen || 0);

        // Làm tròn tổng lượng máu hồi về 2 chữ số thập phân
        totalHealAmount = parseFloat(totalHealAmount.toFixed(2));

        // Chỉ hồi máu nếu HP chưa đầy và có lượng máu để hồi
        if (player.hearts < player.maxHearts && totalHealAmount > 0) {
            // Hồi máu và đảm bảo không vượt quá giới hạn
            player.hearts = Math.min(player.maxHearts, Math.round(player.hearts + totalHealAmount));
            createHealImpactEffect(player, totalHealAmount); // Hiển thị hiệu ứng
        }
        // Đặt lại mốc thời gian cho lần hồi máu tiếp theo
        lastHpRegenTime = now;
    }
}
/**
 * Cập nhật logic hồi stamina tự động cho player, đã bao gồm bonus từ trang bị.
 * @param {number} now - Thời gian hiện tại (timestamp).
 */
function updatePlayerStaminaRegen(now) {
    if (!gameStarted || !lastStaminaRegenTime) {
        lastStaminaRegenTime = now; // Khởi tạo mốc thời gian
        return;
    }
    // Kiểm tra xem đã đủ thời gian chờ hay chưa
    if (now - lastStaminaRegenTime >= STAMINA_REGEN_INTERVAL) {
        // Tính tổng lượng stamina sẽ hồi = Gốc + Trang bị
        const totalStaminaAmount = STAMINA_REGEN_VALUE + (player.equipSpRegen || 0);
        // Chỉ hồi nếu stamina chưa đầy và có lượng stamina để hồi
        if (player.stamina < player.staminaMax && totalStaminaAmount > 0) {
            player.stamina = Math.min(player.staminaMax, player.stamina + totalStaminaAmount);
        }
        // Đặt lại mốc thời gian cho lần hồi tiếp theo
        lastStaminaRegenTime = now; 
    }
}
// Hàm tính khoảng cách giữa hai điểm
function distance(a, b) {
return Math.hypot(a.x - b.x, a.y - b.y);}

function distanceSq(a, b) {
    return (a.x - b.x)**2 + (a.y - b.y)**2;
}
function createFairyHitParticle(targetZombie) {
    particles.push({
        type: 'fairy_status_effect', // Loại hạt mới
        target: targetZombie,       // "Dính" vào mục tiêu này
        life: 180,                   // Tồn tại trong 1.5 giây (60fps * 1.5)
        maxLife: 180,
        angle: Math.random() * Math.PI * 2, // Góc xoay ban đầu
        orbitRadius: targetZombie.radius + 5 + Math.random() * 5, // Khoảng cách xoay
        size: 0.5 + Math.random() * 1,                 // Kích thước hạt
        color: 'rgba(100, 255, 150, 0.8)'   // Màu xanh lá cây bạc hà

    });
}
// Hàm này sẽ quyết định vật phẩm nào sẽ rơi dựa trên tỉ lệ
function determineItemDrop() {
    const itemRand = Math.random(); // Tạo số ngẫu nhiên từ 0 đến 1
    let cumulativeChance = 0;

    // Duyệt qua từng vật phẩm trong bảng tỉ lệ rơi - itemDropTable, thay testDropTable nếu test
    for (const item of itemDropTable) {
        cumulativeChance += item.chance;
        // Nếu số ngẫu nhiên nhỏ hơn tỉ lệ cộng dồn, chúng ta chọn vật phẩm này
        if (itemRand < cumulativeChance) {
            return item.type;
        }
    }
    // Nếu không trúng vật phẩm nào trong bảng, mặc định sẽ là 'energy'
    return 'energy';
}
// Tạo hiệu ứng cổng dịch chuyển
function createSpawnEffect(x, y) {
    playSound('sfx-nuke-fall', 0.5); // Tạm dùng âm thanh bom rơi để cảnh báo
    // Tạo 30 hạt bay ra từ tâm theo hình tròn
    for (let i = 0; i < 30; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 2;
        particles.push({
            x: x, y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 2 + 1,
            color: 'rgba(139, 0, 139, 0.8)', // Màu tím đậm
            alpha: 1,
            fastFade: true
        });
    }
}
/**
 * Tạo một vụ nổ bằng các hạt (particle) tại một vị trí.
 * @param {number} x Tọa độ X của vụ nổ.
 * @param {number} y Tọa độ Y của vụ nổ.
 * @param {number} count Số lượng hạt.
 * @param {string} baseColor Màu cơ bản của vụ nổ (ví dụ: 'orange', 'cyan').
 */
function createParticleExplosion(x, y, count, colorScheme = 'fire') {
    let colors;
    let maxDist = 60; // Bán kính mặc định

    // Chọn bộ màu và bán kính dựa trên yêu cầu
    if (colorScheme === 'fire') {
        colors = [
            'rgba(255, 255, 255, 0.9)', // Trắng
            'rgba(255, 220, 0, 0.8)',   // Vàng
            'rgba(255, 150, 0, 0.8)',   // Cam
            'rgba(255, 50, 0, 0.7)'     // Đỏ
        ];
        maxDist = 60; // Bán kính nổ của tên lửa
    } else if (colorScheme === 'smoke') {
        colors = [
            'rgba(200, 200, 200, 0.7)', // Xám sáng
            'rgba(150, 150, 150, 0.6)', // Xám vừa
            'rgba(100, 100, 100, 0.5)'  // Xám tối
        ];
        maxDist = 80; // Bán kính của bom khói
    }

    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 2;

        const color = colors[Math.floor(Math.random() * colors.length)];

        particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 1 + 2,
            color: color,
            alpha: 1,
            fastFade: true,
            originX: x,
            originY: y,
            maxDistance: maxDist
        });
    }
}

/**
 * Tạo một đối tượng hiệu ứng dying và thêm vào mảng healEffects.
 */
function spawnDyingEffect(z) {
    healEffects.push({
        x: z.x,
        y: z.y - z.radius,
        life: 60,
        maxLife: 60,
        text: '☠️',
        delay: 0  // No delay for death effect
    });
}
// Vẽ các hiệu ứng hồi máu
function updateAndDrawHealEffects() {
    ctx.font = "0.8rem sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    for (let i = healEffects.length - 1; i >= 0; i--) {
        const effect = healEffects[i];

        // Luôn giảm life mỗi frame để hiệu ứng biết khi nào cần biến mất
        effect.life--;

        // Nếu còn delay, chỉ đứng yên tại chỗ
        if (effect.delay > 0) {
            effect.delay--;
        } else {
            // Hết delay thì mới bắt đầu bay lên
            effect.y -= 0.5;
        }

        // Sử dụng màu từ hiệu ứng, nếu không có thì mặc định là màu trắng
        ctx.fillStyle = effect.color || "white";
        ctx.globalAlpha = effect.life / effect.maxLife;
        
        // Vẽ đúng icon (text) của hiệu ứng
        ctx.fillText(effect.text, effect.x, effect.y);

        // Xóa hiệu ứng khi life <= 0
        if (effect.life <= 0) {
            healEffects.splice(i, 1);
        }
    }
    
    ctx.globalAlpha = 1; // Reset độ mờ
}

// 🎁 Quản lý việc rơi vật phẩm khi một zombie bị tiêu diệt.
function dropItem(x, y, isBoss = false, isBigBoss = false, isMiniBoss = false, isElite = false) {
  
    let finalDropCount = 0;
    const isLuckyActive = Date.now() < luckyBuffEndTime;

    // 1. Xác định SỐ LƯỢNG vật phẩm sẽ rơi (logic gốc của bạn, giữ nguyên)
    if (isBigBoss) {
        // BigBoss rơi ngẫu nhiên từ 5 đến 10 vật phẩm
        finalDropCount = getRandomInt(5, 10);
    } else if (isBoss) {
        // Boss rơi ngẫu nhiên từ 3 đến 5 vật phẩm
        finalDropCount = getRandomInt(3, 5);
    } else if (isMiniBoss) {
        // MiniBoss rơi ngẫu nhiên từ 2 đến 3 vật phẩm
        finalDropCount = getRandomInt(2, 3);
    } else if (isElite) {
        // Elite rơi ngẫu nhiên từ 1 đến 2 vật phẩm
        finalDropCount = getRandomInt(1, 2);
    } else {
        let dropChance = 0.1; // Tỉ lệ rơi vật phẩm cơ bản 10%
        if (isLuckyActive) {
            dropChance = 0.2; // Tăng tỉ lệ rơi vật phẩm khi có buff Lucky
        }
        if (Math.random() < dropChance) {
            finalDropCount = 1;
        }
    }

    // Nếu có buff Lucky, nhân đôi số lượng vật phẩm rơi ra
    if (isLuckyActive) {
        finalDropCount *= 2;
    }
    // Nếu không có vật phẩm nào rơi ra, kết thúc hàm
    if (finalDropCount === 0) {
        return;
    }

    // 2. Vòng lặp để tạo ra từng vật phẩm
    for (let i = 0; i < finalDropCount; i++) {
        const offsetX = (Math.random() - 0.5) * 30;
        const offsetY = (Math.random() - 0.5) * 30;
        const safeX = Math.min(worldWidth - wallThickness - 20, Math.max(wallThickness + 20, x + offsetX));
        const safeY = Math.min(worldHeight - wallThickness - 20, Math.max(wallThickness + 20, y + offsetY));
        // 3. Gọi hàm mới để quyết định LOẠI vật phẩm sẽ rơi ra.
        const type = determineItemDrop();
        // 4. Thêm vật phẩm vào game
        if (type) {
            items.push({ 
                x: safeX, 
                y: safeY, 
                type: type, 
                active: true, 
                bornAt: Date.now() // Sử dụng 'bornAt' để tương thích logic tự xóa
            });
        }
    }
}

// 📦 Khi người chơi nhặt hộp vật phẩm đặc biệt
function openItemBox() {
  const rewardCount = Math.floor(Math.random() * 3) + 1; // Nhận 1–3 loại ngẫu nhiên
  const rewards = [
    { type: 'energy', label: '⚡ Energy', icon: '⚡' },
    { type: 'mana', label: '💠 Mana', icon: '💠' },
    { type: 'hp', label: '❤️ HP', icon: '❤️' }
  ];

  const shuffled = rewards.sort(() => Math.random() - 0.5);
  const selected = shuffled.slice(0, rewardCount);
  const summary = [];

  selected.forEach(r => {
    const amount = Math.floor(Math.random() * 5) + 3; // Nhận 3–7 mỗi loại
    switch (r.type) {
      case 'energy': player.energy += amount; break;
      case 'mana': player.mana += amount; break;
      case 'hp': player.hearts = Math.min(player.maxHearts, player.hearts + amount); break;
    }
    summary.push(`${r.icon} +${amount}`);
  });

  // 📢 Gộp thành một dòng thông báo duy nhất
  showWarning(`📦 Hộp vật phẩm: ${summary.join(', ')}`);
}
// Hàm xử lý khi nhặt vật phẩm Secret (phiên bản đã cập nhật tỉ lệ)
function activateSecretItem(item) {
  if (!item) return;

  const r = Math.random(); // 0..1

  // 1) 30% Buff (6 nhánh, mỗi nhánh 5%)
  if (r < 0.30) {
    if (r < 0.05) {
      luckyBuffEndTime = Date.now() + 45000;
      showWarning("❓: Nhận được buff LUCKY!");
    } else if (r < 0.10) {
      powerBuffEndTime = Date.now() + 45000;
      showWarning("❓: Nhận được buff POWER!");
    } else if (r < 0.15) {
      crazyBuffEndTime = Date.now() + 45000;
      showWarning("❓: Nhận được buff CRAZY!");
    } else if (r < 0.20) {
      expBuffEndTime = Date.now() + 45000;
      showWarning("❓: Nhận được buff EXP!");
    } else if (r < 0.25) {
      // 5%: Crit Rate
      if (typeof addCritRateBuff === 'function') {
        addCritRateBuff(0.15, 45000); // +15% trong 45s (tuỳ chỉnh nếu cần)
      }
      showWarning("❓: Crit Rate +15%");
    } else {
      // 5%: Crit Dmg
      if (typeof addCritDmgBuff === 'function') {
        addCritDmgBuff(0.25, 45000); // +25% trong 45s (tuỳ chỉnh nếu cần)
      }
      showWarning("❓: Crit Dmg +25%");
    }
  }

  // 2) 30%: Coin hoặc EXP (50/50)
  else if (r < 0.60) {
    if (Math.random() < 0.5) {
      const coinBonus = Math.round((wave + player.level) * (Math.random() * 3 + 2)); // 2–5 lần (wave + level)
      player.coins += coinBonus;
      showWarning(`❓: Nhận được ${coinBonus} 🪙!`);
    } else {
      activateExpBonusItem();
    }
  }

  // 3) 30%: Elite Pack (10%) / Mini Boss (10%) / Boss (10%)
  else if (r < 0.90) {
    showWarning("Oh! No");
    createSpawnEffect(item.x, item.y);
    setTimeout(() => {
      if (r < 0.70) {           // 0.60–0.70 → 10% Elite Pack
        const cnt = 2 + ((Math.random() * 3) | 0); // 2–4 con
        showWarning(`❗: ${cnt} Zombie tinh anh!`);
        spawnElitePackAt(item.x, item.y, cnt);
      } else if (r < 0.80) {    // 0.70–0.80 → 10% Mini Boss
        showWarning("❗: Mini Boss!");
        spawnMiniBossAt(item.x, item.y);
      } else {                  // 0.80–0.90 → 10% Boss
        showWarning("❗: Boss!");
        spawnBoss(item.x, item.y);
      }
    }, 500);
  }

  // 4) 10%: mở Box
  else {
    showWarning("Nhận được Hộp vật phẩm!");
    openItemBox(); 
  }
}

// Hàm xử lý khi nhặt vật phẩm ExpBonus
function activateExpBonusItem() {
    // Lượng EXP thưởng = (wave + level) * (một số ngẫu nhiên từ 5 đến 10)
    const bonus = Math.round((wave + player.level) * (Math.random() * 5 + 5));
    player.exp += bonus;
    player.currentLevelExp += bonus;
    createExpGainEffect({x: player.x, y: player.y, radius: 20}, bonus);
    showWarning(`🌟 Thưởng: +${bonus} EXP!`);
}
// 🔁 Bullet Pooling
function getBullet() {
  return bulletPool.length ? bulletPool.pop() : { x: 0, y: 0, dx: 0, dy: 0, active: true };
}
function releaseBullet(bullet) {
    bullet.active = false;
    
    // ✨ BẮT ĐẦU PHẦN RESET TOÀN BỘ THUỘC TÍNH ĐẶC BIỆT ✨
    delete bullet.isFairyBullet; // Xóa cờ của đạn Fairy
    delete bullet.isPetBullet; 
    delete bullet.icon;        
    delete bullet.stunDuration;
    delete bullet.customDmg;     // Xóa sát thương riêng của Clone
    delete bullet.color;         // Xóa màu tùy chỉnh
    delete bullet.effect;        // Xóa hiệu ứng của đạn Fairy
    delete bullet.isIceArrow;
    delete bullet.iceHits;  
    bullet.piercing = false;     // Reset thuộc tính xuyên thấu về mặc định
    
    // Reset các kiểu bay đặc biệt
    bullet.curveMode = false;
    bullet.zigzagMode = false;
    bullet.spiralForwardMode = false;
    // ✨ KẾT THÚC PHẦN RESET ✨

    bulletPool.push(bullet);
}

// 💥 Explosion Pooling
function getExplosion(x, y) {
  const e = explosionPool.length ? explosionPool.pop() : { x: 0, y: 0, radius: 0, life: 0, active: true };
  e.x = x;
  e.y = y;
  e.radius = 0;
  e.life = 20;
  e.active = true;
  return e;
}
function releaseExplosion(e) {
  e.active = false;
  explosionPool.push(e);
}

// 💥 Bắn đạn từ zombie về phía player - shootEnemyBullet pooling
function shootEnemyBullet(z, speed = 0.6, chance = 1) { // Nhận cả đối tượng zombie 'z'
    if (Math.random() > chance) return;

    const angle = Math.atan2(player.y - z.y, player.x - z.x);
    const b = getEnemyBullet();
    b.x = z.x;
    b.y = z.y;
    b.dx = Math.cos(angle);
    b.dy = Math.sin(angle);
    b.speed = speed;
    b.damage = calculateZombieDamage(z); // ✨ Tính và lưu sát thương vào đạn
    b.hit = false;
    b.active = true;

    enemyBullets.push(b);
}

// object pooling cho enemyBullets
const enemyBulletPool = [];

function getEnemyBullet() {
  return enemyBulletPool.length
    ? enemyBulletPool.pop()
    : { x: 0, y: 0, dx: 0, dy: 0, speed: 1, hit: false, active: true };
}

function releaseEnemyBullet(b) {
  b.hit = false;
  b.active = false;
  enemyBulletPool.push(b);
}

// 🧟 Zombie Pooling
function getZombie() {
    let z = zombiePool.length ? zombiePool.pop() : {
        x: 0, y: 0, radius: 15, canHit: true, speed: 1,
        color: "hotpink", isBoss: false, isBigBoss: false,
        hp: 1, active: true, type: "normal", level: 1
    };

    // Reset lại toàn bộ khi lấy từ pool
    z.active = true;
    z._killed = false;
    z.isBoss = false;
    z.isBigBoss = false;
    z.type = "normal";
    z.color = "hotpink";
    z.radius = 15;
    z.hp = 1;
    z.level = 1;
    z.baseSpeed = 0.1 + Math.random() * 0.1;
    z.speed = z.baseSpeed;
    z.canHit = true;
    return z;
}

function releaseZombie(z) {
  z.active = false;
  z.state = undefined;   
  zombiePool.push(z);
}
// 💥 Hàm tiêu diệt zombie, dùng chung cho mọi kỹ năng
function killZombie(z) {
  // --- BƯỚC 1: XỬ LÝ BAN ĐẦU ---

  // Nếu zombie đã bị xử lý rồi hoặc không hoạt động, bỏ qua để tránh lỗi
  if (z._killed || !z.active) return;
  z._killed = true; // Đánh dấu là đã xử lý để không gọi lại hàm này trên cùng 1 zombie

  // Phát âm thanh và hiệu ứng hình ảnh
  playSound('sfx-zombie-die', 0.3);
  spawnDyingEffect(z);

  // Trả đối tượng zombie về "kho" (object pool) để tái sử dụng, tối ưu hiệu năng
  releaseZombie(z);
  
  // --- BƯỚC 2: CẬP NHẬT ĐIỂM SỐ ---

  // Luôn cộng 1 vào 'score' để đếm kill và tính high score
  player.score++;
  zombieKillCount = player.score;

  // --- BƯỚC 3: TÍNH TOÁN EXP (LOGIC HOÀN CHỈNH) ---

  let expBaseCalculated = 0; // Biến tạm để lưu EXP gốc trước khi thêm yếu tố ngẫu nhiên

  // 3.1. Tính EXP gốc cho từng loại zombie
  if (z.isBigBoss) {
    // Đối với các loại boss, gọi hàm tính EXP tăng tiến riêng
    expBaseCalculated = calculateScaledBossExp(1000, wave);
  } else if (z.isBoss) {
    expBaseCalculated = calculateScaledBossExp(100, wave);
  } else if (z.type === "miniBoss") {
    // Sử dụng EXP cơ bản là 50 đã sửa
    expBaseCalculated = calculateScaledBossExp(10, wave);
  } else {
    // Logic cho zombie thường và Elite
    const base = z.isElite ? 5 : 1;
    const levelBonus = z.level - 1;
    const waveBonus = wave - 1; // Thưởng theo wave chỉ áp dụng cho zombie thường/elite
    expBaseCalculated = base + levelBonus + waveBonus;
  }

  // 3.2. Thêm yếu tố ngẫu nhiên +/- 10%
  // Công thức: giá trị * (1 + (số ngẫu nhiên từ -0.1 đến +0.1))
  const randomFactor = 1 + (Math.random() * 0.2 - 0.1); 
  let expGained = expBaseCalculated * randomFactor;

  // 3.3. Làm tròn kết quả và đảm bảo EXP nhận được luôn ít nhất là 1
  expGained = Math.max(1, Math.round(expGained));

  // 3.4. Áp dụng các buff khác nếu có (ví dụ: buff x1.5 EXP)
  if (Date.now() < expBuffEndTime) { // nếu đang có buff EXP
    expGained = Math.round(expGained * 1.5);// tăng 50%
  }
  
  // 3.5. Cộng EXP vào cho người chơi
  player.exp += expGained;
  player.currentLevelExp += expGained;
  createExpGainEffect(z, expGained);

  // --- BƯỚC 4: CẬP NHẬT THỐNG KÊ VÀ RƠI VẬT PHẨM ---

  // Cập nhật thống kê số lượng zombie đã diệt theo từng loại
  if (z.level && z.level >= 1 && z.level <= 10) {
    zombieByLevel[z.level] = (zombieByLevel[z.level] || 0) + 1;
  }
  if (z.type === "miniBoss") {
    zombieByLevel.miniBoss = (zombieByLevel.miniBoss || 0) + 1;
  }
  if (z.isBoss && !z.isBigBoss) {
    zombieByLevel.boss = (zombieByLevel.boss || 0) + 1;
  }
  if (z.isBigBoss) {
    zombieByLevel.bigBoss = (zombieByLevel.bigBoss || 0) + 1;
  }
  
  // Gọi hàm để xử lý việc rơi vật phẩm
  dropItem(z.x, z.y, z.isBoss, z.isBigBoss, z.type === "miniBoss", z.isElite);
}
/**
 * Tính toán lượng EXP yêu cầu để đạt được cấp độ tiếp theo.
 * @param {number} level - Cấp độ hiện tại của người chơi.
 * @returns {number} Số EXP cần thiết để lên cấp.
 */
function calculateRequiredExp(level) {
    // --- BẠN CÓ THỂ TÙY CHỈNH CÁC THAM SỐ NÀY ---
    // Hệ số gia tăng. Con số này càng lớn, các cấp độ sau càng khó.
    // 1.5 là một khởi đầu tốt, bạn có thể thử 1.6, 1.7... để làm game khó hơn.
    const exponent = 1.5;
    // Công thức tính: BaseEXP * (Level ^ Exponent)
    // Math.floor dùng để làm tròn xuống, cho ra một con số đẹp.
    return Math.floor(INITIAL_REQUIRED_EXP * Math.pow(level, exponent));
}
function calculateScaledBossExp(baseExp, currentWave) {
  // --- BẠN CÓ THỂ TÙY CHỈNH HỆ SỐ CÂN BẰNG TẠI ĐÂY ---

  // Mỗi wave sẽ cộng thêm bao nhiêu EXP cho boss.
  // Ví dụ: 10 nghĩa là ở wave 10, boss sẽ được cộng thêm 90 EXP.
  const SCALING_FACTOR_PER_WAVE = 10;

  // ---------------------------------------------------

  // Lượng EXP thưởng được tính từ wave thứ 2 trở đi.
  // (currentWave - 1) để đảm bảo wave 1 không có thưởng.
  const waveBonus = Math.max(0, (currentWave - 1) * SCALING_FACTOR_PER_WAVE);

  // Trả về tổng EXP cơ bản cộng với phần thưởng, làm tròn cho số đẹp.
  return Math.round(baseExp + waveBonus);
}

/**
 * Tính toán sát thương của zombie dựa trên loại, wave và level người chơi.
 * @param {object} z - Đối tượng zombie.
 * @returns {number} Sát thương cuối cùng (tối thiểu là 1).
 */
function calculateZombieDamage(z) {
  // --- 1) Base gốc theo loại ---
  let baseDamage = 1;
  if (z.isBigBoss) baseDamage = 5;
  else if (z.isBoss) baseDamage = 3;
  else if (z.type === 'miniBoss' || z.type === 'mini_boss') baseDamage = 2;

  const damageFromWave = Math.max(0, (window.wave|0) - 1);
  const damageFromPlayerLevel = Math.max(0, (window.player?.level|0) - 1);

  // Tổng cơ bản
  let totalDamage = baseDamage + damageFromWave + damageFromPlayerLevel;

  // --- 2) Nhân hệ số theo loại để boss/bigboss vượt trội ---
  const isMini  = (z.type === 'miniBoss' || z.type === 'mini_boss' || z.isMini);
  const isElite = !!(z.isElite || z.elite || z.rank === 'elite' || z.tier === 'elite');
  const typeMult =
      z.isBigBoss ? 2.0 :
      z.isBoss    ? 1.6 :
      isMini      ? 1.3 :
      isElite     ? 1.15 :
                    1.0;

  totalDamage *= typeMult;

  // --- 3) Cộng thêm phần ngẫu nhiên theo loại (roll 1 lần / zombie) ---
  // Dải ngẫu nhiên:
  // - Thường: 0..2
  // - Elite & Mini-boss: 1..10
  // - Boss: 5..20
  // - BigBoss: 10..50
  if (z._atkRnd == null) {
    const rnd = Math.random;
    if (z.isBigBoss) {
      z._atkRnd = (10 + Math.floor(rnd() * 41)); // 10..50
    } else if (z.isBoss) {
      z._atkRnd = (5 + Math.floor(rnd() * 16));  // 5..20
    } else if (isMini || isElite) {
      z._atkRnd = (1 + Math.floor(rnd() * 10));  // 1..10
    } else {
      z._atkRnd = Math.floor(rnd() * 3);   // 0..2 Math.floor(rnd()*3) cho ra {0,1,2}.
    }
  }
  totalDamage += z._atkRnd;

  // --- 4) Suy yếu (giảm 50%) áp dụng sau cùng ---
  if (z.isWeakened && Date.now() < z.weakenEndTime) {
    totalDamage *= 0.5;
  } else if (z.isWeakened && Date.now() >= z.weakenEndTime) {
    z.isWeakened = false;
  }

  return Math.max(1, Math.floor(totalDamage));
}
// Hàm xử lý sát thương vào zombie, tự động kiểm tra chết và hiệu ứng
function dealDamageToZombie(z, dmg = 1) {
  if (window.isPlayerInSafeZone) return; // vô hiệu toàn bộ sát thương từ phía player/skill
    let finalDamage = Math.max(1, Math.round(dmg));
    // --- LOGIC CHO CRAZYMADNESSTIME ---
    if (Date.now() < crazyMadnessTimeEndTime) {
        // Tăng sát thương x2 (vẫn giữ nguyên)
        finalDamage *= 2;

        // 1. Tỉ lệ Crit 30%
        const isCrit = Math.random() < 0.3;

        // Nếu crit thành công...
        if (isCrit) {
            // Tăng 2.5 lần sát thương
            finalDamage *= 2.5;
            finalDamage = Math.round(finalDamage);

            // 2. Hiển thị chữ "Crit!" bay lên từ zombie
            healEffects.push({
                x: z.x + 28 + (Math.random() - 0.5) * 5, // Vị trí ngang ngẫu nhiên để tránh chồng lấn
                y: z.y - z.radius - 15, // Hiện ở vị trí cao hơn số sát thương một chút
                life: 90,   // Tồn tại 1.5 giây
                maxLife: 90,
                text: `Crit!`,
                delay: 0,
                color: 'orange' // Màu cam cho nổi bật
            });

        // 3. Hồi máu CHỈ KHI crit thành công
        const lifestealAmount = Math.ceil(finalDamage * 0.2); // Hồi 20% sát thương
        if (lifestealAmount > 0) {
            // 1. Hồi máu và áp dụng giới hạn maxHearts (CHỈ MỘT LẦN)
            player.hearts = Math.min(player.maxHearts, player.hearts + lifestealAmount);
            createHealImpactEffect(player, lifestealAmount);
        }
      }
    }
    
// Gây sát thương sau khi trừ giáp (armor) — cho phép 0 dmg
const __armor = Math.max(0, Number(z.armor || 0));
let __afterArmor = Math.round(finalDamage) - __armor;
// Chuẩn hoá -0 thành 0 để hiển thị đẹp
if (Object.is(__afterArmor, -0)) __afterArmor = 0;
if (__afterArmor < 0) __afterArmor = 0;

z.hp -= __afterArmor;
createDamageImpactEffect(z, __afterArmor);
    // Kiểm tra và tiêu diệt zombie nếu hết máu
    if (!z._killed && z.hp <= 0) {
        killZombie(z);
    }
}

// 🔪 Sword Pooling
function getSword() {
  return swordPool.length ? swordPool.pop() : {
    angle: 0,
    radius: 60,
    state: 'charging',
    chargeFrame: 90,
    x: 0,
    y: 0,
    target: null,
    fireDelay: 0,
    delay: 60
  };
}

function releaseSword(s) {
  swordPool.push(s);
}

// 🔥 Fireball Pooling
function getFireball() {
  return fireballPool.length ? fireballPool.pop() : {
    angle: 0,
    radius: 40,
    x: 0,
    y: 0
  };
}

function releaseFireball(f) {
  fireballPool.push(f);
}

// ❄️ Iceball Pooling
function getIceball() {
  return iceballPool.length ? iceballPool.pop() : {
    angle: 0,
    radius: 60,
    x: 0,
    y: 0
  };
}

function releaseIceball(i) {
  iceballPool.push(i);
}
// 🧊 Hiển thị cảnh báo tạm thời
function showWarning(message, customStyle = {}) {
  // Tạo khay nếu chưa có
  const container = document.getElementById('notificationContainer')
        || (() => {
             const c = document.createElement('div');
             c.id = 'notificationContainer';
             document.body.appendChild(c);
             return c;
           })();

  //  Tạo popup
  const popup = document.createElement('div');
  popup.className  = 'warningPopup';
  popup.textContent = message;
  Object.assign(popup.style, customStyle);   // nếu cần đổi màu, v.v.

  container.appendChild(popup);

  /* Giới hạn tối đa N popup đồng thời */
  const MAX = 2;
  while (container.childElementCount > MAX) {
    container.firstElementChild.remove();
  }

  /* Tự xoá sau 2 s */
  setTimeout(() => popup.remove(), 2000); // Thời gian hiển thị popup
}
/* ── Buffer gộp popup vật phẩm cho PET ─────────────────────── */
const petLootBuffer  = {};
let   petLootTimer   = null;
/* --- Buffer gộp popup cho Người chơi --- */
const playerLootBuffer = {};
let playerLootTimer = null;

function queuePlayerLootPopup(icon, delay = 500) {
    playerLootBuffer[icon] = (playerLootBuffer[icon] || 0) + 1;

    clearTimeout(playerLootTimer);
    playerLootTimer = setTimeout(() => {
        const summary = Object.entries(playerLootBuffer)
            .map(([ico, c]) => `${ico} x${c}`)
            .join(', ');
        showWarning(`Nhặt được: ${summary}`);
        // Xóa buffer sau khi hiển thị
        Object.keys(playerLootBuffer).forEach(k => delete playerLootBuffer[k]);
    }, delay);
}
function queuePetLootPopup(icon, delay = 500) { // <-- Đổi tên hàm
  petLootBuffer[icon] = (petLootBuffer[icon] || 0) + 1; // <-- Đổi tên buffer

  clearTimeout(petLootTimer); // <-- Đổi tên timer
  petLootTimer = setTimeout(() => { // <-- Đổi tên timer
    const summary = Object.entries(petLootBuffer) // <-- Đổi tên buffer
                  .map(([ico,c]) => `${ico} x${c}`)
                  .join(', ');
    showWarning(`🐰 Pet nhặt: ${summary}`);
    Object.keys(petLootBuffer).forEach(k => delete petLootBuffer[k]); // <-- Đổi tên buffer
  }, delay);
}
// Hàm bắn laze cho người chơi
function firePlayerLaser() {
    const now = Date.now();
    if (now - lastManualShootTime < manualShootCooldown) return;
    lastManualShootTime = now;

    if (zombies.length === 0) return;

    // Tìm mục tiêu và góc bắn (logic này giữ nguyên)
    const target = zombies.reduce((a, b) =>
        distance(a, player) < distance(b, player) ? a : b
    );
    const angle = Math.atan2(target.y - player.y, target.x - player.x);

    // Tạo ra 2 đối tượng lazer, một cho mỗi mắt
    playerLasers.push({ angle: angle, life: 20, eye: 'left' });
    playerLasers.push({ angle: angle, life: 20, eye: 'right' });

    // Phần xử lý sát thương giữ nguyên
    const laserPathTargets = [];
    const dx = Math.cos(angle);
    const dy = Math.sin(angle);

    zombies.forEach(z => {
        if (z.active) {
            const proj = (z.x - player.x) * dx + (z.y - player.y) * dy;
            const perp = Math.abs((z.x - player.x) * dy - (z.y - player.y) * dx);
            if (proj > 0 && proj < 2000 && perp < 10) { 
                laserPathTargets.push(z);
            }
        }
    });

    if (laserPathTargets.length > 0) {
        laserPathTargets.sort((a, b) => distance(player, a) - distance(player, b));
        const firstTarget = laserPathTargets[0];

        laserPathTargets.forEach(z => {
            let finalDamage = (z === firstTarget) 
                ? playerUpgrades.damageBoost 
                : Math.max(1, Math.round(playerUpgrades.damageBoost * 0.5));
            dealDamageToZombie(z, finalDamage);
        });
    }
}
// Tốc độ Ice Arrow (dựa trên cấp độ nâng cấp)
function getIceArrowSpeed() {
  const base = 1;                     // lv0 = 1.0
  const lvl  = Math.min(4, (shopUpgrades.iceArrowSpeedLevel || 0)); // +0.5 mỗi lần, 4 lần là 3.0
  return Math.min(3, base + lvl * 0.5);
}

//🔫 4. Bắn đạn & auto shoot
function shoot() {
  if (window.isPlayerInSafeZone) return; // ⛳ trong Safe Zone: không bắn
  // Kiểm tra và tiêu thụ stamina
  if (player.stamina < 1) {
    showWarning("Không đủ 🔹 Stamina!");
    return;
  }
  player.stamina--; // Trừ 1 stamina khi sử dụng
  const now = Date.now();
  // dùng cooldown riêng cho Ice Arrow
  if (now - lastManualShootTime < getIceArrowCooldown()) return;
  lastManualShootTime = now;

  const directionCount = playerUpgrades.iceArrow;       // số mũi tên theo cấp như cũ
  const speed = getIceArrowSpeed();               // tốc độ mũi tên theo cấp
  const basePlayerDmg  = (playerUpgrades.damageBoost || 1);
  const iceBonus       = getIceArrowBonusDamage();
  const finalDmg       = basePlayerDmg + iceBonus;

  if (zombies.length === 0) return;

  // 🔁 MỐC 21: giữ nguyên hành vi “bắn 21 hướng phủ toàn bản đồ”
  if (directionCount >= 21) {
    const angleOffset = Math.random() * Math.PI * 2; // giữ ngẫu nhiên offset như bản gốc
    for (let i = 0; i < directionCount; i++) {
      const angle = angleOffset + (2 * Math.PI / directionCount) * i;
      const b = getBullet();
      b.x = player.x; b.y = player.y;
      b.dx = Math.cos(angle); b.dy = Math.sin(angle);
      b.speed = speed; b.active = true;

      // 🏹 biến thành mũi tên băng + xuyên + dmg riêng
      b.isIceArrow = true;
      b.piercing   = true;
      b.customDmg  = finalDmg;

      bullets.push(b);
    }
    return;
  }

  // 🎯 < 21: auto-aim — chọn K zombie gần nhất và bắn thẳng vào chúng
  const targets = kNearestZombiesByPlayer(directionCount, 0);
  if (!targets.length) return;

  for (let i = 0; i < directionCount; i++) {
    const t = targets[i % targets.length];
    const angle = Math.atan2(t.y - player.y, t.x - player.x);

    const b = getBullet();
    b.x = player.x; b.y = player.y;
    b.dx = Math.cos(angle); b.dy = Math.sin(angle);
    b.speed = speed; b.active = true;

    // 🏹 Ice Arrow flags
    b.isIceArrow = true;
    b.piercing   = true;
    b.customDmg  = finalDmg;

    bullets.push(b);
  }
}

function autoShootBurst() {
  const now = Date.now(); // Lấy mốc thời gian hiện tại để tính toán chính xác

  // --- 1. QUẢN LÝ THỜI GIAN HỒI GIỮA CÁC LOẠT BẮN ---

  // Lấy thời gian hồi chiêu gốc từ biến autoShootCooldown
  let currentCooldown = autoShootCooldown;

  // Áp dụng các buff giúp bắn nhanh hơn nếu có
  if (supportAuraActive) {
    currentCooldown *= 0.8; // Kỹ năng Hào quang: giảm 20% thời gian hồi chiêu
  }
  if (Date.now() < crazyMadnessTimeEndTime) {
    currentCooldown /= 2; // Buff CrazyMadnessTime: tốc độ bắn x2
  }

  // Kiểm tra xem đã đủ thời gian để bắt đầu một loạt bắn MỚI chưa
  if (now - lastAutoShootTime >= currentCooldown) {
    lastAutoShootTime = now; // Đặt lại mốc thời gian cho loạt bắn tiếp theo
    autoBurstIndex = 0;      // Reset bộ đếm số đạn đã bắn trong loạt về 0
  }

  // --- 2. QUẢN LÝ VIỆC BẮN TỪNG VIÊN TRONG MỘT LOẠT ---

  // Lấy số lượng đạn cần bắn trong một loạt từ chỉ số nâng cấp của người chơi
  const bulletsPerDirection = playerUpgrades.lineBulletCount;

  // Nếu đã bắn đủ số đạn trong loạt này rồi thì dừng lại
  if (autoBurstIndex >= bulletsPerDirection) return;

  // Nếu chưa đủ độ trễ giữa các viên đạn (ví dụ 100ms), thì dừng lại.
  if (now - autoLastBurstTime < autoBurstDelay) return;

  // --- 3. TÌM MỤC TIÊU VÀ TÍNH TOÁN GÓC BẮN ---
  const PLAYER_AUTOSHOOT_RANGE = 360; // Tầm bắn tối đa cho tự động bắn
  let nearestTarget = null;
  // So sánh bình phương khoảng cách để tránh dùng Math.sqrt() tốn kém
  let minDistanceSq = PLAYER_AUTOSHOOT_RANGE * PLAYER_AUTOSHOOT_RANGE; 

  // Dùng vòng lặp for đơn giản để duyệt qua tất cả zombie
  for (const z of zombies) {
    // Bỏ qua những zombie không hoạt động
    if (!z.active) continue;

    // Tính bình phương khoảng cách
    const dSq = distanceSq(player, z);

    // Nếu zombie này gần hơn mục tiêu gần nhất hiện tại VÀ nằm trong tầm bắn
    if (dSq < minDistanceSq) {
      minDistanceSq = dSq;    // Cập nhật khoảng cách gần nhất
      nearestTarget = z;      // Gán mục tiêu mới
    }
  }

  // Nếu sau vòng lặp không tìm thấy mục tiêu nào, thoát ra
  if (nearestTarget === null) return;

  // Gán target bằng mục tiêu đã tìm thấy
  const target = nearestTarget; 

  // Tính toán góc bắn (radian) từ người chơi đến mục tiêu
  const angle = Math.atan2(target.y - player.y, target.x - player.x);

  // --- 4. TẠO VÀ BẮN ĐẠN ---  
  const b = getBullet(); // Lấy một viên đạn từ kho (object pooling)
  // Thiết lập các thuộc tính cho viên đạn
  b.x = player.x;
  b.y = player.y;
  b.dx = Math.cos(angle); // Hướng di chuyển theo trục X
  b.dy = Math.sin(angle); // Hướng di chuyển theo trục Y
  b.speed = playerUpgrades.bulletSpeed;
  b.active = true;
  bullets.push(b); // Thêm viên đạn vào danh sách đạn đang bay

  playSound('sfx-shoot', 0.01); // Phát âm thanh bắn với âm lượng nhỏ

  // Tăng bộ đếm số đạn đã bắn trong loạt và cập nhật thời gian
  autoBurstIndex++;
  autoLastBurstTime = now;
}

//🔪 5. Kích hoạt kỹ năng (Kích hoạt kỹ năng & gán nút)
function activateSwordSkill() {
  if (swordActive) return;

  if (player.level < 1) return showWarning("🔪 Yêu cầu Lv1");
  if (player.energy < 3) return showWarning("🔪 Không đủ 3⚡");

  swordActive = true;
  swordEndTime = Date.now() + 60000;
  player.energy -= 3;
  document.getElementById("bladeBtn").classList.add("active");
  showWarning("🔪 Kích hoạt kỹ năng Đao xoay");
  // ✨ KHỞI TẠO BỘ ĐIỀU KHIỂN TẤN CÔNG
  lastBladeLaunchTime = Date.now();
  nextBladeToAttack = 0;

  swords = [];
  const count = skillUpgrades.bladeCount;
  for (let i = 0; i < count; i++) {
    const homeAngle = (2 * Math.PI / count) * i;
    swords.push({
      state: 'orbiting',
      angle: homeAngle,
      homeAngle: homeAngle,
      orbitRadius: 60,
      hitZombies: new Set(),
      pierceCount: 0,
      bladeIndex: i
    });
  }
}
// ⚔️ Kỹ năng mưa kiếm
function activateDownwardSwords() {
  if (bladeActive) return;

  if (player.level < 2) return showWarning("⚔️ Yêu cầu Lv2");
  if (player.energy < 6) return showWarning("⚔️ Không đủ 6⚡");

  bladeActive = true;
  bladeEndTime = Date.now() + 60000;
  player.energy -= 6;
  document.getElementById("swordBtn").classList.add("active");
  showWarning("⚔️ Kích hoạt kỹ năng Mưa kiếm");
  swordRainClouds = [];
  // Số lượng mây sẽ bằng cấp độ kỹ năng
  const cloudCount = skillUpgrades.swordLevel;
  
  for (let i = 0; i < cloudCount; i++) {
      // Dàn đều các đám mây theo chiều ngang màn hình
      const xPosition = (canvas.width / (cloudCount + 1)) * (i + 1);

      swordRainClouds.push({
          relativeX: xPosition,
          relativeY: 100 + (Math.random() - 0.5) * 20,
          driftSpeed: (Math.random() - 0.5) * 0.2,
          nextDropTime: Date.now() + Math.random() * 1000
      });
  }
}
// Kích hoạt kỹ năng PET – Thỏ màu hồng
function activatePet() {
  petActive       = true;                      // nay chắc chắn chưa hoạt động
  petEndTime      = Date.now() + 60000;        // 60 s
  petLastHealTime = Date.now();

  petRabbit = {                                // speed tính động mỗi frame
    x      : player.x + 40,
    y      : player.y,
    radius : 14,
    attackTimer: 0
  };

  const btn        = document.getElementById("PetBtn");
  btn.innerText    = lastPetText;
  btn.classList.add("active");

  showWarning("🐰 Pet thỏ đã ra trận!");
}
// 🖱 Gán sự kiện nút
// 🔪 Kỹ năng Đao
document.getElementById("bladeBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 1) return showWarning("🔪 Yêu cầu Lv1");
  if (player.energy < 5) return showWarning("🔪 Không đủ 3⚡");
  activateSwordSkill();
};
// ⚔️ Kỹ năng Kiếm
document.getElementById("swordBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 2) return showWarning("⚔️ Yêu cầu Lv2");
  if (player.energy < 6) return showWarning("⚔️ Không đủ 6⚡");
  activateDownwardSwords();
};
// 🔥 Kỹ năng Lửa
document.getElementById("fireBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 3) return showWarning("🔥 Yêu cầu Lv3");
  if (player.energy < 8) return showWarning("🔥 Không đủ 8⚡");
  if (!fireActive) {
    fireActive = true;
    fireballs.length = 0;
    const fireCount = skillUpgrades.fireCount;
    for (let i = 0; i < fireCount; i++) {
      const angle = (2 * Math.PI / fireCount) * i;
      const f = getFireball();
      f.angle = angle;
      f.radius = 40;
      f.x = player.x + Math.cos(angle) * 40;
      f.y = player.y + Math.sin(angle) * 40;
      fireballs.push(f);
    }
    fireEndTime = Date.now() + 60000;
    player.energy -= 8;
    document.getElementById("fireBtn").classList.add("active");
    showWarning("🔥 Kích hoạt kỹ năng Lửa");

  }
};
// ❄️ Kỹ năng Băng
document.getElementById("iceBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 3)   return showWarning("❄️ Yêu cầu Lv3");
  if (player.energy < 12) return showWarning("❄️ Không đủ 12⚡");
  if (!iceActive) {
    iceActive  = true;
    iceballs.length = 0;
    const iceCount = skillUpgrades.iceCount;
    for (let i = 0; i < iceCount; i++) {
      const angle = (2 * Math.PI / iceCount) * i;
      const b     = getIceball();
      b.angle  = angle;
      b.radius = 50;
      b.x = player.x + Math.cos(angle) * 60;
      b.y = player.y + Math.sin(angle) * 60;
      iceballs.push(b);
    }
    iceEndTime      = Date.now() + 60000;   // 60 s hiệu lực
    player.energy  -= 12;                   // trừ năng lượng đúng 1 lần
    document.getElementById("iceBtn").classList.add("active");
    showWarning("❄️ Kích hoạt kỹ năng Băng");
  }
};
// === Kỹ năng LÔI ===
document.getElementById("thunderBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 5) return showWarning("🔵 Yêu cầu Lv5");
  if (player.energy < 18) return showWarning("🔵 Không đủ 18⚡");
  if (!thunderActive) {
    thunderActive = true;
    thunderBalls.length = 0;
    const thunderCount = skillUpgrades.thunderCount;
    for (let i = 0; i < thunderCount; i++) {
      const angle = (2 * Math.PI / thunderCount) * i;
      thunderBalls.push({
        angle,
        radius: 50,
        x: player.x + Math.cos(angle) * 70,
        y: player.y + Math.sin(angle) * 70,
        stunCooldown: 0,
        nextZapTime: Date.now() + Math.random() * 1500
      });
    }
    thunderEndTime = Date.now() + 60000;
    player.energy -= 18;
    document.getElementById("thunderBtn").classList.add("active");
    showWarning("❄️ Kích hoạt kỹ năng Lôi");
  }
};
// Auto bắn
document.getElementById("autoBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  autoShoot = !autoShoot;
  const btn = document.getElementById("autoBtn");
  if (autoShoot) {
    btn.classList.add("active");
    showWarning("🔫 Kích hoạt auto");
  } else {
    btn.classList.remove("active");
    showWarning("🔫 Tắt auto!");
  }
};
// 🐰 Kỹ năng Pet
document.getElementById("PetBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (petActive) return;                       // đang có thỏ → bỏ
  if (player.energy < 5) {
    showWarning("🐰 Không đủ 5 ⚡");
    return;
  }
  activatePet();                               // kích hoạt thành công
  player.energy -= 5;                          // trừ ⚡ duy nhất 1 lần
};
// ✨ Kỹ năng Hào quang
document.getElementById("supportAuraBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
    if (player.level < 6) return showWarning("✨ Yêu cầu Lv6");
    if (player.energy < 15) return showWarning("✨ Không đủ 15⚡");
    
    if (!supportAuraActive) {
        supportAuraActive = true;
        supportAuraEndTime = Date.now() + 60000;
        player.energy -= 15;
        showWarning("✨ Kích hoạt Hào quang!");
        document.getElementById("supportAuraBtn").classList.add("active");

        // Tạo hiệu ứng các đường nứt
        auraCrackLines = [];
        const crackCount = 30;
        const radius = 45;

        for (let i = 0; i < crackCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distFromCenter = Math.random() * radius;
            const length = 5 + Math.random() * 10;
            
            const x1 = Math.cos(angle) * distFromCenter;
            const y1 = Math.sin(angle) * distFromCenter;
            const x2 = x1 + Math.cos(angle) * length;
            const y2 = y1 + Math.sin(angle) * length;

            auraCrackLines.push({ x1, y1, x2, y2 });
        }
    }
};
// 🦋 Kích hoạt kỹ năng Fairy activateFairySkill
document.getElementById("fairyBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 7) return showWarning("🦋 Yêu cầu Lv7");
  if (player.energy < 25) return showWarning("🦋 Không đủ 25⚡");
  if (fairyActive) return; // Không kích hoạt nếu đang trong thời gian hồi

  fairyActive = true;
  fairyEndTime = Date.now() + 60000;
  player.energy -= 25;
  fairyDeathDefyAvailable = true; // Kích hoạt khả năng hồi sinh

  // Tạo các Fairy dựa trên cấp độ nâng cấp
  fairies = [];
  const count = skillUpgrades.fairyCount;
  for (let i = 0; i < count; i++) {
    fairies.push({
      angle: (2 * Math.PI / count) * i,
      orbitRadius: 50 + (i * 10), // Các Fairy bay ở quỹ đạo khác nhau
      bobOffset: Math.random() * Math.PI * 2, // Hiệu ứng nhấp nhô riêng
      nextAttackTime: Date.now() + Math.random() * 2000
    });
  }

  showWarning("🦋 Triệu hồi Fairy!");
};

//🧟 6. Sinh zombie và boss
// 🎨 Màu tương ứng cho zombie cấp 1 → 10
const zombieColorsByLevel = [
  "#00cc66", // Level 1 – Xanh lá sáng (nhẹ nhàng)
  "#3399ff", // Level 2 – Xanh dương (nhạt hơn boss)
  "#ffcc00", // Level 3 – Vàng sáng
  "#ff9900", // Level 4 – Cam
  "#ff3333", // Level 5 – Đỏ sáng
  "#cc00cc", // Level 6 – Tím
  "#9933ff", // Level 7 – Tím xanh điện
  "#ff66cc", // Level 8 – Hồng neon
  "#00ffff", // Level 9 – Xanh cyan
  "#ffffff"  // Level 10 – Trắng sáng chói (gần max)
];

// 📊 Bảng xác suất cấp độ zombie theo từng wave
/**
 * Tính toán cấp độ (sức mạnh) của zombie, cho phép cả 10 loại xuất hiện với tỉ lệ thay đổi theo wave.
 * @param {number} wave - Số wave hiện tại.
 * @returns {number} Cấp độ của zombie (dưới dạng index từ 0 đến 9).
 */
function getZombieLevelByWave(wave) {
    // Wave 1 vẫn luôn là wave khởi động với zombie yếu nhất.
    if (wave === 1) {
        return 0;
    }

    const MAX_ZOMBIE_LEVEL = 9; // Có 10 cấp độ, từ index 0 đến 9.

    // 1. Xác định "trọng tâm độ khó" cho wave hiện tại.
    // Con số này sẽ tăng dần khi wave tăng, quyết định loại zombie nào sẽ phổ biến nhất.
    const centerLevel = (wave - 2) * 0.4;

    // 2. Xác định "độ đa dạng". Con số này càng lớn, các loại zombie xa trọng tâm càng có cơ hội xuất hiện.
    const spread = 2.0 + (wave / 20);

    const weights = [];
    let totalWeight = 0;

    // 3. Vòng lặp qua tất cả 10 cấp độ zombie (0 đến 9) để tính trọng số (tỉ lệ xuất hiện).
    for (let i = 0; i <= MAX_ZOMBIE_LEVEL; i++) {
        // Công thức này tính toán trọng số dựa trên mô hình đường cong Chuẩn (Gaussian curve).
        // Zombie có cấp độ càng gần "trọng tâm độ khó" thì trọng số càng cao, tỉ lệ xuất hiện càng lớn.
        // Ngay cả ở wave cao, zombie cấp thấp vẫn có một trọng số rất nhỏ (nhưng khác 0).
        const distance = i - centerLevel;
        const weight = Math.exp(-(distance * distance) / (2 * spread * spread));
        
        weights.push({ level: i, weight: weight });
        totalWeight += weight;
    }

    // 4. Chọn ngẫu nhiên một cấp độ dựa trên các trọng số đã tính.
    const rand = Math.random() * totalWeight;
    let weightSum = 0;
    for (const item of weights) {
        weightSum += item.weight;
        if (rand < weightSum) {
            return item.level;
        }
    }

    return MAX_ZOMBIE_LEVEL; // Dự phòng nếu có lỗi xảy ra.
}
// Khởi tạo Zombie
function spawnZombie() {
  const z = getZombie();
    // ✨ GÁN CHỦNG LOÀI NGẪU NHIÊN ✨
  z.style = zombieTypes[Math.floor(Math.random() * zombieTypes.length)];
  const level = getZombieLevelByWave(wave); // cấp từ 0–9
// HP zombie tăng theo level player + random 1~10
// --- BẮT ĐẦU PHẦN TÍNH HP CẢI TIẾN ---

    // Kiểm tra xem có phải là wave đầu tiên không.
    // Wave 1 sẽ có cách tính HP đặc biệt để giúp người chơi dễ khởi đầu.
    if (wave === 1) {
        
        // Gán HP cho zombie là một số nguyên ngẫu nhiên từ 1 đến 4.
        // Math.random() * 4 -> tạo số thập phân ngẫu nhiên từ 0 đến 3.99...
        // Math.floor(...)   -> làm tròn xuống (0, 1, 2, hoặc 3)
        // ... + 1           -> kết quả cuối cùng là 1, 2, 3, hoặc 4.
        z.hp = Math.floor(Math.random() * 2) + 1;

    } else {
        
        // Nếu không phải wave 1 (tức là từ wave 2 trở đi), áp dụng công thức tính HP phức tạp hơn.
        // Cấu hình các chỉ số cơ bản để tính toán HP.
        const HP_CONFIG = {
            BASE_HP: 1,                  // HP tối thiểu của một zombie.
            HP_PER_ZOMBIE_LEVEL: 5,      // Lượng HP được cộng thêm cho mỗi cấp của zombie.
            HP_PER_WAVE: 2.5,            // Lượng HP được cộng thêm cho mỗi wave (độ khó tăng dần).
            RANDOM_VARIANCE: 0.20,       // Tỉ lệ ngẫu nhiên (+/- 20%) để HP của zombie đa dạng hơn.
            ELITE_CHANCE: 0.05,          // 5% tỉ lệ xuất hiện zombie Tinh Anh.
            ELITE_HP_MULTIPLIER: 5       // Zombie Tinh Anh sẽ có lượng HP nhân lên 5 lần.
        };

        // Tính toán HP cơ bản trước khi thêm yếu tố ngẫu nhiên.
        // Công thức = HP gốc + HP thưởng theo cấp zombie + HP thưởng theo wave.
        // (wave - 1) được dùng để đảm bảo việc cộng HP theo wave chỉ bắt đầu từ wave 2.
        let calculatedHp = HP_CONFIG.BASE_HP +
                           (level * HP_CONFIG.HP_PER_ZOMBIE_LEVEL) +
                           ((wave - 1) * HP_CONFIG.HP_PER_WAVE);

        // Thêm yếu tố ngẫu nhiên vào HP đã tính.
        const variance = calculatedHp * HP_CONFIG.RANDOM_VARIANCE; // Tính toán lượng HP (+/- 20%).
        calculatedHp += Math.random() * variance * 2 - variance;   // Cộng/trừ ngẫu nhiên trong khoảng đó.

        // Kiểm tra xem zombie có phải là loại Tinh Anh (Elite) hay không.
        if (Math.random() < HP_CONFIG.ELITE_CHANCE) { // Nếu số ngẫu nhiên nhỏ hơn 0.05 (5%)
            calculatedHp *= HP_CONFIG.ELITE_HP_MULTIPLIER; // Nhân HP lên 5 lần.
            z.isElite = true; // Đánh dấu đây là zombie Tinh Anh.
        } else {
            z.isElite = false; // Đánh dấu đây là zombie thường.
        }

        // Gán HP cuối cùng cho zombie, làm tròn và đảm bảo không bao giờ nhỏ hơn 1.
        z.hp = Math.max(1, Math.round(calculatedHp));
    }

    // --- KẾT THÚC PHẦN TÍNH HP ---

    // Lưu lại lượng HP ban đầu của zombie để dùng cho các logic khác nếu cần.
    z.baseHp = z.hp;
    z.level = level + 1; // cấp thật từ 1–10
    z.behaviorCheckCounter = 0; // Khởi tạo bộ đếm chu kỳ hành vi
    z.showStatusIcon = Math.random() < 0.3; // Gán ngẫu nhiên có hiển thị icon hay không lần đầu tiên
    z.lastDayBuffed = currentDay;
    z.isBuffed = false;
    z.nightBuffApplied = false;
    z.lastRegenTime = Date.now();

// 👣 Di chuyển ngẫu nhiên ban đầu
  z.state = "wandering";
  z.nextStateCheck = Date.now() + 3000; // kiểm tra mỗi 3s khi đang chasing - kiểm tra mỗi giây
  z.wanderTime = Date.now() + 2000 + Math.random() * 2000; // từ 2 đến 4 giây
  z.wanderAngle = Math.random() * Math.PI * 2;
// 🎲 Chọn kiểu wander: 80% di chuyển, 20% đứng im
  z.wanderBehavior = Math.random() < 0.2 ? "pause" : "move";
  z.baseSpeed = 0.2 + Math.random() * 1.3; // tốc độ khi chasing - tốc độ khi đuổi theo
  z.speed = 0.3 + Math.random() * 0.9;   // tốc độ khi wandering - tốc độ khi lang thang
  z.color = zombieColorsByLevel[level];
  z.type = "normal";
  z.radius = 15;
  z.isBoss = false;

// 🎯 Random mini boss (xuất hiện 2%) - Tỷ lệ xuất hiện mini boss
// 🎯 Random boss (xuất hiện 1%)
if (Math.random() < 0.01) {
  z.type = "miniBoss";
  z.isBoss = false;                // boss thường (khác với isBigBoss của world boss nếu bạn có)
  // HP boss cao hơn miniBoss rõ rệt — bạn có thể tinh chỉnh hệ số này
  z.hp = 25 * wave + Math.floor(player.level / 2) + Math.floor(Math.random() * 10 + 1);
  z.baseHp = z.hp;
  z.color = bossColors[Math.floor(Math.random() * bossColors.length)];
  z.radius = 16;                  // nhỏ hơn miniBoss
  z.level = 98;                  // đánh dấu riêng
  z.baseSpeed = 0.28 + Math.random() * 0.35;
  z.speed = 0.22 + Math.random() * 0.28;

// 🎯 Random mini boss (xuất hiện 2%) - chỉ xét nếu KHÔNG phải boss
} else if (Math.random() < 0.02) {
  z.type = "miniBoss";
  z.isBoss = false;
  z.hp = 50 + wave + Math.floor(player.level / 2) + Math.floor(Math.random() * 20 + 1);
  z.baseHp = z.hp;
  z.color = bossColors[Math.floor(Math.random() * bossColors.length)];
  z.radius = 18;
  z.level = 99;
}
// 🛡️ ARMOR BY LEVEL + TYPE (không sinh rác)
{
  const lvClamp = Math.max(1, Math.min(10, Number(z.level || 1))); // 1..10
  const baseArmor = (lvClamp - 1) + Math.round(Math.random());     // lv-1 .. lv
  let extra = 0;
  if (z.isElite) extra += 2;
  if (z.type === "miniBoss") extra += 5;
  if (z.type === "boss") extra += 10;
  if (z.isBigBoss || z.type === "bigBoss") extra += 20;
  z.armor = baseArmor + extra;
}

// 📍 Tạo zombie ngẫu nhiên bên trong bản đồ
z.x = Math.random() * worldWidth;
z.y = Math.random() * worldHeight;
// 📍 Đặt zombie
  zombies.push(z);
  zombieSpawnedCount++;
}

// Màu boss
const bossColors = [
  "#ff3333", // Đỏ tươi
  "#ff8800", // Cam rực
  "#ffaa00", // Vàng cam
  "#00ccff", // Xanh dương sáng
  "#9933ff", // Tím đậm
  "#00ff99", // Xanh ngọc
  "#ff66cc", // Hồng neon
  "#ffffff", // Trắng lạnh
  "#888888", // Xám tro (boss máy móc)
  "#00ffff"  // Xanh cyan ánh kim
];
// Giới hạn vào trong tường/map giống dropItem
function clampToWorld(x, y) {
  const safeX = Math.min(worldWidth - wallThickness - 20, Math.max(wallThickness + 20, x));
  const safeY = Math.min(worldHeight - wallThickness - 20, Math.max(wallThickness + 20, y));
  return { x: safeX, y: safeY };
}
// === Mini Boss & Elite Spawners ===
function spawnMiniBossAt(x, y) {
  const z = getZombie();

  // Vị trí (kẹp biên theo bán kính 18 nếu có)
  if (typeof clampToWorld === 'function') {
    const p = clampToWorld(x, y, 18);
    z.x = p.x; z.y = p.y;
  } else {
    z.x = x; z.y = y;
  }

  // ✨ Đồng bộ các field nền như spawnZombie()
  z.style = zombieTypes[(Math.random() * zombieTypes.length) | 0];

  // State/di chuyển (quan trọng để không "đứng im")
  z.state = "chasing";
  z.nextStateCheck = Date.now() + 3000;
  z.wanderTime = Date.now() + 2000 + Math.random() * 2000;
  z.wanderAngle = Math.random() * Math.PI * 2;
  z.wanderBehavior = Math.random() < 0.2 ? "pause" : "move";

  // Dải tốc độ như spawnZombie() (chasing dùng baseSpeed)
  z.baseSpeed = 0.2 + Math.random() * 0.8; // 0.2–1.0
  z.speed = z.baseSpeed;                   // vì đang "chasing"

  // Mini Boss core
  z.type   = "miniBoss";
  z.radius = 18;
  z.hp     = 50 + wave + ((player.level / 2) | 0) + (((Math.random() * 20) | 0) + 1);
  z.baseHp = z.hp;   // ✅ đồng bộ với spawnZombie()
  z.level  = 99;
  if (Array.isArray(bossColors) && bossColors.length) {
    z.color = bossColors[(Math.random() * bossColors.length) | 0];
  }
  z.isBoss = false; // giữ rõ ràng (getZombie() đã false, dòng này chỉ để nhất quán)

  // Cờ/đếm như spawnZombie()
  z.behaviorCheckCounter = 0;
  z.showStatusIcon = Math.random() < 0.3;
  z.lastDayBuffed = currentDay;
  z.isBuffed = false;
  z.nightBuffApplied = false;
  z.lastRegenTime = Date.now();

  zombies.push(z);
  return z;
}
// Elite đơn: chỉ bật cờ + AI, stat để hệ thống chung lo (tránh xung đột)
function spawnEliteAt(x, y) {
  const z = getZombie();

  // Vị trí (kẹp biên nếu có)
  if (typeof clampToWorld === 'function') {
    const p = clampToWorld(x, y, /*r=*/15);
    z.x = p.x; z.y = p.y;
  } else {
    z.x = x; z.y = y;
  }

  // ✨ GÁN CHỦNG LOÀI NGẪU NHIÊN (như spawnZombie)
  z.style = zombieTypes[(Math.random() * zombieTypes.length) | 0];

  const levelIdx = getZombieLevelByWave(wave); // 0..9

  // --- TÍNH HP giống hệt spawnZombie, nhưng ép Elite ---
  if (wave === 1) {
    z.hp = Math.floor(Math.random() * 2) + 1; // 1..2 như code gốc hiện tại
  } else {
    const BASE_HP = 1;
    const HP_PER_ZOMBIE_LEVEL = 5;
    const HP_PER_WAVE = 2.5;
    const RANDOM_VARIANCE = 0.20;
    const ELITE_HP_MULTIPLIER = 5;

    let calculatedHp = BASE_HP
      + (levelIdx * HP_PER_ZOMBIE_LEVEL)
      + ((wave - 1) * HP_PER_WAVE);

    const variance = calculatedHp * RANDOM_VARIANCE;
    calculatedHp += Math.random() * variance * 2 - variance;

    calculatedHp *= ELITE_HP_MULTIPLIER; // ép Elite
    z.hp = Math.max(1, Math.round(calculatedHp));
  }
  z.isElite = true;
  z.baseHp = z.hp;

  // --- Các field khác như spawnZombie ---
  z.level = levelIdx + 1;        // 1..10
  z.behaviorCheckCounter = 0;
  z.showStatusIcon = Math.random() < 0.3;
  z.lastDayBuffed = currentDay;
  z.isBuffed = false;
  z.nightBuffApplied = false;
  z.lastRegenTime = Date.now();

  // 👣 State/di chuyển (QUAN TRỌNG để không "đứng im")
  z.state = "wandering";
  z.nextStateCheck = Date.now() + 3000;
  z.wanderTime = Date.now() + 2000 + Math.random() * 2000;
  z.wanderAngle = Math.random() * Math.PI * 2;
  z.wanderBehavior = Math.random() < 0.2 ? "pause" : "move";
  z.baseSpeed = 0.2 + Math.random() * 0.8;
  z.speed = 0.15 + Math.random() * 0.5;

  // Màu theo cấp (giống gốc)
  z.color = zombieColorsByLevel[levelIdx];

  // Loại/hitbox như zombie thường (KHÔNG chuyển type)
  z.type = "normal";
  z.radius = 15;
  z.isBoss = false;

  zombies.push(z);
  zombieSpawnedCount++;
  return z;
}

// Elite Pack: dùng spawnEliteAt để bảo toàn pipeline
function spawnElitePackAt(cx, cy, cfg = 3) {
  const isNum  = typeof cfg === "number";
  const count  = isNum ? cfg : (cfg.count  ?? 3);
  const radius = isNum ? 24  : (cfg.radius ?? 24);
  const jitter = isNum ? 10  : (cfg.jitter ?? 10);

  for (let i = 0; i < count; i++) {
    const ang = Math.random() * Math.PI * 2;
    let ex = cx + Math.cos(ang) * (radius + Math.random() * jitter);
    let ey = cy + Math.sin(ang) * (radius + Math.random() * jitter);

    if (typeof clampToWorld === "function") {
      const p = clampToWorld(ex, ey, /*r=*/15);
      ex = p.x; ey = p.y;
    }
    spawnEliteAt(ex, ey);
  }
}
// Hàm sinh Boss 👹
function spawnBoss(spawnX, spawnY) { // Thêm 2 tham số vị trí
  const z = getZombie();

  // NẾU CÓ VỊ TRÍ CỤ THỂ -> TẠO BOSS TẠI ĐÓ
  if (spawnX !== undefined && spawnY !== undefined) {
      z.x = spawnX;
      z.y = spawnY;
  } else {   // 📍 ➊ Chọn vị trí ngẫu nhiên trong world
  // (worldWidth / worldHeight đã dùng cho zombie thường)
  do {
    z.x = Math.random() * worldWidth;
    z.y = Math.random() * worldHeight;
    // 📏 ➋ Bảo đảm không “úp sọt” player
  } while (distance(z, player) < 250); // ≥ 250 px mới cho xuất hiện
  }
  z.radius = 30;
  z.baseSpeed = 0.015 + Math.random() * 0.2; // Lưu tốc độ gốc | Tốc độ boss
  z.speed = z.baseSpeed; // Tốc độ zombie
  z.isBoss = true;
  // HP boss tăng theo wave và level player + random 1~100
  z.hp = 500 + wave * 2 + Math.floor(player.level / 2) + Math.floor(Math.random() * 100 + 1);
  z.baseHp = z.hp; // 🔑 Ghi nhớ HP gốc để reset ban ngày
  z.type = "boss";
  z.level = 100; // level Boss
  z.armor = (9 + Math.round(Math.random())) + 10; // base(9..10) + 10 cho Boss
  z.color = bossColors[Math.floor(Math.random() * bossColors.length)]; // Màu boss
  z.active = true;
  z.state = "chasing";
  zombies.push(z);
  zombieSpawnedCount++;
  z.lastDayBuffed = currentDay;
  z.isBuffed = false;
  z.nightBuffApplied = false;
  z.lastRegenTime = Date.now();
}
// Hàm sinh Big Boss 👹 – boss mạnh nhất
function spawnBigBoss() {
    const z = getZombie();
    z.active = true; // reset lại chắc chắn
    z.state = "chasing";
    z._killed = false;

    do {
        z.x = Math.random() * worldWidth;
        z.y = Math.random() * worldHeight;
    } while (distance(z, player) < 250); // tránh sinh gần player

    z.radius = 120; // Kích thước bigboss
    z.baseSpeed = 0.01 + Math.random() * 0.2;
    z.speed = z.baseSpeed;
    z.isBoss = true;
    z.isBigBoss = true; // 🔑 Đánh dấu riêng bigBoss
    z.hp = 10000 + wave * 500 + Math.floor(Math.random() * 1000 + 250);
    z.baseHp = z.hp;
    z.type = "bigBoss";
    z.level = 999;
    z.armor = (9 + Math.round(Math.random())) + 20; // base(9..10) + 20 cho BigBoss
    z.color = "purple"; // Đổi màu để dễ phân biệt
    z.active = true;
z.lazerTimer = 0;
z.isLazerAttacking = false;
z.lazerDuration = 0;
    zombies.push(z);
    zombieSpawnedCount++;
    z.lastDayBuffed = currentDay;
    z.isBuffed = false;
    z.nightBuffApplied = false;
    z.lastRegenTime = Date.now();
}

//🧠 7. Cập nhật UI – chỉ DOM
// 🧟 Hàm cập nhật Wave riêng biệt
function updateWaveUI() {
  document.getElementById("score-bottom").innerText = 
  `Level: ${player.level.toString().padStart(4, '0')} |⚡: ${player.energy.toString().padStart(4, '0')}`;
  setTimeout(() => {
  document.getElementById("waveNumberDisplay").innerText = `Wave: ${wave}`;
}, 1000); // ⏱️ hiển thị sau 1 giây
  document.getElementById("ui-mana").innerText = `💠 Mana: ${player.mana}`;
  document.getElementById("ui-stamina").innerText = `🔹 Stamina: ${player.stamina}`;
}
// Các biến lưu trạng thái hiển thị trước đó để tránh cập nhật DOM không cần thiết
let lastScore = -1, lastLevel = -1, lastEnergy = -1, lastHearts = -1, lastHighScore = -1; let lastMana = -1;
let lastBladeText = "", lastSwordText = "", lastFireText = "", lastIceText = "", lastFpsText = "", lastPetText = "";
let lastDay = -1, lastCoins = -1, lastExp = -1;
const BUFF_INFO = {
  lucky: { icon: '🍀', name: 'LuckyUp', desc: 'Tăng tỉ lệ rơi vật phẩm 30% và có thể nhân đôi số lượng rơi.' },
  power: { icon: '🍁', name: 'PowerUp', desc: 'Tăng mạnh sát thương lên đến 150% và tăng theo cấp độ của bạn.' },
  crazy: { icon: '🍂', name: 'CrazyUp', desc: 'Tăng các chỉ số cơ bản, tốc chạy: 0.5, tốc bắn: 1, sát thương 50%, số lượng đạn: 1, iceArrow: 10.' },
  exp:   { icon: '🌿', name: 'ExpUp',   desc: 'Tăng 50% EXP nhận được.' },
  magnet:{ icon: '🧲', name: 'Magnet',  desc: 'Tự động hút các vật phẩm ở gần.' },
  crazymadness:{ icon:'💢', name:'CrazyMadnessTime', desc:'Trạng thái cuồng nộ đặc biệt, tăng mạnh các chỉ số cơ bản, tốc chạy: 0.5, tốc bắn: 1, sát thương 200%, số lượng đạn: 1, iceArrow: 10.' }
};
function setBuffTip(el, id, endTime){
  if (!el) return;
  const info = BUFF_INFO[id];
  const now = Date.now();
  const active = now < endTime;
  const tip = `${info.icon} ${info.name}\n${info.desc}` + (active ? `\nCòn lại: ${((endTime - now)/1000).toFixed(1)}s` : '');
  if (el.dataset.tooltip !== tip) el.dataset.tooltip = tip; // tránh ghi DOM thừa
}

function updateUI() {
    // --- CẬP NHẬT CÁC THÔNG TIN PHỤ ---
    if (currentDay !== lastDay) {
        document.getElementById('dayCounterDisplay').innerText = `Ngày: ${currentDay}`;
        lastDay = currentDay;
    }

    // Cập nhật Kỷ lục (High Score) bằng player.score (số kill)
    const highScore = parseInt(localStorage.getItem('highScore') || '0');
    if (player.score > highScore) {
        localStorage.setItem('highScore', player.score);
    }
    if (highScore !== lastHighScore) {
        document.getElementById("highScoreDisplay").innerText = `🏆 Kỷ lục: ${highScore}`;
        lastHighScore = highScore;
    }
    
    // --- CẬP NHẬT THANH TRẠNG THÁI CHÍNH ---

    // Cập nhật hiển thị tiến trình EXP và HP
    const scoreTopDiv = document.getElementById("score-top");
    const required = player.requiredExp;
    const current = player.currentLevelExp;
    const remaining = required - current;

    // Tạo chuỗi text mới cho EXP và HP
    const newExpText = `Exp: ${current.toString().padStart(4, '0')} |❤️: ${parseFloat(player.hearts.toFixed(2)).toString().padStart(4, '0')}`;
    // Chỉ cập nhật DOM
    if (scoreTopDiv.innerText !== newExpText) {
        scoreTopDiv.innerText = newExpText;
    }
    
    // Cập nhật tooltip với lượng EXP còn lại
    const newTooltip = `Exp cấp tiếp theo: ${remaining}`;
    if (scoreTopDiv.dataset.tooltip !== newTooltip) {
        scoreTopDiv.dataset.tooltip = newTooltip;
    }

    // Cập nhật hiển thị số xu
    if (player.coins !== lastCoins) {
        const formattedCoins = player.coins.toString().padStart(4, '0');
        document.getElementById('coinCounterDisplay').innerText = `🪙: ${formattedCoins}`;
        lastCoins = player.coins;
    }

    // Cập nhật hiển thị Level và Energy
    if (player.level !== lastLevel || player.energy !== lastEnergy) {
        lastLevel = player.level;
        lastEnergy = player.energy;
        updateWaveUI(); // Gọi hàm con để cập nhật text cho Level và Energy
    }

    // Cập nhật hiển thị Mana
    if (player.mana !== lastMana) {
        lastMana = player.mana;
        document.getElementById("ui-mana").innerText = `💠 Mana: ${player.mana}`;
    }
if (player.stamina !== lastStamina) {
    lastStamina = player.stamina;
    const roundedStamina = parseFloat(player.stamina.toFixed(2)); // ⬅️ 2 chữ số
    document.getElementById("ui-stamina").innerText = `🔹 Stamina: ${roundedStamina}`;
}
    // --- CẬP NHẬT HIỂN THỊ CÁC BUFF TẠM THỜI ---
    
    // Cập nhật hiển thị cho buff Lucky
    const luckyDisplay = document.getElementById('luckyBuffDisplay');
            setBuffTip(luckyDisplay, 'lucky', luckyBuffEndTime);
    if (Date.now() < luckyBuffEndTime) {
        luckyDisplay.classList.remove('inactive');
        luckyDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((luckyBuffEndTime - Date.now()) / 1000);
        luckyDisplay.innerHTML = `🍀 LuckyUp: <span>${timeLeft}</span>s`; // Sửa tên
    } else {
        luckyDisplay.classList.add('inactive');
        luckyDisplay.classList.remove('active-glow');
        luckyDisplay.innerHTML = `🍀 LuckyUp: <span>---</span>`; // Sửa tên
    }

    // Cập nhật hiển thị cho buff Power
    const powerDisplay = document.getElementById('powerBuffDisplay');
            setBuffTip(powerDisplay, 'power', powerBuffEndTime);
    if (Date.now() < powerBuffEndTime) {
        powerDisplay.classList.remove('inactive');
        powerDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((powerBuffEndTime - Date.now()) / 1000);
        powerDisplay.innerHTML = `🍁 PowerUp: <span>${timeLeft}</span>s`; // Sửa tên
    } else {
        powerDisplay.classList.add('inactive');
        powerDisplay.classList.remove('active-glow');
        powerDisplay.innerHTML = `🍁 PowerUp: <span>---</span>`; // Sửa tên
    }
    
    // Cập nhật hiển thị cho buff Crazy
    const crazyDisplay = document.getElementById('crazyBuffDisplay');
            setBuffTip(crazyDisplay, 'crazy', crazyBuffEndTime);
    if (Date.now() < crazyBuffEndTime) {
        crazyDisplay.classList.remove('inactive');
        crazyDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((crazyBuffEndTime - Date.now()) / 1000);
        crazyDisplay.innerHTML = `🍂 CrazyUp: <span>${timeLeft}</span>s`; // Sửa tên
    } else {
        crazyDisplay.classList.add('inactive');
        crazyDisplay.classList.remove('active-glow');
        crazyDisplay.innerHTML = `🍂 CrazyUp: <span>---</span>`; // Sửa tên
    }

    // Cập nhật hiển thị cho buff ExpUp (MỚI)
    const expDisplay = document.getElementById('expBuffDisplay');
            setBuffTip(expDisplay, 'exp', expBuffEndTime);
    if (Date.now() < expBuffEndTime) {
        expDisplay.classList.remove('inactive');
        expDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((expBuffEndTime - Date.now()) / 1000);
        expDisplay.innerHTML = `🌿 ExpUp: <span>${timeLeft}</span>s`;
    } else {
        expDisplay.classList.add('inactive');
        expDisplay.classList.remove('active-glow');
        expDisplay.innerHTML = `🌿 ExpUp: <span>---</span>`;
    }
    // Cập nhật hiển thị cho buff Magnet
    const magnetDisplay = document.getElementById('magnetBuffDisplay');
            setBuffTip(magnetDisplay, 'magnet', magnetBuffEndTime);
    if (Date.now() < magnetBuffEndTime) {
        magnetDisplay.style.display = 'block'; // Hiện lên
        magnetDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((magnetBuffEndTime - Date.now()) / 1000);
        magnetDisplay.innerHTML = `🧲 Magnet: <span>${timeLeft}</span>s`;
    } else {
        magnetDisplay.style.display = 'none'; // Ẩn đi
        magnetDisplay.classList.remove('active-glow');
    }
    // Cập nhật hiển thị cho buff CrazyMadnessTime (MỚI)
    const crazyMadnessDisplay = document.getElementById('crazymadnesstimeBuffDisplay');
            setBuffTip(crazyMadnessDisplay, 'crazymadness', crazyMadnessTimeEndTime);
    if (Date.now() < crazyMadnessTimeEndTime) {
        crazyMadnessDisplay.style.display = 'block'; // Hiện lên
        crazyMadnessDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((crazyMadnessTimeEndTime - Date.now()) / 1000);
        crazyMadnessDisplay.innerHTML = `💢 CrazyMadnessTime: <span>${timeLeft}</span>s`;
    } else {
        crazyMadnessDisplay.style.display = 'none'; // Ẩn đi
        crazyMadnessDisplay.classList.remove('active-glow');
    }
}

// 🧿 Tìm zombie còn sống gần player nhất 
function findActiveZombie() {
  return zombies.find(z => z.active);
}

/* ───────────────────────────────────────
   🐰 CẬP NHẬT PET – GỌI MỖI FRAME
   ─────────────────────────────────────── */
// ====== PET EQUIP VISITOR (no-alloc) ========================================
// Dùng lại mỗi frame, không tạo callback ẩn danh.
let __petMinD2 = 0, __petRef = null;
function __visitDropForPet(d) {
  if (!d || d.active === false) return;
  const dx = d.x - __petRef.x, dy = d.y - __petRef.y;
  const d2 = dx * dx + dy * dy;
  if (d2 < __petMinD2) {
    __petMinD2 = d2;
    __petRef.target = d;
    __petRef.targetIsEquip = true;
  }
}

// ====== UPDATE PET ===========================================================
function updatePet() {
  const now = Date.now();
  if (!petActive || !petRabbit) return;

  // Hằng số
  const DIST_ITEM    = 360;
  const DIST_FOLLOW  = 480;
  const TOLERANCE    = 40;
  const PICK_DIST    = 16;
  const GIVE_UP_MS   = 3000;
  const MIN_PROGRESS = 20;

  // Tốc độ pet
  petRabbit.speed = (player.speed ?? 1) + 0.4;

  // 0) Quá xa → quay về
  if (distance(petRabbit, player) > DIST_FOLLOW) {
    moveTowards(petRabbit, player, petRabbit.speed * 1.6);
    petRabbit.target = null;
    petRabbit.targetIsEquip = false;
    return;
  }

  // 1) Chọn mục tiêu mới (ưu tiên gần nhất)
  if (!petRabbit.target || !petRabbit.target.active) {
    petRabbit.target = null;
    petRabbit.targetIsEquip = false;

    let minDistanceSq = DIST_ITEM * DIST_ITEM;

    // 1.a) ITEMS thường
    for (let i = 0; i < items.length; i++) {
      const it = items[i];
      if (!it || !it.active) continue;
      if (now - lastGiveUpTime < RESELECT_CD && it.id === lastGiveUpId) continue;
      const d2 = distanceSq(petRabbit, it);
      if (d2 < minDistanceSq) {
        minDistanceSq = d2;
        petRabbit.target = it;
        petRabbit.targetIsEquip = false;
      }
    }

    // 1.b) TRANG BỊ rơi (EquipmentDropAPI) — no-alloc visitor
    const api = window.EquipmentDropAPI;
    if (api && typeof api.forEachActiveDrop === 'function') {
      __petMinD2 = minDistanceSq;
      __petRef   = petRabbit;
      api.forEachActiveDrop(__visitDropForPet);
      // Nếu vừa chọn equip → cập nhật lại minDistanceSq để progress chuẩn
      if (petRabbit.targetIsEquip) minDistanceSq = __petMinD2;
    }

    if (petRabbit.target) {
      petRabbit.chaseStart    = now;
      petRabbit.startDistance = Math.sqrt(minDistanceSq);
    }
  }

  // 2) Đuổi & nhặt
  if (petRabbit.target) {
    const tg = petRabbit.target;
    const dNow    = distance(petRabbit, tg);
    const elapsed = now - (petRabbit.chaseStart || now);
    const progress = (petRabbit.startDistance || 0) - dNow;

    // Không tiến triển → bỏ
    if (elapsed > GIVE_UP_MS && progress < MIN_PROGRESS) {
      giveUp();
      return;
    }
    // Mục tiêu quá xa player → bỏ
    if (distance(player, tg) > DIST_FOLLOW) {
      giveUp();
      return;
    }

    // Di chuyển tới mục tiêu
    moveTowards(petRabbit, tg, petRabbit.speed);

    // Tới gần → nhặt
    if (dNow < PICK_DIST) {
      collectLoot(); // đã hỗ trợ cả TRANG BỊ (petRabbit.targetIsEquip)
      return;
    }
  }
  // 3) Không có mục tiêu → bám player
  else if (distance(petRabbit, player) > TOLERANCE) {
    moveTowards(petRabbit, player, petRabbit.speed * 1.2);
  }

  // ✨ Tấn công (giữ tối ưu)
  if (petRabbit.attackTimer > 0) {
    petRabbit.attackTimer -= 1000 * globalDeltaTime;
  }
  if (petRabbit.attackTimer <= 0) {
    let nearestZombie = null, minZombD2 = Infinity;
    for (let i = 0; i < zombies.length; i++) {
      const z = zombies[i];
      if (!z || !z.active) continue;
      const d2 = distanceSq(petRabbit, z);
      if (d2 < minZombD2) { minZombD2 = d2; nearestZombie = z; }
    }
    if (nearestZombie) {
      petRabbit.attackTimer = 1000;
      const b = getBullet();
      b.x = petRabbit.x; b.y = petRabbit.y;
      const ang = Math.atan2(nearestZombie.y - petRabbit.y, nearestZombie.x - petRabbit.x);
      b.dx = Math.cos(ang); b.dy = Math.sin(ang);
      b.isPetBullet = true;
      b.icon = '🥕';
      b.speed = 2;
      b.stunDuration = 1000;
      b.customDmg = 1 + (wave - 1) + (player.level - 1);
      bullets.push(b);
    }
  }

  // Hồi máu & hết giờ (giữ nguyên)
  if (now - petLastHealTime >= 3000) {
    petLastHealTime = now;
    player.hearts = Math.min(player.maxHearts, player.hearts + 1);
    createHealImpactEffect(player, 1);
  }
  if (now >= petEndTime) {
    petActive = false;
    petRabbit = null;
    showWarning("🐰 Pet đã rời đi.");
  }
}

/* ───────────────────────────────────────
   🚀 CẬP NHẬT TÊN LỬA – GỌI MỖI FRAME
   ─────────────────────────────────────── */
function updateMissiles() {
  // Lặp ngược để xóa phần tử an toàn
  for (let i = missiles.length - 1; i >= 0; i--) {
    const m = missiles[i];
    let shouldRemove = false; // Cờ để quyết định có xóa tên lửa không

    // --- Giai đoạn chờ (delay) ---
    if (m.state === "delay") {
      m.delay--;
      if (m.delay <= 0) {
        m.state = "fly";
      }
      continue; 
    }

    // --- Cập nhật di chuyển & dẫn hướng ---
    if (m.target && m.target.active) {
      const desiredAngle = Math.atan2(m.target.y - m.y, m.target.x - m.x);
      const currentAngle = Math.atan2(m.dy, m.dx);
      const turnRate = 0.05;
      let delta = desiredAngle - currentAngle;
      if (delta > Math.PI) delta -= 2 * Math.PI;
      if (delta < -Math.PI) delta += 2 * Math.PI;
      const newAngle = currentAngle + Math.sign(delta) * Math.min(turnRate, Math.abs(delta));
      const speed = 2.5;
      m.dx = Math.cos(newAngle) * speed;
      m.dy = Math.sin(newAngle) * speed;
    }
    m.x += m.dx;
    m.y += m.dy;

    // --- Gây sát thương xuyên trên đường bay ---
    zombies.forEach(z => {
      if (z.active && !m.hitSet.has(z) && distance(m, z) < 20) {
        if (!z.missileHitCooldown || Date.now() > z.missileHitCooldown) {
          dealDamageToZombie(z, m.damage);
          m.hitSet.add(z);
          z.missileHitCooldown = Date.now() + 100;
        }
      }
    });

    // --- Kiểm tra điều kiện để nổ ---
    const travelDistance = distance({ x: m.startX, y: m.startY }, m);
    const hitTarget = m.target && m.target.active && distance(m, m.target) < 25;

    if (travelDistance > 360 || hitTarget) {
      // Kích hoạt vụ nổ kép
      zombies.forEach(z => {
        if (z.active && distance(m, z) < 120) {
          dealDamageToZombie(z, m.damage);
        }
      });
      createParticleExplosion(m.x, m.y, 50, 'fire');
      setTimeout(() => {
        zombies.forEach(z => {
          if (z.active && distance(m, z) < 120) {
            dealDamageToZombie(z, m.damage * 0.5);
          }
        });
        const secondaryExplosion = getExplosion(m.x, m.y);
        secondaryExplosion.life = 15;
        explosions.push(secondaryExplosion);
      }, 200);
      shouldRemove = true;
    }

    if (shouldRemove) {
      missiles.splice(i, 1);
    }
  }
}

/* ================================
   1) LƯỚI KHÔNG GIAN (SPATIAL GRID)
   - Mục tiêu: chỉ xét đối tượng "ở gần" hố đen.
   - KHÔNG tạo mảng mới mỗi frame -> tránh GC.
   - Với world 3000x2000, cell 200 là hợp lý (có thể chỉnh).
================================== */

const WORLD_W = 3000;
const WORLD_H = 2000;
const CELL_SIZE = 200; // nên >= pullRadius lớn nhất để giảm số cell kiểm tra

const GRID_COLS = Math.ceil(WORLD_W / CELL_SIZE);
const GRID_ROWS = Math.ceil(WORLD_H / CELL_SIZE);
const GRID_COUNT = GRID_COLS * GRID_ROWS;

// Mảng cell tái sử dụng cho mỗi frame (mỗi cell là 1 mảng reuse)
const gridZ = new Array(GRID_COUNT);
const gridB = new Array(GRID_COUNT);
for (let i = 0; i < GRID_COUNT; i++) {
    gridZ[i] = [];
    gridB[i] = [];
}

// Scratch array dùng tạm cho mỗi hố đen (không cấp phát mới)
const scratchCells = [];

// Giới hạn & tính chỉ số cell từ toạ độ
function clamp(v, min, max) {
    return v < min ? min : (v > max ? max : v);
}
function cellIndexFromXY(x, y) {
    // clamp để tránh vượt ngoài biên
    x = clamp(x, 0, WORLD_W - 1);
    y = clamp(y, 0, WORLD_H - 1);
    const col = (x / CELL_SIZE) | 0;
    const row = (y / CELL_SIZE) | 0;
    return row * GRID_COLS + col;
}

// Liệt kê các cell mà một hình tròn (tâm cx,cy; bán kính r) cắt qua
// Ghi thẳng vào 'out' (scratchCells), không return mảng mới -> tránh GC.
function cellsForCircle(cx, cy, r, out) {
    let minCol = ((cx - r) / CELL_SIZE) | 0;
    let maxCol = ((cx + r) / CELL_SIZE) | 0;
    let minRow = ((cy - r) / CELL_SIZE) | 0;
    let maxRow = ((cy + r) / CELL_SIZE) | 0;

    if (minCol < 0) minCol = 0;
    if (minRow < 0) minRow = 0;
    if (maxCol >= GRID_COLS) maxCol = GRID_COLS - 1;
    if (maxRow >= GRID_ROWS) maxRow = GRID_ROWS - 1;

    // Ghi trực tiếp chỉ số cell vào 'out'
    let k = 0;
    for (let r0 = minRow; r0 <= maxRow; r0++) {
        const base = r0 * GRID_COLS;
        for (let c = minCol; c <= maxCol; c++) {
            out[k++] = base + c;
        }
    }
    out.length = k; // cắt chiều dài về đúng số ô
}

/* ============================================
   2) CẬP NHẬT CHỈ MỤC KHÔNG GIAN CHO ENTITIES
   - Gọi MỘT LẦN trước khi update hố đen mỗi frame.
   - Không tạo mảng mới: chỉ reset length = 0.
============================================= */

function clearSpatialGrid() {
    // GRID_COUNT nhỏ (~150) nên việc reset rất rẻ
    for (let i = 0; i < GRID_COUNT; i++) {
        gridZ[i].length = 0;
        gridB[i].length = 0;
    }
}

function updateSpatialIndex() {
    clearSpatialGrid();

    // Ghi zombie vào lưới
    for (let i = 0; i < zombies.length; i++) {
        const z = zombies[i];
        if (!z.active) continue;
        const idx = cellIndexFromXY(z.x, z.y);
        gridZ[idx].push(z);
    }

    // Ghi đạn địch vào lưới
    for (let i = 0; i < enemyBullets.length; i++) {
        const b = enemyBullets[i];
        if (!b.active) continue;
        const idx = cellIndexFromXY(b.x, b.y);
        gridB[idx].push(b);
    }
}

/* ============================================================
   3) updateBlackHoles
   - duyệt ngược + splice để xoá.
   - Chỉ xét entity trong các cell giao với pullRadius.
   - Hạn chế Math.sqrt: chỉ sqrt khi chắc chắn trong phạm vi.
   - Tránh atan2/cos/sin: dùng vector chuẩn hoá (dx,dy)/d.
============================================================= */
const FEEL_COMPAT = true;
const Z_PULL_MULT = FEEL_COMPAT ? 4 : 2;
const B_PULL_MULT = FEEL_COMPAT ? 2 : 1;
const DAMAGE_INTERVAL = 30;
const PARTICLE_INTERVAL = FEEL_COMPAT ? 2 : 3;

function isCircleVisible(x, y, r, camera) {
    if (!camera) return true; // nếu không có camera, luôn vẽ
    const left   = camera.x - r - 64;
    const right  = camera.x + camera.w + r + 64;
    const top    = camera.y - r - 64;
    const bottom = camera.y + camera.h + r + 64;
    return (x >= left && x <= right && y >= top && y <= bottom);
}

function updateBlackHoles() {
    const now = Date.now();

    // Duyệt ngược để có thể splice xoá phần tử an toàn
    for (let i = blackHoles.length - 1; i >= 0; i--) {
        const hole = blackHoles[i];

        // Hết hạn sống → xoá ngay, không xử lý tiếp
        if (now >= hole.endTime) {
            blackHoles.splice(i, 1);
            continue;
        }

        // Tick chỉ tăng 1 lần/frame
        hole.tick++;

        // Cache thuộc tính dùng nhiều lần để giảm lookup
        const pullRadius = hole.pullRadius | 0;
        const pullSpeed  = hole.pullSpeed;
        const hx = hole.x, hy = hole.y;

        // Precompute cho kiểm tra phạm vi
        const r2   = pullRadius * pullRadius;
        const invR = pullRadius > 0 ? (1 / pullRadius) : 0;
        const damageThisTick = (hole.tick % DAMAGE_INTERVAL === 0);

        // Chỉ hút khi có bán kính & tốc độ hút
        if (pullRadius > 0 && pullSpeed !== 0) {
            // Lấy danh sách cell giao với hình tròn hút (không tạo mảng mới)
            cellsForCircle(hx, hy, pullRadius, scratchCells);
            // Duyệt từng cell ứng viên
            for (let ci = 0; ci < scratchCells.length; ci++) {
                const idx = scratchCells[ci];

                // --- Hút zombie ---
                const cellZ = gridZ[idx];
                for (let zi = 0; zi < cellZ.length; zi++) {
                    const z = cellZ[zi];
                    if (!z.active) continue;

                    // Vector từ zombie đến tâm hố
                    const dx = hx - z.x;
                    const dy = hy - z.y;
                    const d2 = dx * dx + dy * dy;

                    // So sánh bình phương khoảng cách để tránh sqrt sớm
                    if (d2 < r2) {
                        // Chỉ sqrt khi chắc chắn trong phạm vi
                        const d = Math.sqrt(d2) || 1e-6; // tránh chia 0
                        const invD = 1 / d;

                        // Lực hút giảm theo khoảng cách: (1 - d/R) * pullSpeed * Z_PULL_MULT
                        const strength = (1 - d * invR) * pullSpeed * Z_PULL_MULT;

                        // Đẩy zombie về phía tâm (chuẩn hoá vector → không cần atan2/cos/sin)
                        z.x += dx * invD * strength;
                        z.y += dy * invD * strength;

                        if (damageThisTick) {
                            dealDamageToZombie(z, hole.damage);
                        }
                    }
                }

                // --- Hút đạn địch ---
                const cellB = gridB[idx];
                for (let bi = 0; bi < cellB.length; bi++) {
                    const b = cellB[bi];
                    if (!b.active) continue;

                    const dx = hx - b.x;
                    const dy = hy - b.y;
                    const d2 = dx * dx + dy * dy;

                    if (d2 < r2) {
                        const d = Math.sqrt(d2) || 1e-6;
                        const invD = 1 / d;
                        b.x += dx * invD * pullSpeed * B_PULL_MULT;
                        b.y += dy * invD * pullSpeed * B_PULL_MULT;

                        // Đủ gần tâm → thu hồi/huỷ
                        if (d < 20) {
                            releaseEnemyBullet(b);
                        }
                    }
                }
            }
        }

        // Di chuyển hố đen (sau khi hút), rồi clamp biên
        hole.x = hx + hole.dx;
        hole.y = hy + hole.dy;

        if (hole.x < wallThickness) hole.x = wallThickness;
        else if (hole.x > worldWidth - wallThickness) hole.x = worldWidth - wallThickness;

        if (hole.y < wallThickness) hole.y = wallThickness;
        else if (hole.y > worldHeight - wallThickness) hole.y = worldHeight - wallThickness;

        if (hole.tick % PARTICLE_INTERVAL === 0) {
            if (!globalThis.camera || isCircleVisible(hole.x, hole.y, pullRadius, globalThis.camera)) {
                createVortexParticle(hole.x, hole.y, pullRadius);
            }
        }
    }
}

/* ───────── helpers ───────── */
function moveTowards(obj, target, spd) {
  const ang = Math.atan2(target.y - obj.y, target.x - obj.x);
  obj.x += Math.cos(ang) * spd;
  obj.y += Math.sin(ang) * spd;
}
// Pet nhặt vật phẩm
function collectLoot() {
  const t = petRabbit && petRabbit.target;
  if (!t) return;

  // 🧰 Nhặt TRANG BỊ (equipment)
  if (petRabbit.targetIsEquip) {
    // API tự kiểm khoảng cách & nhặt vào Equip.inventory, bắn ticker, set inactive
    if (window.EquipmentDropAPI && typeof window.EquipmentDropAPI.updateEquipDrops === 'function') {
      window.EquipmentDropAPI.updateEquipDrops(Date.now(), petRabbit.x, petRabbit.y);
    }
    // Dọn trạng thái target
    petRabbit.target = null;
    petRabbit.targetIsEquip = false;
    return;
  }

  // 🎒 Nhặt ITEMS thường
  playSound('sfx-pickup', 0.5);
  switch (t.type) {
    case "lucky":        luckyBuffEndTime = Date.now() + 45000; queuePetLootPopup("🍀"); playSound('sfx-powerup', 0.8); break;
    case "power":        powerBuffEndTime = Date.now() + 45000; queuePetLootPopup("🍁"); playSound('sfx-powerup', 0.8); break;
    case "crazy":        crazyBuffEndTime = Date.now() + 45000; queuePetLootPopup("🍂"); playSound('sfx-powerup', 0.8); break;
    case "exp":          expBuffEndTime = Date.now() + 45000; queuePetLootPopup("🌿"); playSound('sfx-powerup', 0.8); break;
    case "magnet":       magnetBuffEndTime = Date.now() + 30000; queuePetLootPopup("🧲"); playSound('sfx-powerup', 0.8); break;
    case "crazymadnesstime":
                         crazyMadnessTimeEndTime = Date.now() + 30000; queuePetLootPopup("💢"); playSound('sfx-powerup', 0.8); break;
    case "critRateBuff": addCritRateBuff(0.15, 45000); queuePetLootPopup("✨"); playSound('sfx-powerup', 0.8); break;
    case "critDmgBuff":  addCritDmgBuff(0.25, 45000); queuePetLootPopup("💥"); playSound('sfx-powerup', 0.8); break;
    case "potion": {
      const baseHeal  = getRandomInt(10, 20);
      const bonusHeal = Math.round((player.level + wave) * 1.5);
      const totalHeal = baseHeal + bonusHeal;
      player.hearts   = Math.min(player.maxHearts, player.hearts + totalHeal);
      createHealImpactEffect(player, totalHeal);
      queuePetLootPopup("💊");
      playSound('sfx-powerup', 0.8);
      break;
    }
    case "secret":   activateSecretItem(t); queuePetLootPopup("❓"); playSound('sfx-powerup', 0.8); break;
    case "expBonus": activateExpBonusItem(); queuePetLootPopup("🌟"); playSound('sfx-powerup', 0.8); break;
    case "coin":     player.coins++; queuePetLootPopup("🪙"); playSound('sfx-pickup-coin', 0.5); break;
    case "energy":   player.energy++; queuePetLootPopup("⚡"); break;
    case "mana":     player.mana++; queuePetLootPopup("💠"); break;
    case "hp":       player.hearts = Math.min(player.maxHearts, player.hearts + 1); queuePetLootPopup("❤️"); break;
    case "box":      openItemBox(); break;
  }

  t.active = false;
  petRabbit.target = null;
  petRabbit.targetIsEquip = false;
}

function giveUp() {
  lastGiveUpId   = petRabbit.target.id;   // ghi nhớ id
  lastGiveUpTime = Date.now();
  petRabbit.target = null;
  showWarning("🐰 đừng đi xa, quay về!");
}
// Cập nhật kỹ năng đao xoay
function updateBlades() {
    if (!swordActive) return;

    const now = Date.now();
    const MAX_SEEK_RADIUS = 450;
    const BLADE_FLY_SPEED = 4;
    const BLADE_LAUNCH_INTERVAL = 100;

    if (now - lastBladeLaunchTime > BLADE_LAUNCH_INTERVAL) {
        const bladeToLaunch = swords[nextBladeToAttack];
        if (bladeToLaunch && bladeToLaunch.state === 'orbiting') {
            const target = zombies.find(z => z.active && distance(player, z) < MAX_SEEK_RADIUS);
            if (target) {
                bladeToLaunch.state = 'seeking';
                bladeToLaunch.hitZombies.clear();
                bladeToLaunch.pierceCount = 0;
            }
        }
        nextBladeToAttack = (nextBladeToAttack + 1) % swords.length;
        lastBladeLaunchTime = now;
    }

    const formationAngle = (now / 1500);
    swords.forEach(s => {
        switch (s.state) {
            case 'orbiting':
                s.angle = s.homeAngle + formationAngle;
                s.x = player.x + Math.cos(s.angle) * s.orbitRadius;
                s.y = player.y + Math.sin(s.angle) * s.orbitRadius;
                
// GIẢM TẢI: dùng khoảng cách bình phương + giới hạn số kiểm tra mỗi frame
{
  const HIT_R2 = 20 * 20;         // bán kính va chạm^2
  let checks = 0, MAX_CHECKS = 24; // tối đa 24 zombie/frame/đao

  for (let j = 0; j < zombies.length && checks < MAX_CHECKS; j++) {
    const z = zombies[j];
    if (!z || !z.active) continue;

    // Chỉ tính d2 (không sqrt)
    const dx = s.x - z.x, dy = s.y - z.y;
    if ((dx * dx + dy * dy) < HIT_R2 && (!z.bladeOrbitCooldown || now > z.bladeOrbitCooldown)) {
      const orbitingDamage = Math.max(1, Math.round(skillUpgrades.bladeDamage));
      dealDamageToZombie(z, orbitingDamage);
      z.bladeOrbitCooldown = now + 100;
    }
    checks++;
  }
}
                break;

            case 'seeking':
                let nearestTarget = null;
                let minDistance = Infinity;
                zombies.forEach(z => {
                    if (z.active && !s.hitZombies.has(z)) {
                        const d = distance(s, z);
                        if (d < minDistance) { minDistance = d; nearestTarget = z; }
                    }
                });
                if (nearestTarget) {
                    const angle = Math.atan2(nearestTarget.y - s.y, nearestTarget.x - s.x);
                    s.x += Math.cos(angle) * BLADE_FLY_SPEED;
                    s.y += Math.sin(angle) * BLADE_FLY_SPEED;
                }
                zombies.forEach(z => {
// Dùng khoảng cách bình phương để tránh sqrt
const dx = s.x - z.x, dy = s.y - z.y;
if (z.active && !s.hitZombies.has(z) && (dx*dx + dy*dy) < (20*20)) {
  const originalDamage = skillUpgrades.bladeDamage + playerUpgrades.damageBoost;
  let finalDamage;

  if (s.pierceCount === 0) {
    finalDamage = Math.max(1, Math.round(originalDamage));
                        }

                        dealDamageToZombie(z, finalDamage);
                        
                        s.hitZombies.add(z);
                        s.pierceCount++;
                        const impactExplosion = getExplosion(z.x, z.y);
                        impactExplosion.life = 10;
                        explosions.push(impactExplosion);
                    }
                });
                if (s.pierceCount >= 5 || distance(s, player) > MAX_SEEK_RADIUS || !nearestTarget) {
                    s.state = 'returning';
                }
                break;

            case 'returning':
                const angleToPlayer = Math.atan2(player.y - s.y, player.x - s.x);
                s.x += Math.cos(angleToPlayer) * 10;
                s.y += Math.sin(angleToPlayer) * 10;
                if (distance(s, player) < s.orbitRadius) {
                    s.state = 'orbiting';
                }
                break;
        }
    });
}

// Danh sách loại tài nguyên: tạo 1 lần, tái sử dụng
const SUPPLY_RESOURCE_TYPES = ["coin", "hp", "mana", "energy"];

/** Kích hoạt sự kiện: tạo 3–7 kiện 🪂 rơi từ trên xuống */
function triggerSupplyDrop() {
  playSound("sfx-nuke-fall", 0.4);
  showWarning("Hàng tiếp tế đang đến!");

  const dropCount = getRandomInt(3, 7);

  // Chốt snapshot camera/màn hình tại thời điểm spawn
  const camX = camera.x, camY = camera.y;
  const viewW = canvas.width, viewH = canvas.height;

  for (let i = 0; i < dropCount; i++) {
    supplyDrops.push({
      // id: performance.now() + i, // tuỳ chọn nếu bạn muốn debug
      x: camX + Math.random() * viewW,
      y: camY - 50,
      speedY: 1 + Math.random() * 0.5, // ~1..1.5 px/frame @60fps
      finalY: camY + viewH - (50 + Math.random() * 50), // “chạm đất” gần đáy màn hình
      active: true
    });
  }
}

/** Cập nhật rơi cho các kiện hàng (gọi trong update() mỗi frame) */
// Không dùng dt: tốc độ rơi tính theo "mỗi frame" (~60fps)
function updateSupplyDrops() {
  for (let i = supplyDrops.length - 1; i >= 0; i--) {
    const drop = supplyDrops[i];

    // Nếu có flag inactive thì xoá nhanh (swap-remove)
    if (!drop.active) {
      const last = supplyDrops.pop();
      if (i < supplyDrops.length) supplyDrops[i] = last;
      continue;
    }

    // Rơi mỗi frame (không scale theo thời gian)
    drop.y += drop.speedY; // speedY ~ 1..1.5 đã set lúc spawn

    // Chạm "đất" (finalY chốt tại thời điểm spawn)
    if (drop.y > drop.finalY) {
      playSound("sfx-supply-drop-item", 0.5);

      const resourceCount = getRandomInt(2, 10);
      for (let j = 0; j < resourceCount; j++) {
        const type = SUPPLY_RESOURCE_TYPES[(Math.random() * SUPPLY_RESOURCE_TYPES.length) | 0];
        const offsetX = (Math.random() - 0.5) * 60;
        const offsetY = (Math.random() - 0.5) * 60;
        items.push({
          x: drop.x + offsetX,
          y: drop.y + offsetY,
          type,
          active: true,
          bornAt: Date.now(),
        });
      }

      // Xoá phần tử đã hoàn tất (swap-remove)
      drop.active = false;
      const last = supplyDrops.pop();
      if (i < supplyDrops.length) supplyDrops[i] = last;
    }
  }
}

/** Vẽ kiện hàng – có culling để giảm overdraw */
function drawSupplyDrops() {
  ctx.font = "2rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  const left   = camera.x - 64;
  const right  = camera.x + canvas.width  + 64;
  const top    = camera.y - 64;
  const bottom = camera.y + canvas.height + 64;

  for (let i = 0; i < supplyDrops.length; i++) {
    const d = supplyDrops[i];
    if (d.x >= left && d.x <= right && d.y >= top && d.y <= bottom) {
      ctx.fillText("🪂", d.x, d.y);
    }
  }
}

//🔄 8. Cập nhật logic game (Main loop logic)

/* ---------- CÁC BIẾN CACHE UI NHẸ ---------- */
const __uiCache = {
  waveText: "",
  bladeText: "",
  swordText: "",
  fireText: "",
  iceText: "",
  petText: "",
  auraText: "",
};

/* ---------- TIỆN ÍCH NHANH, KHÔNG RÁC ---------- */
function removeAtSwap(arr, i) { const n = arr.length - 1; if (i < 0 || i > n) return; if (i !== n) arr[i] = arr[n]; arr.pop(); }
function clamp(v, a, b) { return v < a ? a : v > b ? b : v; }
function d2(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return dx*dx + dy*dy; }
function setTextOnce(el, txt, cacheKey) { if (!el) return; if (__uiCache[cacheKey] !== txt) { el.innerText = txt; __uiCache[cacheKey] = txt; } }
function nearestZombieInRange(srcx, srcy, maxR) {
  const maxR2 = maxR * maxR; let best = null, bestD2 = maxR2;
  for (let i = 0; i < zombies.length; i++) {
    const z = zombies[i]; if (!z.active) continue;
    const dz2 = d2(srcx, srcy, z.x, z.y);
    if (dz2 < bestD2) { bestD2 = dz2; best = z; }
  }
  return best;
}
/* Top-K nearby (K nhỏ, ví dụ số clone ≤ 5) — chèn tuyến tính, không sort toàn cục */
function kNearestZombiesByPlayer(k, maxR) {
  const K = Math.max(0, k|0); if (K === 0) return [];
  const maxR2 = maxR > 0 ? maxR*maxR : Infinity;
  const idx = new Array(K).fill(-1), dist = new Array(K).fill(Infinity);
  for (let i = 0; i < zombies.length; i++) {
    const z = zombies[i]; if (!z.active) continue;
    const dz2 = d2(player.x, player.y, z.x, z.y);
    if (dz2 >= maxR2) continue;
    // chèn vào mảng top-K (nhỏ), dịch trái
    let pos = K - 1; if (dz2 < dist[pos]) { dist[pos] = dz2; idx[pos] = i;
      while (pos > 0 && dist[pos] < dist[pos-1]) { // bubble trái
        const td = dist[pos-1]; dist[pos-1] = dist[pos]; dist[pos] = td;
        const ti = idx[pos-1]; idx[pos-1] = idx[pos]; idx[pos] = ti; pos--;
      }
    }
  }
  const out = [];
  for (let j = 0; j < K; j++) if (idx[j] !== -1) out.push(zombies[idx[j]]);
  return out;
}

/* ========== 1) BUFF CORE (power/crazy/lucky/exp/magnet) + halo xoay ========== */
function sysUpdateBuffCore(now) {
  buffEffects.power.active  = now < powerBuffEndTime;
  buffEffects.crazy.active  = now < crazyBuffEndTime;
  buffEffects.lucky.active  = now < luckyBuffEndTime;
  buffEffects.exp.active    = now < expBuffEndTime;
  buffEffects.magnet.active = now < magnetBuffEndTime;
  buffEffects.crazymadness.active = now < crazyMadnessTimeEndTime;
  _compactTimedBuffs(_critRateBuffs, now);
  _compactTimedBuffs(_critDmgBuffs, now);
  buffEffects.critRate.active = _critRateBuffs.length > 0;
  buffEffects.critDmg.active = _critDmgBuffs.length > 0;

  for (const k in buffEffects) { const b = buffEffects[k]; if (b && b.active) b.angle += 0.01; }
}

/* ========== 2) PLAYER LASERS (giảm life, remove O(1)) ========== */
function sysUpdatePlayerLasers() {
  for (let i = playerLasers.length - 1; i >= 0; i--) {
    const l = playerLasers[i]; l.life--; if (l.life <= 0) removeAtSwap(playerLasers, i);
  }
}

/* ========== 3) WAVE TIMER + BIG BOSS (UI + respawn) ========== */
function sysUpdateWaveAndBoss(now) {
  if (!lastWaveTime) return;
  const elWave = document.getElementById("waveTimerDisplay");
  const elapsed = (now - lastWaveTime) / 1000;
  let remaining = waveTime - elapsed; if (remaining < 0) remaining = 0;

  const min = (remaining / 60) | 0, sec = (remaining | 0) % 60, cs = Math.floor((remaining - (remaining | 0)) * 100);
  setTextOnce(elWave, `${min.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')}:${cs.toString().padStart(2,'0')}`, "waveText");

  if (remaining <= 0) {
    wave++; pendingWave = wave; if (typeof showUpgradePopup === "function") showUpgradePopup();
    globalThis.wave = wave;  // Đồng bộ wave ra global để mọi nơi (kể cả popup hover) đọc được ngay
    if (wave === 5) { bigBossRespawnTimer = 0; lastBigBossTimerUpdate = performance.now(); }
    lastWaveTime = now; if (typeof updateWaveUI === "function") updateWaveUI();
  }

  // BigBoss UI + respawn (đếm thực)
  let hasBoss = false;
  for (let i = 0; i < zombies.length; i++) { const z = zombies[i]; if (z.active && z.isBigBoss) { hasBoss = true; break; } }
  const box = document.getElementById("bigBossRespawnDisplay"); if (box) box.style.display = "block";
  if (wave < 5) { if (box) setTextOnce(box, "BigBoss: zZzz..", "bossText"); return; }

  if (!lastBigBossTimerUpdate) lastBigBossTimerUpdate = performance.now();
  if (!hasBoss) {
    const nowp = performance.now(); const dt = (nowp - lastBigBossTimerUpdate) / 1000;
    if (dt > 0) bigBossRespawnTimer += dt; lastBigBossTimerUpdate = nowp;
    const remain = Math.max(0, Math.ceil(bigBossRespawnInterval - bigBossRespawnTimer));
    if (box) setTextOnce(box, remain > 0 ? `BigBoss: -${remain.toString().padStart(3,'0')}s-` : "BigBoss: READY", "bossText");
    if (bigBossRespawnTimer >= bigBossRespawnInterval && typeof spawnBigBoss === "function") { spawnBigBoss(); bigBossRespawnTimer = 0; }
  } else {
    if (box) setTextOnce(box, "BigBoss: living", "bossText");
    bigBossRespawnTimer = 0; lastBigBossTimerUpdate = performance.now();
  }
}

/* ========== 4) SWORD (🔪) — vòng lưỡi đao auto 30s + updateBlades() ========== */
function skillUpdateBladesUIAndSpawn(now) {
  if (!swordActive) return;
  if (now >= swordEndTime) {
    swordActive = false; swords.length = 0;
    const btn = document.getElementById("bladeBtn");
    if (btn) { btn.classList.remove("active"); btn.innerText = "🔪 Đao"; }
    return;
  }
  // UI
  const remain = Math.ceil((swordEndTime - now) / 1000);
  const btn = document.getElementById("bladeBtn");
  if (btn) setTextOnce(btn, `🔪 ${remain}s`, "bladeText");

  // Spawn nếu chưa có
  if (swords.length === 0) {
    const count = skillUpgrades.bladeCount|0; nextFireIndex = 0;
    for (let i = 0; i < count; i++) {
      const s = getSword(); s.angle = (2*Math.PI / count) * i; s.radius = 60;
      s.state = 'charging'; s.chargeFrame = 90; s.fireDelay = 20 + i * 10; s.fireOrder = i;
      swords.push(s);
    }
  }
  // vòng điều khiển lưỡi đao gốc của bạn:
  if (typeof updateBlades === "function") updateBlades();
}

/* ========== 5) BLADE RAIN (⚔️) — mây thả kiếm có mục tiêu ========== */
function skillUpdateBladeRain(now) {
  if (!bladeActive) return;
  if (now >= bladeEndTime) {
    bladeActive = false; downwardSwords.length = 0; swordRainClouds.length = 0;
    const btn = document.getElementById("swordBtn"); if (btn) { btn.classList.remove("active"); btn.innerText = "⚔️ Kiếm"; }
    return;
  }
  // UI
  const btn = document.getElementById("swordBtn"); if (btn) setTextOnce(btn, `⚔️ ${Math.ceil((bladeEndTime - now)/1000)}s`, "swordText");

  // Mây trôi + thả kiếm (không forEach)
  const SWORD_DROP_INTERVAL = Math.max(100, 1200 - (skillUpgrades.swordLevel * 100));
  for (let i = 0; i < swordRainClouds.length; i++) {
    const c = swordRainClouds[i];
    // drift
    c.relativeX += c.driftSpeed;
    if (c.relativeX < 50 || c.relativeX > canvas.width - 50) c.driftSpeed *= -1;
    // drop
    if (now > c.nextDropTime) {
      downwardSwords.push({ x: camera.x + c.relativeX, y: camera.y + c.relativeY + 20, speed: 4 + skillUpgrades.swordLevel * 0.2, vx: (Math.random()-0.5)*2 });
      c.nextDropTime = now + SWORD_DROP_INTERVAL + Math.random()*200;
    }
  }
  // Kiếm rơi
  for (let i = downwardSwords.length - 1; i >= 0; i--) {
    const s = downwardSwords[i]; s.y += s.speed; s.x += s.vx;
    if (s.y > camera.y + canvas.height + 30) { removeAtSwap(downwardSwords, i); continue; }
    for (let j = 0; j < zombies.length; j++) {
      const z = zombies[j]; if (!z.active) continue;
      if (d2(s.x, s.y, z.x, z.y) < 400) { // 20^2
        if (!z.swordCooldown || now > z.swordCooldown) {
          dealDamageToZombie(z, skillUpgrades.swordDamage + playerUpgrades.damageBoost);
          z.swordCooldown = now + 100;
        }
      }
    }
  }
}

/* ========== 6) PLAYER MOVE + CAMERA + TOUCH ========== */
function sysUpdateMovementAndCamera() {
  let mx = 0, my = 0;
  if (keys.w) my -= 1; if (keys.s) my += 1; if (keys.a) mx -= 1; if (keys.d) mx += 1;
  if (mx !== 0 || my !== 0) {
    const len = Math.hypot(mx, my); mx /= len; my /= len;
    let v = player.speed;
    if (disguiseActive) v *= 1.5;
    if (supportAuraActive) v *= 1.2;
    player.x += mx * v; player.y += my * v;
    player.x = clamp(player.x, wallThickness + player.size, worldWidth - wallThickness - player.size);
    player.y = clamp(player.y, wallThickness + player.size, worldHeight - wallThickness - player.size);
    camera.x = clamp(player.x - canvas.width/2, 0, worldWidth - canvas.width);
    camera.y = clamp(player.y - canvas.height/2, 0, worldHeight - canvas.height);
  }
  // touch
  if (touchStartX !== null && touchMoveX !== null) {
    let dx = touchMoveX - touchStartX, dy = touchMoveY - touchStartY;
    const len = Math.hypot(dx, dy);
    if (len > 10) { dx /= len; dy /= len; player.x += dx * player.speed; player.y += dy * player.speed; }
  }
}

/* ========== 7) KỸ NĂNG LỬA/BĂNG — orbit + tia phụ (không filter/sort) ========== */
function skillUpdateFireIce(now) {
  // 🔥 Fire
  if (fireActive) {
    const fireBtn = document.getElementById("fireBtn");
    const rem = Math.ceil((fireEndTime - now)/1000);
    if (rem > 0) setTextOnce(fireBtn, `🔥 ${rem}s`, "fireText");
    else {
      fireActive = false; for (let i = 0; i < fireballs.length; i++) releaseFireball(fireballs[i]);
      fireballs.length = 0; if (fireBtn) { fireBtn.innerText = "🔥 Lửa"; fireBtn.classList.remove("active"); }
    }
  }
  for (let i = 0; i < fireballs.length; i++) {
    const f = fireballs[i]; f.angle += 0.05;
    f.x = player.x + Math.cos(f.angle) * f.radius; f.y = player.y + Math.sin(f.angle) * f.radius;
    if (!f.nextSparkTime) f.nextSparkTime = 0;
    if (now > f.nextSparkTime) {
      f.nextSparkTime = now + 1500;
      // nearest trong 200
      const t = nearestZombieInRange(f.x, f.y, 200);
      if (t) {
        const sparkDamage = Math.max(1, Math.round((skillUpgrades.fireDamage + playerUpgrades.damageBoost) * 0.5));
        particles.push({ type: 'fire_spark', x: f.x, y: f.y, target: t, speed: 2, damage: sparkDamage });
      }
    }
    // chạm trực tiếp
    for (let j = 0; j < zombies.length; j++) {
      const z = zombies[j]; if (!z.active) continue;
      if (d2(f.x, f.y, z.x, z.y) < 25*25) {
        if (!z.fireCooldown || now > z.fireCooldown) {
          dealDamageToZombie(z, skillUpgrades.fireDamage + playerUpgrades.damageBoost);
          z.fireCooldown = now + 100; z.onFireUntil = now + 400; z.burnEndTime = now + 3000;
          z.state = "wandering"; z.wanderTime = now + 3000 + Math.random()*2000; z.wanderAngle = Math.random()*Math.PI*2;
        }
      }
    }
  }

  // ❄️ Ice
  if (iceActive) {
    const iceBtn = document.getElementById("iceBtn");
    const rem = Math.ceil((iceEndTime - now)/1000);
    if (rem > 0) setTextOnce(iceBtn, `❄️ ${rem}s`, "iceText");
    else {
      iceActive = false; for (let i = 0; i < iceballs.length; i++) releaseIceball(iceballs[i]);
      iceballs.length = 0; if (iceBtn) { iceBtn.innerText = "❄️ Băng"; iceBtn.classList.remove("active"); }
    }
  }
  for (let i = 0; i < iceballs.length; i++) {
    const f = iceballs[i]; f.angle += 0.03;
    f.x = player.x + Math.cos(f.angle) * f.radius; f.y = player.y + Math.sin(f.angle) * f.radius;
    if (!f.nextShardTime) f.nextShardTime = 0;
    if (now > f.nextShardTime) {
      f.nextShardTime = now + 2000;
      const t = nearestZombieInRange(f.x, f.y, 250);
      if (t) {
        const shardDamage = Math.max(1, Math.round((skillUpgrades.iceDamage + playerUpgrades.damageBoost) * 0.5));
        particles.push({ type: 'ice_shard', x: f.x, y: f.y, target: t, speed: 2, damage: shardDamage });
      }
    }
    // chạm trực tiếp
    for (let j = 0; j < zombies.length; j++) {
      const z = zombies[j]; if (!z.active) continue;
      if (d2(f.x, f.y, z.x, z.y) < 25*25) {
        if (!z.iceCooldown || now > z.iceCooldown) {
          dealDamageToZombie(z, skillUpgrades.iceDamage + playerUpgrades.damageBoost);
          z.iceCooldown = now + 100; z.onIceUntil = now + 400; z.slowEndTime = now + 3000;
          z.state = "wandering"; z.wanderTime = now + 3000 + Math.random()*2000; z.wanderAngle = Math.random()*Math.PI*2;
        }
      }
    }
  }
}

/* ========== 8) PET UI NHẸ ========== */
function sysUpdatePetUI(now) {
  if (!petActive) return;
  const rem = Math.ceil((petEndTime - now)/1000), btn = document.getElementById("PetBtn");
  if (rem > 0) setTextOnce(btn, `🐰 ${rem}s`, "petText");
  else if (btn) { btn.innerText = "🐰 Pet"; btn.classList.remove("active"); }
}

/* ========== 9) BULLETS (player/clone/fairy/pet) & ENEMY BULLETS ========== */
function sysUpdateBullets() {
  for (let i = 0; i < bullets.length; i++) {
    const b = bullets[i]; if (!b.active) continue;
// Chỉ chặn khi zone đang ACTIVE
if (safeZones.some(zone => zone.active && distance(b, zone) < zone.radius)) {
  createShieldImpactEffect(b.x, b.y);
  releaseEnemyBullet(b);
  continue;
}
    // quỹ đạo
    if (b.curveMode) {
      b.curveRadius += 0.6; b.angle += b.curveSpeed * 0.5;
      b.x = player.x + Math.cos(b.angle) * b.curveRadius; b.y = player.y + Math.sin(b.angle) * b.curveRadius;
    } else if (b.zigzagMode) {
      b.travel += b.speed; const off = Math.sin(b.travel * b.oscillateSpeed + b.oscillatePhase) * b.oscillateAmplitude, ang = b.baseAngle;
      b.x = b.startX + Math.cos(ang)*b.travel - Math.sin(ang)*off; b.y = b.startY + Math.sin(ang)*b.travel + Math.cos(ang)*off;
    } else if (b.spiralForwardMode) {
      b.travel += b.speed; const ang = b.baseAngle;
      const cx = b.startX + Math.cos(ang)*b.travel, cy = b.startY + Math.sin(ang)*b.travel;
      const offAng = b.spiralPhase + b.travel*b.spiralSpeed;
      b.x = cx + Math.cos(offAng)*b.spiralRadius; b.y = cy + Math.sin(offAng)*b.spiralRadius;
    } else { b.x += b.dx * b.speed; b.y += b.dy * b.speed; }

    // va chạm zombies
for (let j = 0; j < zombies.length; j++) {
  const z = zombies[j]; if (!z.active) continue;
  if (d2(b.x, b.y, z.x, z.y) < 20*20) {

    const now = Date.now();

    // Cooldown CHUNG cho mọi loại đạn (giữ nguyên logic của bạn)
    if (z.bulletHitCooldown && now < z.bulletHitCooldown) continue;

    if (b.isFairyBullet) { // fairy
      if (b.effect === 'sleep') { z.isSleeping = true; z.sleepUntil = now + 3000; }
      else if (b.effect === 'wandering') { z.state = 'wandering'; z.wanderTime = now + 3000; }
      z.isWeakened = true; z.weakenEndTime = now + 5000; for (let k = 0; k < 4; k++) createFairyHitParticle(z);
      z.bulletHitCooldown = now + 100;
      releaseBullet(b); break;

    } else if (b.isPetBullet) { // pet
      // 🔽 áp CRIT vào sát thương pet
      const petDmg = calcCritDamage(b.customDmg, now);
      dealDamageToZombie(z, petDmg);
      z.stunnedByThunder = true; z.stunnedThunderUntil = now + b.stunDuration;
      z.bulletHitCooldown = now + 100;
      releaseBullet(b); break;

} else { // player/clone bình thường
  // ➕ thời gian an toàn: dùng _now nếu có, else Date.now()
  const now = (typeof _now === 'number') ? _now : Date.now();

  let dmg = (b.customDmg !== undefined) ? b.customDmg : (playerUpgrades.damageBoost || 1);

  if (b.isIceArrow) {
    if (!b.iceHits) b.iceHits = 0;
    const baseDmg = (b.iceHits === 0) ? dmg : Math.max(1, Math.round(dmg * 0.5));

    // 🔽 áp CRIT vào Ice Arrow
    const critDmg = calcCritDamage(baseDmg, now);

    // ➕ hiện “Crit!” nếu có chí mạng (không hồi máu)
    if (critDmg > baseDmg) {
      const r = z.radius || 15;
      healEffects.push({
      x: z.x + 28 + (Math.random() - 0.5) * 5, // Vị trí ngang ngẫu nhiên để tránh chồng lấn
      y: z.y - z.radius - 15, // Hiện ở vị trí cao hơn số sát thương một chút
        life: 90, maxLife: 90,
        text: 'Crit!', delay: 0,
        color: 'orange'
      });
    }

    dealDamageToZombie(z, critDmg);
    if (typeof window.applyOnHitFromEquips === 'function') window.applyOnHitFromEquips(z, now, b.x, b.y);

    b.iceHits++;
    z.bulletHitCooldown = now + 100; // cooldown chung
    // piercing: không release

  } else {
    // 🔽 áp CRIT vào đạn thường
    const critDmg = calcCritDamage(dmg, now);

    // ➕ hiện “Crit!” nếu có chí mạng (không hồi máu)
    if (critDmg > dmg) {
      const r = z.radius || 15;
      healEffects.push({
      x: z.x + 28 + (Math.random() - 0.5) * 5, // Vị trí ngang ngẫu nhiên để tránh chồng lấn
      y: z.y - z.radius - 15, // Hiện ở vị trí cao hơn số sát thương một chút
        life: 90, maxLife: 90,
        text: 'Crit!', delay: 0,
        color: 'orange'
      });
    }

    dealDamageToZombie(z, critDmg);
    if (typeof window.applyOnHitFromEquips === 'function') window.applyOnHitFromEquips(z, now, b.x, b.y);

    z.bulletHitCooldown = now + 100;

    if (!b.piercing) { releaseBullet(b); break; }
  }
}
}
}

const buffer = 50;
if (b.x < camera.x - buffer || 
    b.x > camera.x + canvas.width + buffer ||
    b.y < camera.y - buffer || 
    b.y > camera.y + canvas.height + buffer) {
  releaseBullet(b);
}
}
}
/* ====== CRIT SYSTEM (rate & dmg, có thời hạn) ====== */

// Giới hạn & mặc định buff crit rate, crit dmg
const CRIT_DMG_CAP = 9.00;   // Giới hạn tối đa +400%
const CRIT_RATE_CAP = 0.75;   // 75%
let   baseCritRate   = 0.00;  // 0% (có thể tăng khi lên cấp vĩnh viễn nếu muốn)
let   baseCritDmg    = 0.50;  // +50%  => tức là multiplier = 1 + 0.50 = 1.5x

// Buff tạm thời mua trong shop / nhận khi lên cấp
const _critRateBuffs = [];     // { value: 0.15, until: ms }
const _critDmgBuffs  = [];     // { value: 0.25, until: ms }

// Nén mảng tại chỗ (không tạo mảng mới)
function _compactTimedBuffs(arr, now) {
  let w = 0;
  for (let i = 0; i < arr.length; i++) {
    const it = arr[i];
    if (it && it.until > now) arr[w++] = it;
  }
  arr.length = w;
}

// API thêm buff (mua trong shop / nhận khi lên cấp)
function addCritRateBuff(inc, durationMs) {
  const now = Date.now();
  _critRateBuffs.push({ value: inc, until: now + durationMs });
}
function addCritDmgBuff(inc, durationMs) {
  const now = Date.now();
  _critDmgBuffs.push({ value: inc, until: now + durationMs });
}

// Lấy chỉ số hiện hành (gộp base + buff còn hạn)
function getCritRate(now) {
  let sum = baseCritRate;
  _compactTimedBuffs(_critRateBuffs, now);
  for (let i = 0; i < _critRateBuffs.length; i++) sum += _critRateBuffs[i].value;
  // Kẹp trần 70%
  return (sum > CRIT_RATE_CAP) ? CRIT_RATE_CAP : (sum < 0 ? 0 : sum);
}
function getCritDmg(now) {
  let sum = baseCritDmg;
  _compactTimedBuffs(_critDmgBuffs, now);
  for (let i = 0; i < _critDmgBuffs.length; i++) sum += _critDmgBuffs[i].value;
  return Math.max(0, Math.min(sum, CRIT_DMG_CAP));
}

// Tính damage đã áp CRIT. 
// Quy ước: Crit DMG = +X% => multiplier = 1 + X (vd 50% => 1.5x)
function calcCritDamage(base, now) {
  const rate = getCritRate(now);     // 0..0.7
  if (rate > 0 && Math.random() < rate) {
    const mult = 1 + getCritDmg(now);  // ví dụ 1 + 0.5 = 1.5x
    const v = Math.round(base * mult);
    return (v > 0 ? v : 1);
  }
  // không crit
  const b = base | 0;
  return (b > 0 ? b : 1);
}

function sysUpdateEnemyBullets(now) {
  for (let i = 0; i < enemyBullets.length; i++) {
    const b = enemyBullets[i]; if (!b.active) continue;
    b.x += b.dx * b.speed; b.y += b.dy * b.speed;
        // Kiểm tra va chạm với TẤT CẢ các mái vòm
        if (safeZones.some(zone => zone.active && distance(b, zone) < zone.radius)) {
            createShieldImpactEffect(b.x, b.y);
            releaseEnemyBullet(b);
            continue;
        }
    // trúng player
    if (d2(b.x, b.y, player.x, player.y) < 15*15) {
      if (player.shieldActive) {
        playSound('sfx-shield-block', 0.3);
        const ang = Math.atan2(b.y - player.y, b.x - player.x), R = 48;
        const ix = player.x + Math.cos(ang)*R, iy = player.y + Math.sin(ang)*R;
        createShieldImpactEffect(ix, iy);
        releaseEnemyBullet(b); continue;
      }
      if (player.hitTimer === 0 && !player.safeInvincible) {
  let damage = b.damage || 1; if (supportAuraActive) damage *= 0.5;
  // THÊM MỚI: Tính sát thương cuối cùng sau khi trừ giáp
  const finalDamage = Math.max(0, Math.round(damage) - (player.armor || 0));
  player.hearts -= finalDamage;
  player.hitTimer = 30;
  createDamageImpactEffect(player, finalDamage); // Hiển thị đúng sát thương đã giảm
        if (player.hearts <= 0) handlePlayerDeath();
      }
      b.hit = true;
    }
    const oob = b.x < -50 || b.x > worldWidth + 50 || b.y < -50 || b.y > worldHeight + 50;
    if (b.hit || oob) releaseEnemyBullet(b);
  }
}

/* ========== 10) ZOMBIES CORE: trạng thái, debuff, bắn trả, va chạm player ========== */
function sysUpdateZombies(now) {
    // KIỂM TRA NGƯỜI CHƠI CÓ Ở BẤT KỲ VÙNG AN TOÀN NÀO KHÔNG
    const isPlayerSafe = safeZones.some(zone => zone.active && distance(player, zone) < zone.radius);

    for (let i = 0; i < zombies.length; i++) {
        const z = zombies[i];
        if (!z.active) continue;

    // Nếu người chơi an toàn, zombie sẽ không đuổi theo nữa
    if (isPlayerSafe && !z.isBoss) {
        // Nếu zombie đang đuổi, chuyển nó sang trạng thái đi lang thang
        if (z.state === "chasing") {
            z.state = "wandering";
            z.wanderTime = now + 5000 + Math.random() * 5000; // Lang thang trong 5-10 giây
            z.wanderAngle = Math.random() * Math.PI * 2;
        }
    }

    // Đẩy zombie ra nếu nó vô tình đi vào mái vòm
        safeZones.forEach(zone => {
            if (zone.active && distance(z, zone) < zone.radius) {
                const angle = Math.atan2(z.y - zone.y, z.x - zone.x);
                z.x += Math.cos(angle) * 2;
                z.y += Math.sin(angle) * 2;
            }
        });
  }
  for (let i = 0; i < zombies.length; i++) {
    const z = zombies[i]; if (!z.active) continue;
    // TỐI ƯU: Nếu zombie ở quá xa người chơi, bỏ qua việc cập nhật logic cho nó
    const activationRange = canvas.width; // Khoảng cách zombie bắt đầu "thức dậy"
    if (distance(player, z) > activationRange) {
        continue; // Bỏ qua tất cả logic bên dưới cho con zombie này
    }
    // burn tick mỗi giây
    if (z.burnEndTime && now < z.burnEndTime) {
      if (!z.lastBurnTick || now - z.lastBurnTick > 1000) { z.lastBurnTick = now;
        const burnDmg = Math.max(1, Math.round((skillUpgrades.fireDamage + playerUpgrades.damageBoost) * 0.25));
        dealDamageToZombie(z, burnDmg);
      }
    } else if (z.burnEndTime) z.burnEndTime = null;

    // slow
    const slowed = z.slowEndTime && now < z.slowEndTime; if (z.slowEndTime && now >= z.slowEndTime) z.slowEndTime = null;

    // stun thunder
    if (z.stunnedByThunder && now < z.stunnedThunderUntil) continue; else if (z.stunnedByThunder && now >= z.stunnedThunderUntil) z.stunnedByThunder = false;
// Burn từ SPECIAL vũ khí
    if (z.weaponBurnUntil && now < z.weaponBurnUntil) {
      if (!z._wburnTick || now - z._wburnTick >= 1000) {
        z._wburnTick = now;
        const d = Math.max(1, Math.round((playerUpgrades.damageBoost || 1) * (z.weaponBurnDpsMul || 0.15)));
        dealDamageToZombie(z, d);
      }
    } else if (z.weaponBurnUntil && now >= z.weaponBurnUntil) {
      z.weaponBurnUntil = 0; z._wburnTick = 0;
    }
    // buff theo ngày/đêm
    if (isNight()) {
      if (!z.nightBuffApplied) { const bonus = (Math.random()*9|0) + 2; z.hp += bonus; z.baseHp += bonus; z.nightBuffApplied = true; }
    } else z.nightBuffApplied = false;

    if (currentDay > (z.lastDayBuffed || 0)) { const sb = Math.round(z.baseHp * 0.1); z.hp += sb; z.baseHp += sb; z.lastDayBuffed = currentDay; z.isBuffed = true; }

// regen/trừ máu 5s
if (!z.lastRegenTime || now - z.lastRegenTime > 5000) {
  if (isNight()) {
    // Khi regen, tăng cả máu hiện tại và máu tối đa
    z.hp += 1;
    z.baseHp += 1;
    z.lastRegenTime = now;
    // Thêm logic hồi phục 1% HP cho boss và big boss
    if (z.isBoss || z.isBigBoss) {
      const healAmount = Math.ceil(z.hp * 0.01);
      z.hp += healAmount;
      // Đảm bảo HP không vượt quá baseHp
      if (z.hp > z.baseHp) {
        z.hp = z.baseHp;
      }
    }
  } else if (wave > 3) {
    // Khi mất máu, chỉ trừ máu hiện tại
    z.hp -= 1;
    z.lastRegenTime = now;
    if (z.hp <= 0 && !z._killed) killZombie(z);
  }
}

// Hồi phục 1HP mỗi 2s nếu máu hiện tại nhỏ hơn máu tối đa
if (isNight() && (!z.lastHPRegenTime || now - z.lastHPRegenTime > 2000)) {
  if (z.hp < z.baseHp) {
    z.hp += 1;
  }
  z.lastHPRegenTime = now;
}
    // state
    if (z.state === "wandering") {
      if (now >= z.wanderTime) { z.state = "chasing"; z.speed = z.baseSpeed; z.nextStateCheck = now + 3000; }
      else if (z.wanderBehavior === "move") {
        let v = z.speed; 
        if (wave === 1 && !z.isBoss && !z.isBigBoss) v *= 0.5; // giảm 50% ở wave 1, 0.8 = giảm 20%
        if (slowed) v *= 0.5; z.x += Math.cos(z.wanderAngle) * v; z.y += Math.sin(z.wanderAngle) * v;
      }
    } else if (z.state === "chasing") {
      if (now >= (z.nextStateCheck || 0) && !z.isBoss) {
        z.behaviorCheckCounter = (z.behaviorCheckCounter || 0) + 1;
        if (z.behaviorCheckCounter >= 3) { z.showStatusIcon = Math.random() < 0.3; z.behaviorCheckCounter = 0; }
        if (Math.random() < 0.6) z.nextStateCheck = now + 3000;
        else {
          const pauseChance = isNight() ? 0.1 : 0.2;
          z.state = "wandering"; z.wanderTime = now + 1500 + Math.random()*8500; z.wanderAngle = Math.random()*Math.PI*2;
          z.speed = 0.15 + Math.random()*0.05; z.wanderBehavior = Math.random() < pauseChance ? "pause" : "move"; continue;
        }
      }
// ⬇️ MỚI: Boss/BigBoss né Safe Zone + đi vòng quanh biên
const playerInSafe = safeZones.some(zone => distance(player, zone) < zone.radius);
let orbited = false;

if ((z.isBoss || z.isBigBoss) && safeZones.length) {
    for (let k = 0; k < safeZones.length; k++) {
        const zone = safeZones[k];
        const dz = distance(z, zone);
        const margin = (z.radius || 18) + 12;

        // Nếu tiến sát mái vòm (hoặc player đang ở trong mái vòm) -> đi theo tiếp tuyến
        if (dz < zone.radius + margin || (playerInSafe && dz < zone.radius + 140)) {
            // Gán hướng quỹ đạo 1 lần cho ổn định
            if (z.orbitDir == null) z.orbitDir = (Math.random() < 0.5 ? 1 : -1);
            const toCenter = Math.atan2(zone.y - z.y, zone.x - z.x);
            const tangent = toCenter + z.orbitDir * Math.PI / 2;

            let v2 = z.speed;
            if (!isNight()) v2 *= 0.7;
            if (slowed) v2 *= 0.5;

            // Nếu lỡ chui vào trong, đẩy nhẹ ra biên
            if (dz < zone.radius + (z.radius || 18) - 4) {
                z.x -= Math.cos(toCenter) * 2;
                z.y -= Math.sin(toCenter) * 2;
            }

            z.x += Math.cos(tangent) * v2;
            z.y += Math.sin(tangent) * v2;
            orbited = true;
            break;
        }
    }
}

if (!orbited) {
    const ang = Math.atan2(player.y - z.y, player.x - z.x);
    let v = z.speed; 
    if (wave === 1 && !z.isBoss && !z.isBigBoss) v *= 0.5;// giảm 50% ở wave 1, 0.8 = giảm 20%
    if (!isNight()) v *= 0.7;
    if (slowed) v *= 0.5;
    z.x += Math.cos(ang) * v;
    z.y += Math.sin(ang) * v;
}
    }

    // bắn trả
    if (z.isBoss || z.type === "miniBoss") {
      if (!z.lastShoot) z.lastShoot = 0; if (now - z.lastShoot >= 8000) { z.lastShoot = now; shootEnemyBullet(z, 2, 0.8); }
    } else {
      if (!z.lastShoot) z.lastShoot = 0; if (now - z.lastShoot >= 60000) { z.lastShoot = now; shootEnemyBullet(z, 1 + Math.random()*0.5, 0.001); }
    }

    // va chạm player
    if (d2(z.x, z.y, player.x, player.y) < (z.radius + player.size) ** 2) {
      if (player.shieldActive) {
        const R = 48, repel = R + z.radius; const dist = Math.sqrt(d2(z.x, z.y, player.x, player.y));
        if (dist < repel) {
          const now2 = now; if (!window.lastShieldBlockSoundTime || now2 - lastShieldBlockSoundTime > 100) { playSound('sfx-shield-block', 0.3); window.lastShieldBlockSoundTime = now2; }
          const ang = Math.atan2(z.y - player.y, z.x - player.x), push = (repel - dist) + 20;
          z.x += Math.cos(ang)*push; z.y += Math.sin(ang)*push; continue;
        }
      }
      const dist = Math.sqrt(d2(z.x, z.y, player.x, player.y));
      if (dist < z.radius + player.size) {
        // KIỂM TRA BẤT TỬ CỦA PLAYER TẠI ĐÂY
      if (player.hitTimer === 0 && !player.safeInvincible && z.canHit) {
        let dmg = calculateZombieDamage(z); 
        if (supportAuraActive) dmg *= 0.5;

        // THÊM MỚI: Tính sát thương cuối cùng sau khi trừ giáp
        const finalDamage = Math.max(0, Math.round(dmg) - (player.armor || 0)); // Xử lý sát thương cuối cùng

        player.hearts -= finalDamage; 
        player.hitTimer = 30;
        createDamageImpactEffect(player, finalDamage); // Hiển thị đúng sát thương đã giảm
          z.canHit = false; 
          setTimeout(() => { z.canHit = true; }, 500);
          
          if (player.hearts <= 0) handlePlayerDeath();
        }
        
        // Logic đẩy lùi giữ nguyên
        const ang = Math.atan2(z.y - player.y, z.x - player.x), push = (z.radius + player.size - dist) + 1;
        z.x += Math.cos(ang)*push; z.y += Math.sin(ang)*push;
      }
    }

    // clamp map
    z.x = clamp(z.x, wallThickness + z.radius, worldWidth  - wallThickness - z.radius);
    z.y = clamp(z.y, wallThickness + z.radius, worldHeight - wallThickness - z.radius);
  }
}

/* ========== 11) ITEMS PICKUP + MAGNET + LEVEL-UP ========== */
function sysPickupItemsAndLevel(now) {
  // Magnet: hút item (trừ buff types)
  if (now < magnetBuffEndTime) {
    const R = 200, typesBlock = ['lucky','power','crazy','exp','magnet','secret', 'crazymadnesstime'];
    for (let i = 0; i < items.length; i++) {
      const it = items[i]; if (!it.active) continue;
      let skip = false; for (let k = 0; k < typesBlock.length; k++) if (it.type === typesBlock[k]) { skip = true; break; }
      if (skip) continue;
      if (d2(player.x, player.y, it.x, it.y) < R*R) {
        const ang = Math.atan2(player.y - it.y, player.x - it.x); it.x += Math.cos(ang)*5; it.y += Math.sin(ang)*5;
      }
    }
  }
  // Pickup
  for (let i = 0; i < items.length; i++) {
    const it = items[i]; if (!it.active) continue;
    if (d2(it.x, it.y, player.x, player.y) < 20*20) {
      playSound('sfx-pickup', 0.5);
      switch (it.type) {
        case 'lucky':  luckyBuffEndTime  = now + 45000; playSound('sfx-powerup',0.8); break;
        case 'power':  powerBuffEndTime  = now + 45000; playSound('sfx-powerup',0.8); break;
        case 'crazy':  crazyBuffEndTime  = now + 45000; playSound('sfx-powerup',0.8); break;
        case 'exp':    expBuffEndTime    = now + 45000; playSound('sfx-powerup',0.8); break;
        case 'magnet': magnetBuffEndTime = now + 30000; playSound('sfx-powerup',0.8); break;
        case 'crazymadnesstime': crazyMadnessTimeEndTime = now + 30000; playSound('sfx-powerup',0.8); break;
        case 'secret': activateSecretItem(it); playSound('sfx-powerup',0.8); break;
        case 'expBonus': activateExpBonusItem(); playSound('sfx-powerup',0.8); break;
        case 'coin':   player.coins += 1;  queuePlayerLootPopup("🪙"); playSound('sfx-pickup-coin', 0.5); break;
        case 'energy': player.energy += 1; queuePlayerLootPopup("⚡"); break;
        case 'mana':   player.mana += 1;   queuePlayerLootPopup("💠"); break;
        case 'hp': player.hearts = Math.min(player.maxHearts, player.hearts + 1); createHealImpactEffect(player, 1);
        queuePlayerLootPopup("❤️"); break;
        case 'potion': {
        const baseHeal = (Math.random()*11|0) + 10, bonus = Math.round((player.level + wave) * 1.5), total = baseHeal + bonus; player.hearts = Math.min(player.maxHearts, player.hearts + total); createHealImpactEffect(player, total);
        showWarning(`💊 +${total} HP`);} break;
        case 'critRateBuff': addCritRateBuff(0.15, 45000); showWarning("✨ Tăng tỉ lệ chí mạng!"); playSound('sfx-powerup', 0.8); break;
        case 'critDmgBuff': addCritDmgBuff(0.25, 45000); showWarning("💥 Tăng sát thương chí mạng!"); playSound('sfx-powerup', 0.8); break;
        case 'box': openItemBox(); break;
      }
      it.active = false;
    }
  }

  // Level up: while xử lý lên nhiều cấp
  while (player.currentLevelExp >= player.requiredExp) {
    const leftover = player.currentLevelExp - player.requiredExp;
    playSound('sfx-level-up'); player.level++;
    // Tăng chỉ số tối đa khi lên cấp
    player.maxHearts += 5;
    player.staminaMax += 1;
    player.stamina = player.staminaMax; // Hồi đầy stamina
    // ➕ MỖI CẤP +3 ĐIỂM
    player.statPoints = (player.statPoints || 0) + 3;
    window.CharacterPanel?.refresh();
    const healOnLevelUp = 1 + (UPGRADE_TIERS.hpBoost[playerUpgrades.hpBoost] || 0);
    player.hearts = Math.min(player.maxHearts, player.hearts + healOnLevelUp);
    player.energy += 10; player.mana += 10; playerUpgrades.damageBoost += 0.5; showWarning("+0.5 💥");

    const popup = document.getElementById("levelUpPopup");
    if (popup) { popup.style.animation = "none"; void popup.offsetWidth; popup.style.display = "block"; setTimeout(()=>{ popup.style.display="none"; }, 1200); }
    levelUpGlowTime = 60; if (typeof showSkillLevelUpPopup === "function") showSkillLevelUpPopup();
    if (player.level % 1 === 0 && typeof spawnBoss === "function") spawnBoss();

    player.currentLevelExp = leftover; player.requiredExp = calculateRequiredExp(player.level);
  }
}

/* ========== 12) EXPLOSIONS / EXPANDING / EXTRA SHOCKWAVES ========== */
function sysUpdateExplosionsAndShockwaves() {
  for (let i = 0; i < explosions.length; i++) {
    const e = explosions[i]; if (!e.active) continue;
    e.radius += 2; e.life--; if (e.life <= 0) releaseExplosion(e);
  }
  for (let i = expandingExplosions.length - 1; i >= 0; i--) {
    const exp = expandingExplosions[i]; const prevR = exp.radius;
    exp.radius += exp.maxRadius / exp.duration; exp.duration--;
    for (let j = 0; j < zombies.length; j++) {
      const z = zombies[j]; if (!z.active) continue;
      const dist = Math.sqrt(d2(exp.x, exp.y, z.x, z.y));
      if (dist >= prevR && dist < exp.radius && !exp.hitSet.has(z)) { dealDamageToZombie(z, exp.damage); exp.hitSet.add(z); }
    }
    if (exp.duration <= 0) removeAtSwap(expandingExplosions, i);
  }
  for (let i = extraShockwaves.length - 1; i >= 0; i--) {
    const sw = extraShockwaves[i]; sw.radius += 8; sw.alpha -= 0.012; if (sw.alpha <= 0) removeAtSwap(extraShockwaves, i);
  }
}

/* ========== 13) SATELLITES (laze xuyên — nearest ưu tiên) ========== */
function skillUpdateSatellites(now) {
  if (!satelliteActive) return;
  if (now >= satelliteEndTime) { satelliteActive = false; satellites.length = 0; return; }

  for (let i = 0; i < satellites.length; i++) {
    const sat = satellites[i];
    sat.angle += sat.orbitSpeed; sat.x = player.x + Math.cos(sat.angle)*sat.orbitRadius; sat.y = player.y + Math.sin(sat.angle)*sat.orbitRadius;
    if (!sat.laserCooldown) sat.laserCooldown = now;

    if (now >= sat.laserCooldown) {
      // nearest trong 500
      const t = nearestZombieInRange(sat.x, sat.y, 500);
      if (t) {
        playSound('sfx-laser', 0.5); sat.laserCooldown = now + 2000;
        sat.laserBeam = { angle: Math.atan2(t.y - sat.y, t.x - sat.x), life: 60, hitZombiesThisShot: new Set() };
      }
    }
    if (sat.laserBeam && sat.laserBeam.life > 0) {
      sat.laserBeam.life--;
      const x1 = sat.x, y1 = sat.y, ang = sat.laserBeam.angle, dx = Math.cos(ang), dy = Math.sin(ang);
      const sk = (function(){ for (let s=0; s<activeSkills.length; s++) { const a=activeSkills[s]; if (a && a.name==="Vệ tinh laze") return a; } return null; })();
      const baseDmg = (sk && sk.baseDamage) || 5;

      // Quét tất cả mục tiêu trên tia (không sort): tìm first (gần nhất) + gây dmg cho tất cả
      let first = null, firstD2 = Infinity;
      const hitList = [];
      for (let j = 0; j < zombies.length; j++) {
        const z = zombies[j]; if (!z.active) continue;
        const proj = (z.x - x1)*dx + (z.y - y1)*dy; if (proj <= 0 || proj >= 500) continue;
        const perp = Math.abs((z.x - x1)*dy - (z.y - y1)*dx); if (perp >= 20) continue;
        hitList.push(z);
        const dz2 = d2(sat.x, sat.y, z.x, z.y);
        if (dz2 < firstD2) { firstD2 = dz2; first = z; }
      }
      if (hitList.length) {
        for (let j = 0; j < hitList.length; j++) {
          const z = hitList[j]; if (sat.laserBeam.hitZombiesThisShot.has(z)) continue;
          const dmg = (z === first) ? baseDmg : Math.max(1, Math.round(baseDmg * 0.5));
          dealDamageToZombie(z, dmg); sat.laserBeam.hitZombiesThisShot.add(z);
        }
      }
      if (sat.laserBeam.life <= 0) sat.laserBeam = null;
    }
  }
}

/* ========== 14) LIGHTNING — mây vòng cung + strike ========== */
function skillUpdateLightning(now) {
  if (!lightningActive) return;
  const bobY = Math.sin(frame * 0.05) * 4;
  const n = lightningBolts.length, R = 80, spread = Math.PI * 0.7;

  for (let i = 0; i < n; i++) {
    const bolt = lightningBolts[i];
    let ang = -Math.PI/2; if (n > 1) { const start = -Math.PI/2 - spread/2, step = spread / (n-1); ang = start + i * step; }
    bolt.x = player.x + Math.cos(ang)*R; bolt.y = player.y + Math.sin(ang)*R + bobY;
    if (!bolt.nextZapTime) bolt.nextZapTime = 0;

    if (now > bolt.nextZapTime) {
      // nearest trong 240
      const t = nearestZombieInRange(bolt.x, bolt.y, 240);
      if (t) {
        dealDamageToZombie(t, bolt.damage / 2);
        activeLightningStrikes.push({ path: getZigZag(bolt, t, 4), life: 60, type: 'chain' });
        bolt.nextZapTime = now + 1000 + Math.random()*500;
      }
    }
  }

  // strike lớn: chọn 1 zombie nhìn thấy bằng reservoir sampling
  if (now > nextLightningStrikeTime) {
    let count = 0, target = null;
    for (let i = 0; i < zombies.length; i++) {
      const z = zombies[i]; if (!z.active) continue;
      if (z.x > camera.x && z.x < camera.x + canvas.width && z.y > camera.y && z.y < camera.y + canvas.height) {
        count++; if (Math.random() < (1 / count)) target = z; // reservoir
      }
    }
    if (target) {
      const start = { x: target.x, y: camera.y - 20 }, end = { x: target.x, y: target.y };
      activeLightningStrikes.push({ path: getZigZag(start, end, 8), life: 60 });
      if (lightningBolts.length) dealDamageToZombie(target, lightningBolts[0].damage);
      explosions.push(getExplosion(target.x, target.y));
    }
    const baseInterval = 800 / Math.max(1, lightningBolts.length); const rand = (Math.random()-0.5)*400;
    nextLightningStrikeTime = now + Math.max(100, baseInterval + rand);
  }
  // giảm life & dọn tia
  for (let i = activeLightningStrikes.length - 1; i >= 0; i--) { const s = activeLightningStrikes[i]; s.life--; if (s.life <= 0) removeAtSwap(activeLightningStrikes, i); }
}

/* ========== 15) CLONES — nhắm K mục tiêu gần PLAYER (không sort) ========== */
function skillUpdateClones(now) {
  if (!clonesActive) return;
  if (now >= clonesEndTime) { clonesActive = false; clones.length = 0; return; }

  // Chọn K mục tiêu gần người chơi
  const targets = kNearestZombiesByPlayer(clones.length, 600);

  for (let i = 0; i < clones.length; i++) {
    const c = clones[i]; const t = targets[i] || null;
    if (t) {
      const ang = Math.atan2(t.y - c.y, t.x - c.x), dist = Math.sqrt(d2(c.x, c.y, t.x, t.y));
      if (dist > 250) { c.x += Math.cos(ang)*c.moveSpeed; c.y += Math.sin(ang)*c.moveSpeed; }
      if (!c.lastShot) c.lastShot = 0; if (!c.shotCount) c.shotCount = 0;
      if (now - c.lastShot >= 500) { // Tốc độ bắn clone
        c.lastShot = now; c.shotCount++;
        if (c.shotCount >= 3) {
          c.shotCount = 0; playSound('sfx-laser', 0.5);
          activeCloneLasers.push({ cloneId: c.id, endX: t.x, endY: t.y, life: 60 });
          dealDamageToZombie(t, c.baseDamage * 3);
        } else {
          const b = getBullet(); b.x = c.x; b.y = c.y; b.dx = Math.cos(ang); b.dy = Math.sin(ang); b.speed = 3; b.active = true; b.customDmg = c.baseDamage; b.color = "#ff66ff";
          bullets.push(b);
        }
      }
    } else {
      const dist = Math.sqrt(d2(c.x, c.y, player.x, player.y));
      if (dist > 150) { const angBack = Math.atan2(player.y - c.y, player.x - c.x); c.x += Math.cos(angBack)*c.moveSpeed; c.y += Math.sin(angBack)*c.moveSpeed; }
    }
    c.x = clamp(c.x, wallThickness, worldWidth - wallThickness); c.y = clamp(c.y, wallThickness, worldHeight - wallThickness);
  }

  for (let i = activeCloneLasers.length - 1; i >= 0; i--) { const L = activeCloneLasers[i]; L.life--; if (L.life <= 0) removeAtSwap(activeCloneLasers, i); }
}

/* ========== 16) BLOOD ORB (🩸) ========== */
function skillUpdateBloodOrb(now) {
  if (!bloodOrbActive) return;
  if (now > bloodOrbEndTime) { bloodOrbActive = false; bloodOrbs.length = 0; return; }
  for (let i = 0; i < bloodOrbs.length; i++) {
    const o = bloodOrbs[i]; o.angle += 0.01; o.x = player.x + Math.cos(o.angle)*o.radius; o.y = player.y + Math.sin(o.angle)*o.radius;
    // nearest 300
    let best = null, bestD2 = 300*300;
    for (let j = 0; j < zombies.length; j++) { const z = zombies[j]; if (!z.active) continue; const dz2 = d2(o.x, o.y, z.x, z.y); if (dz2 < bestD2) { bestD2 = dz2; best = z; } }
    if (best !== o.target) { o.target = best; o.lockTime = now; }
    if (!o.target) continue;
    if ((now - (o.lockTime||0)) > 400 && (now - (window.bloodOrbLastDrain||0)) > 300) {
      window.bloodOrbLastDrain = now;
    let sk = null; for (let s=0; s<activeSkills.length; s++){const a=activeSkills[s]; if (a && a.name==="Quả cầu hấp huyết"){sk=a;break;}}
    dealDamageToZombie(o.target, (sk && sk.baseDamage) || 1);
    player.hearts = Math.min(player.maxHearts, player.hearts + 1);
    createHealImpactEffect(player, 1);
      for (let k = 0; k < 2; k++) createBloodOrbParticle(o);
      for (let k = 0; k < 2; k++) createBloodOrbParticleOnBeam(o);
    }
  }
}

/* ========== 17) THUNDER (🔵) ========== */
function skillUpdateThunder(now) {
  if (!thunderActive) return;
  const btn = document.getElementById("thunderBtn"); const rem = Math.ceil((thunderEndTime - now)/1000);
  if (rem > 0) { if (btn) btn.innerText = `🔵 ${rem}s`; } else { thunderActive = false; thunderBalls.length = 0; if (btn){ btn.innerText="🔵 Lôi"; btn.classList.remove("active"); } return; }

  for (let i = 0; i < thunderBalls.length; i++) {
    const ball = thunderBalls[i];
    ball.angle += 0.02; ball.x = player.x + Math.cos(ball.angle)*ball.radius; ball.y = player.y + Math.sin(ball.angle)*ball.radius;
    for (let j = 0; j < zombies.length; j++) {
      const z = zombies[j]; if (!z.active) continue;
      if (d2(ball.x, ball.y, z.x, z.y) < 40*40) {
        if (!z.thunderCooldown || now > z.thunderCooldown) {
          dealDamageToZombie(z, skillUpgrades.thunderDamage + playerUpgrades.damageBoost);
          z.stunnedByThunder = true; z.stunnedThunderUntil = now + 800; z.thunderCooldown = now + 100;
          const ang = Math.atan2(z.y - player.y, z.x - player.x), push = 16; z.x += Math.cos(ang)*push; z.y += Math.sin(ang)*push;
        }
      }
    }
    if (!ball.nextZapTime) ball.nextZapTime = 0;
    if (now > ball.nextZapTime) {
      const t = nearestZombieInRange(ball.x, ball.y, 250);
      if (t) {
        dealDamageToZombie(t, (skillUpgrades.thunderDamage + playerUpgrades.damageBoost) / 2);
        t.stunnedByThunder = true; t.stunnedThunderUntil = now + 800;
        activeLightningStrikes.push({ path: getZigZag(ball, t, 4), life: 30, type: 'chain' });
        ball.nextZapTime = now + 2000;
      }
    }
  }
  // dọn tia sét
  for (let i = activeLightningStrikes.length - 1; i >= 0; i--) { const s = activeLightningStrikes[i]; s.life--; if (s.life <= 0) removeAtSwap(activeLightningStrikes, i); }
}

/* ========== 18) SUPPORT AURA (✨ Heal) ========== */
function skillUpdateSupportAura(now) {
  const btn = document.getElementById("supportAuraBtn");
  if (supportAuraActive) {
    if (now > supportAuraEndTime) {
      supportAuraActive = false; auraCrackLines.length = 0; auraLightBeams.length = 0; if (btn) btn.classList.remove("active");
    } else {
      if (!window.lastAuraHealTime) window.lastAuraHealTime = 0;
    if (now - lastAuraHealTime > 1000) { // hồi máu mỗi giây
        lastAuraHealTime = now;
        const totalHeal = Math.min(1 + skillUpgrades.auraHealLevel, 5);
        player.hearts = Math.min(player.maxHearts, player.hearts + totalHeal); // <-- THAY ĐỔI
        createHealImpactEffect(player, totalHeal);
    }
      // hạt + cột sáng nhẹ, throttle theo frame
      if (frame % 15 === 0) {
        const ax = (player.x - 50) + Math.random()*100;
        particles.push({ x: ax, y: player.y + player.size - 5, type:'aura_particle', vx:(Math.random()-0.5)*0.1, vy:-0.5 - Math.random()*0.5, size:0.5+Math.random()*0.5, color:'rgba(255,215,0,0.8)', alpha:1, alphaDecay:0.005 });
      }
      if (frame % 20 === 0) { const bx = (player.x - 50) + Math.random()*100; auraLightBeams.push({ x: bx, width: 0.5 + Math.random(), alpha: 0, life: 60, initialLife: 60 }); }
      const rem = Math.ceil((supportAuraEndTime - now)/1000); if (btn) setTextOnce(btn, `✨ ${rem}s`, "auraText");
    }
  } else if (btn && btn.innerText !== "✨ Heal") btn.innerText = "✨ Heal";

  for (let i = auraLightBeams.length - 1; i >= 0; i--) {
    const b = auraLightBeams[i]; b.life--; b.alpha = Math.sin((1 - b.life / b.initialLife) * Math.PI); if (b.life <= 0) removeAtSwap(auraLightBeams, i);
  }
}

/* ========== 19) SPACE GATE (3-phase) — nếu đang dùng cổng kiểu khác, giữ nguyên ========== */
function sysUpdateSpaceGate(now) {
  // Nếu bạn đang dùng hệ thống cổng trong mã hiện tại (player.isTeleporting / isGrowingAfterTeleport / spaceGateActive)
  // thì khối dưới đây giữ nguyên hành vi đó, chỉ gom & comment lại để đọc dễ hơn, không cấp phát.
  if (player.isTeleporting) {
    player.size *= 0.92; if (spaceGate) spaceGate.radius *= 0.92;
    if (player.size < 1) {
      player.isTeleporting = false; player.isGrowingAfterTeleport = true;
      const t = findSafeTeleportLocation(); player.x = t.x; player.y = t.y; lastTeleportTime = now;
      camera.x = clamp(player.x - canvas.width/2, 0, worldWidth - canvas.width);
      camera.y = clamp(player.y - canvas.height/2, 0, worldHeight - canvas.height);
      if (now < spaceGateEndTime) createNewGate(player.x, player.y); else { spaceGateActive = false; spaceGate = null; }
    }
  } else if (player.isGrowingAfterTeleport) {
    player.size += (player.originalSize - player.size) * 0.1;
    if (player.originalSize - player.size < 0.1) {
      player.size = player.originalSize; player.isGrowingAfterTeleport = false;
      const ang = Math.random() * Math.PI * 2; player.x += Math.cos(ang)*40; player.y += Math.sin(ang)*40;
    }
  } else if (spaceGateActive && spaceGate) {
    if (now > spaceGateEndTime) { spaceGateActive = false; spaceGate = null; }
    else {
      if (spaceGate.alpha < 1) spaceGate.alpha += 0.05; spaceGate.rotation += 0.04;
      if (frame % 10 === 0) { // hạt cổng không gian
        createGateOrbitParticle(spaceGate);
        const PR = 80, KR = 25, PS = 1.8, PR2 = PR*PR, KR2 = KR*KR, BPS = PS*2.5;
        for (let i = 0; i < zombies.length; i++) { const z = zombies[i]; if (!z.active) continue;
          const dz2 = d2(spaceGate.x, spaceGate.y, z.x, z.y);
          if (dz2 < PR2) {
            const ang = Math.atan2(spaceGate.y - z.y, spaceGate.x - z.x); z.x += Math.cos(ang)*PS; z.y += Math.sin(ang)*PS;
            if (!z.gateDamageCooldown || now > z.gateDamageCooldown) { dealDamageToZombie(z, spaceGate.damage); z.gateDamageCooldown = now + 500; }
          }
          if (dz2 < KR2) { killZombie(z); explosions.push(getExplosion(z.x, z.y)); }
        }
        for (let i = 0; i < enemyBullets.length; i++) { const b = enemyBullets[i]; if (!b.active) continue;
          const db2 = d2(spaceGate.x, spaceGate.y, b.x, b.y);
          if (db2 < PR2) { const ang = Math.atan2(spaceGate.y - b.y, spaceGate.x - b.x); b.x += Math.cos(ang)*BPS; b.y += Math.sin(ang)*BPS; if (db2 < KR2) { releaseEnemyBullet(b); explosions.push(getExplosion(b.x, b.y)); } }
        }
      }
      const canUse = now > lastTeleportTime + GATE_COOLDOWN;
      if (canUse && d2(player.x, player.y, spaceGate.x, spaceGate.y) < spaceGate.radius * spaceGate.radius) { player.originalSize = player.size; player.isTeleporting = true; }
    }
  }
}

/* ========== 20) FAIRY (🦋) ========== */
function skillUpdateFairy(now) {
  if (!fairyActive) return;
  const btn = document.getElementById("fairyBtn");
  if (now > fairyEndTime) {
    fairyActive = false; fairies.length = 0; playerUpgrades.damageBoost -= fairyDamageBonus; fairyDamageBonus = 0;
    if (btn) { btn.classList.remove("active"); btn.innerText = "🦋 Fairy"; }
    return;
  }
  if (btn) { btn.classList.add("active"); btn.innerText = `🦋 ${Math.ceil((fairyEndTime - now)/1000)}s`; }

  // buff heal/damage theo ngày/đêm
  let healAmt = isNight() ? (2 + skillUpgrades.fairyHealLevel*2) : (1 + skillUpgrades.fairyHealLevel*1);
  let dmgAmt  = isNight() ? (1 + skillUpgrades.fairyDamageLevel*0.5) : (2 + skillUpgrades.fairyDamageLevel);
  healAmt = Math.min(healAmt, isNight() ? 10 : 5);

  playerUpgrades.damageBoost -= fairyDamageBonus;
  fairyDamageBonus = dmgAmt * skillUpgrades.fairyCount;
  playerUpgrades.damageBoost += fairyDamageBonus;

  if (!window.lastFairyHealTime) window.lastFairyHealTime = 0;
  if (now - lastFairyHealTime > 2000) {
      const totalHeal = healAmt * skillUpgrades.fairyCount;
      player.hearts = Math.min(player.maxHearts, player.hearts + totalHeal); // <-- THAY ĐỔI
      lastFairyHealTime = now;
      if (totalHeal > 0) createHealImpactEffect(player, totalHeal);
  }

  for (let i = 0; i < fairies.length; i++) {
    const f = fairies[i]; f.angle += 0.02; const bob = Math.sin(frame*0.05 + f.bobOffset)*5;
    f.x = player.x + Math.cos(f.angle)*f.orbitRadius; f.y = player.y + Math.sin(f.angle)*f.orbitRadius + bob;
    if (frame % 30 === 0) createFairyParticle(f.x, f.y); // hạt của kỹ năng fairy

    if (!f.nextAttackTime) f.nextAttackTime = 0;
    if (now > f.nextAttackTime) {
      f.nextAttackTime = now + 1000;
      let nearest = null, bestD2 = 600*600;
      for (let j = 0; j < zombies.length; j++) {
        const z = zombies[j]; if (!z.active || z.isSleeping) continue;
        const dz2 = d2(f.x, f.y, z.x, z.y); if (dz2 < bestD2) { bestD2 = dz2; nearest = z; }
      }
      if (nearest) {
        const b = getBullet(); const ang = Math.atan2(nearest.y - f.y, nearest.x - f.x);
        b.x = f.x; b.y = f.y; b.dx = Math.cos(ang); b.dy = Math.sin(ang); b.speed = 2; b.isFairyBullet = true; b.piercing = false; b.effect = isNight() ? 'sleep' : 'wandering';
        bullets.push(b);
      }
    }
  }
}

/* ========== 21) CẬP NHẬT BUFF CHIẾN ĐẤU (Cộng dồn hiệu ứng) ========== */
function sysUpdateCombatBuffs(now) {
// --- Xử lý buff 💢 CrazyMadnessTime (Power + Crazy gộp, speed chỉ +0.5) ---
const wasCrazyMadness = isCrazyMadnessTimeActive;
isCrazyMadnessTimeActive = now < crazyMadnessTimeEndTime;
if (isCrazyMadnessTimeActive && !wasCrazyMadness) {
  // 1) Lấy "base" chưa có cộng từ Power/Crazy (nếu đang bật 1 trong 2)
  const existingCrazyD = (isCrazyBuffActive && window.crazyBuffStats && typeof crazyBuffStats.damage === 'number')
    ? crazyBuffStats.damage : 0;
  const existingPowerD = (typeof window.powerBuffDamageBonus === 'number' && (now < (window.powerBuffEndTime || 0)))
    ? powerBuffDamageBonus : 0;

  const baseDmgBoost = Math.max(0, playerUpgrades.damageBoost - existingCrazyD - existingPowerD);

  // 2) Tính “tương đương Power + Crazy” dựa trên base + level-scaling 1 dòng như bạn quy ước
  const powerEq = (baseDmgBoost * 1.5) + 2 + Math.floor(player.level * 1.2); // Power
  const crazyEq = (baseDmgBoost * 0.5) + 1 + player.level;                   // Crazy (+1 mỗi cấp)
  const dmgAdd  = powerEq + crazyEq;

  // 3) Gói các stats của CMT (speed chỉ +0.5 để cộng dồn với Crazy thành +1)
  crazyMadnessTimeBuffStats = {
    speed: 0.5,               // KHÔNG x2 nữa; để Crazy (+0.5) => tổng +1 khi cùng hoạt động
    bulletSpeed: 1,           // như Crazy
    damage: dmgAdd,           // Power + Crazy (tính trên base)
    lineBulletCount: 1,       // như Crazy
    iceArrow: 10              // như Crazy
  };

  // 4) Áp dụng
  player.speed                     += crazyMadnessTimeBuffStats.speed;
  playerUpgrades.bulletSpeed       += crazyMadnessTimeBuffStats.bulletSpeed;
  playerUpgrades.damageBoost       += crazyMadnessTimeBuffStats.damage;
  playerUpgrades.lineBulletCount   += crazyMadnessTimeBuffStats.lineBulletCount;
  playerUpgrades.iceArrow          += crazyMadnessTimeBuffStats.iceArrow;

  updateStatsOverlay();
} else if (!isCrazyMadnessTimeActive && wasCrazyMadness) {
  // Hoàn trả an toàn (fallback nếu stats bị clear)
  const s = crazyMadnessTimeBuffStats || {speed:0, bulletSpeed:0, damage:0, lineBulletCount:0, iceArrow:0};

  player.speed                     -= s.speed;
  playerUpgrades.bulletSpeed       -= s.bulletSpeed;
  playerUpgrades.damageBoost       -= s.damage;
  playerUpgrades.lineBulletCount   -= s.lineBulletCount;
  playerUpgrades.iceArrow          -= s.iceArrow;

  // Clamp nhỏ đề phòng âm do nơi khác cùng chỉnh
  playerUpgrades.bulletSpeed       = Math.max(0, playerUpgrades.bulletSpeed);
  playerUpgrades.lineBulletCount   = Math.max(0, playerUpgrades.lineBulletCount);
  playerUpgrades.iceArrow          = Math.max(0, playerUpgrades.iceArrow);

  crazyMadnessTimeBuffStats = {};
  updateStatsOverlay();
}
    // --- Xử lý buff 🍁 Power (hoạt động độc lập) ---
    const wasPower = isPowerBuffActive;
    isPowerBuffActive = now < powerBuffEndTime;
    if (isPowerBuffActive && !wasPower) {
        powerBuffDamageBonus = (playerUpgrades.damageBoost * 1.5) + 2 + Math.floor(player.level * 1.2);
        // Tăng 150% sát thương hiện tại + 2 + 1.2 sát thương mỗi cấp
        playerUpgrades.damageBoost += powerBuffDamageBonus;
        updateStatsOverlay();
    } else if (!isPowerBuffActive && wasPower) {
        playerUpgrades.damageBoost -= powerBuffDamageBonus;
        powerBuffDamageBonus = 0;
        updateStatsOverlay();
    }

    // --- Xử lý buff 🍂 Crazy (hoạt động độc lập) ---
    const wasCrazy = isCrazyBuffActive;
    isCrazyBuffActive = now < crazyBuffEndTime;
    if (isCrazyBuffActive && !wasCrazy) {
        const crazyD = (playerUpgrades.damageBoost * 0.5) + 1 + player.level;
        // Tăng 50% sát thương hiện tại + 1 + 1 sát thương mỗi cấp
        crazyBuffStats = { speed: 0.5, bulletSpeed: 1, damage: crazyD, lineBulletCount: 1, iceArrow: 10 };
        player.speed += crazyBuffStats.speed;
        playerUpgrades.bulletSpeed += crazyBuffStats.bulletSpeed;
        playerUpgrades.damageBoost += crazyBuffStats.damage;
        playerUpgrades.lineBulletCount += crazyBuffStats.lineBulletCount;
        playerUpgrades.iceArrow += crazyBuffStats.iceArrow;
        updateStatsOverlay();
    } else if (!isCrazyBuffActive && wasCrazy) {
        player.speed -= crazyBuffStats.speed;
        playerUpgrades.bulletSpeed -= crazyBuffStats.bulletSpeed;
        playerUpgrades.damageBoost -= crazyBuffStats.damage;
        playerUpgrades.lineBulletCount -= crazyBuffStats.lineBulletCount;
        playerUpgrades.iceArrow -= crazyBuffStats.iceArrow;
        crazyBuffStats = {};
        updateStatsOverlay();
    }
}
// ===== [CẤU HÌNH] TTL cho item =====
const ITEM_TTL_MS = 15000; // 15 giây — xóa item

// (Tối ưu nhẹ) Không cần quét mỗi frame; 200–500ms/lần là đủ
let _nextItemTTLCheckAt = 0;

function pruneExpiredItems(now) {
  // Giảm tần suất quét để không tốn CPU khi FPS cao
  if (now < _nextItemTTLCheckAt) return;
  _nextItemTTLCheckAt = now + 300; // quét mỗi 300ms

  // Duyệt ngược để xóa an toàn
  for (let i = items.length - 1; i >= 0; i--) {
    const it = items[i];
    if (!it) continue;

    // Nếu chưa có bornAt (do các chỗ spawn chưa set), khởi tạo luôn ở lần gặp đầu
    if (it.bornAt == null) {
      it.bornAt = now;
      continue; // mới sinh (theo chuẩn), đợi lần quét sau
    }

    // Quá 30s thì xóa
    if ((now - it.bornAt) >= ITEM_TTL_MS) {
      // Cách 1: xóa nhanh, ít side-effect (swap-pop) nếu bạn có sẵn helper removeAtSwap()
      if (typeof removeAtSwap === 'function') {
        removeAtSwap(items, i);
      } else {
        // Cách 2: dùng splice cho đơn giản (đã duyệt ngược nên an toàn)
        items.splice(i, 1);
      }
    }
  }
}
// ===== SAFE UI LOCK - khóa thanh nút trên khi ở Safe Zone =====
(function () {
  let cached = false;
  let box = null;         // container thanh nút
  let btns = [];          // tất cả button nằm trong container

  function ensureCache() {
    if (cached) return;
    cached = true;

    // Container thanh nút: file của bạn là <div id="ui"> ... các button ...
    box = document.getElementById('ui');
    if (box) {
      btns = Array.from(box.querySelectorAll('button'));

      // Chặn click từ giai đoạn capture => mọi onclick/addeventlistener bên dưới đều bị chặn khi ở safe zone
      if (!box.__safeClickBlocker) {
        box.addEventListener('click', (e) => {
          if (window.isPlayerInSafeZone) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        }, true); // capture
        box.__safeClickBlocker = true;
      }
    } else {
      // Nếu DOM chưa có #ui, lần sau gọi sẽ thử lại
      cached = false;
    }
  }

  // Hàm public: đồng bộ UI theo trạng thái
  window.syncSafeZoneTopUI = function () {
    ensureCache();
    const inSafe = !!window.isPlayerInSafeZone;

    if (box) box.classList.toggle('safe-ui-disabled', inSafe);

    for (let i = 0; i < btns.length; i++) {
      const b = btns[i];
      b.classList.toggle('safe-ui-btn-disabled', inSafe);
      if (inSafe) {
        b.setAttribute('aria-disabled', 'true');
        b.tabIndex = -1;
      } else {
        b.removeAttribute('aria-disabled');
        b.tabIndex = 0;
      }
    }
  };
})();

/* ========== 22) MAIN UPDATE — PIPELINE RÕ RÀNG ========== */
function update() {
  updateSafeZoneStatus();
  // Vùng an toàn (safe zones)
  const isPlayerSafe = safeZones.some(zone => zone.active && distance(player, zone) < zone.radius);
  player.inSafeZone = isPlayerSafe;
  window.isPlayerInSafeZone = isPlayerSafe;
  // Chỉ sync khi đổi trạng thái để không tốn CPU mỗi frame
if (window._prevSafe !== isPlayerSafe) {
  window._prevSafe = isPlayerSafe;
  if (window.syncSafeZoneTopUI) window.syncSafeZoneTopUI(); // ✅ chỉ gọi khi đã có
}
// Hồi máu khi ở trong vùng an toàn
if (isPlayerSafe) {
    if (!player.lastSafeHeal || Date.now() - player.lastSafeHeal > 1000) { // mỗi giây hồi 10 máu
        // Lưu giá trị máu hiện tại trước khi hồi
        const currentHearts = player.hearts;
        // Hồi máu, đảm bảo không vượt quá máu tối đa
        player.hearts = Math.min(player.maxHearts, player.hearts + 10);
        player.stamina = Math.min(player.staminaMax, player.stamina + 10);
        // Chỉ tạo hiệu ứng nếu máu thực sự tăng
        if (player.hearts > currentHearts) {
            createHealImpactEffect(player, 10);
        }
        // Cập nhật thời gian hồi máu cuối cùng
        player.lastSafeHeal = Date.now();
    }
}
// Đặt bất tử khi ở trong Safe Zone
player.safeInvincible = !!isPlayerSafe;

  const now = Date.now();
  if (!gameStarted || gameOver || isPaused) return;

  updatePlayerRegen(now); // hồi máu
  updatePlayerStaminaRegen(now); // Hồi stamina
  updateSkillCooldowns();

  if (player.hitTimer > 0) player.hitTimer--;

  // dying → chỉ hạt
  if (player.isDying) { updateParticles(); return; }

  // 1) Buff lõi + Halo
  sysUpdateBuffCore(now);

  // 2) Player lasers
  if (!isPlayerSafe) sysUpdatePlayerLasers();

  // 3) Wave + BigBoss
  sysUpdateWaveAndBoss(now);

  // 4) Skill Đao vòng + Lưỡi kiếm mưa
  if (!isPlayerSafe) {
  skillUpdateBladesUIAndSpawn(now);
  skillUpdateBladeRain(now);
  }
  // 5) Movement + Camera + Touch
  sysUpdateMovementAndCamera();

  // 6) Auto shoot
  if (!window.isPlayerInSafeZone && autoShoot && player.level >= 1) autoShootBurst();

  // 7) Fire/Ice
  if (!isPlayerSafe) skillUpdateFireIce(now);

  // 8) Pet UI nhẹ
  sysUpdatePetUI(now);

  // 9) Bullets (player/clone/fairy/pet) & Enemy bullets
  if (!isPlayerSafe) sysUpdateBullets(); // vẫn để enemy bullets chạy phía dưới
  sysUpdateEnemyBullets(now);

  // 10) Zombies
  sysUpdateZombies(now);

  // 11) BigBoss lazer follow (nếu có)
  for (let i = 0; i < zombies.length; i++) { const z = zombies[i]; if (z.active) updateBigBossLazer(z, globalDeltaTime); }

  // 12a) TTL Items 30s — dọn item quá hạn TRƯỚC khi hút/nhặt để giảm chi phí
  pruneExpiredItems(now);

  // 12) Items + Magnet + Level up
  sysPickupItemsAndLevel(now);
window.EquipmentDropAPI?.updateEquipDrops?.(now, player.x, player.y);

  // 13) Explosions & Shockwaves
  sysUpdateExplosionsAndShockwaves();

  if (levelUpGlowTime > 0) levelUpGlowTime--;
  // 14..21) Toàn bộ skill tick => tắt khi trong safe zone
  // 14) Satellites
  if (!isPlayerSafe) {
  skillUpdateSatellites(now);

  // 15) Lightning
  skillUpdateLightning(now);

  // 16) Clones
  skillUpdateClones(now);

  // 17) Blood Orb
  skillUpdateBloodOrb(now);

  // 18) Thunder
  skillUpdateThunder(now);

  // 19) Support Aura
  skillUpdateSupportAura(now);

  // 20) Space Gate
  sysUpdateSpaceGate(now);

  // 21) Fairy
  skillUpdateFairy(now);
  }
  // 22) Power/Crazy áp chỉ số
  sysUpdateCombatBuffs(now);

  // 23) Particles/Pet/Missiles/Spatial/Black holes/Cleanup/UI/Music/Supply
  updateParticles();
  updatePet();
  updateMissiles();
  updateSpatialIndex();
  updateBlackHoles();
  cleanupInactiveObjects();
  updateUI();
  updateStatsOverlay();
  updateMusic();
  updateSupplyDrops();
}

// Cập nhật cooldown của kỹ năng
function updateSkillCooldowns() {
    const listItems = document.querySelectorAll('#skills-list .skill-item');
    const now = Date.now();

    // 🔒 Khóa/ mở khóa các nút kỹ năng theo safe zone
    const inSafe = (window.isPlayerInSafeZone === true) || safeZones.some(zone => zone.active && distance(player, zone) < zone.radius);
    listItems.forEach(it => {
        if (inSafe) it.classList.add('disabled');
        else it.classList.remove('disabled');
    });
    activeSkills.forEach((skill, index) => {
        const item = listItems[index];
        if (!item || !skill.endTime) return;

        if (now < skill.endTime) {
            const remain = Math.ceil((skill.endTime - now) / 1000);
            item.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${remain}s`;
            item.classList.add('active');
        } else {
            skill.endTime = null; // Reset khi hết giờ
            item.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${skill.manaCost}💠`;
            item.classList.remove('active');
        }
    });
}
// Lazer boss
function updateBigBossLazer(z, deltaTime) {
    if (!z.active || !z.isBigBoss) return;

    if (z.lazerDamageCooldown === undefined) z.lazerDamageCooldown = 0;
    if (z.isChargingLazer === undefined) z.isChargingLazer = false;

    const distanceToPlayer = distance(z, player);
    const ATTACK_RANGE = 600; // Tầm bắt đầu ngắm bắn
    const CHARGE_TIME = 2;    // Thời gian ngắm bắn

    const chargeSound = document.getElementById('sfx-lazer-charging');

    // ⛳ SAFE ZONE: dừng toàn bộ laser khi player ở trong
    const playerInSafe = safeZones.some(zone => distance(player, zone) < zone.radius);
    if (playerInSafe) {
        if (z.isChargingLazer && chargeSound) {
            chargeSound.pause();
            chargeSound.currentTime = 0;
        }
        z.isChargingLazer = false;
        z.isLazerAttacking = false;
        z.lazerTimer = 0;
        return; // Không bắn laser khi player ở trong mái vòm
    }

    // Nếu người chơi ở ngoài tầm và boss không đang bắn
    if (distanceToPlayer > ATTACK_RANGE && !z.isLazerAttacking) {
        // Nếu boss ĐANG gồng thì phải tắt âm thanh đi
        if (z.isChargingLazer && chargeSound) {
            chargeSound.pause();
            chargeSound.currentTime = 0;
        }
        z.isChargingLazer = false;
        z.lazerTimer = 0;
    } 
    // Nếu người chơi ở trong tầm và boss chưa làm gì cả
    else if (distanceToPlayer < ATTACK_RANGE && !z.isLazerAttacking && !z.isChargingLazer) {
        z.isChargingLazer = true; // Bắt đầu gồng
        z.lazerTimer = 0;
        
        // Bắt đầu phát âm thanh gồng
        if (chargeSound) {
            chargeSound.volume = 0.5; // 0.5 = 50% âm lượng
            chargeSound.play();
    }
  }
    // Nếu đang trong giai đoạn gồng laze
    if (z.isChargingLazer) {
        z.lazerTimer += deltaTime;
        // Nếu gồng đủ 2 giây thì bắn
        if (z.lazerTimer > CHARGE_TIME) {
            z.isChargingLazer = false;
            z.isLazerAttacking = true;
            
            // Dừng âm thanh gồng
            if (chargeSound) {
                chargeSound.pause();
                chargeSound.currentTime = 0;
            }
            // Phát âm thanh bắn
            playSound('sfx-bigboss-laser', 0.5);
            
            z.lazerDuration = 2;
            z.lazerTimer = 0;
            z.lazerAngle = Math.atan2(player.y - z.y, player.x - z.x);
        }
    }

    // Giai đoạn bắn tia lazer
    if (z.isLazerAttacking) {
        z.lazerDuration -= deltaTime;
        if (z.lazerDuration <= 0) {
            z.isLazerAttacking = false;
        }
        
        if (z.lazerAngle !== undefined) {
            const proj = (player.x - z.x) * Math.cos(z.lazerAngle) + (player.y - z.y) * Math.sin(z.lazerAngle);
            const perp = Math.abs((player.x - z.x) * Math.sin(z.lazerAngle) - (player.y - z.y) * Math.cos(z.lazerAngle));
            
            const lazerRange = 600;
            const lazerWidth = 18;
            const lazerCooldown = 60;

            if (proj > 0 && proj < lazerRange && perp < lazerWidth) {
                if (z.lazerDamageCooldown <= 0 && player.hearts > 0 && !player.safeInvincible) {
                    if (player.shieldActive) {
                      const now = Date.now();
                        // Dùng chung cooldown với va chạm zombie để tránh spam âm thanh
                        if (now - lastShieldBlockSoundTime > 100) {
                            playSound('sfx-shield-block', 0.3); // 30% âm lượng
                            lastShieldBlockSoundTime = now;
                        }
                        if (frame % 5 === 0) {
                            createParticleExplosion(player.x, player.y, 2, 'smoke');
                        }
                    } else {
                        let lazerDamage = calculateZombieDamage(z);
                        if (supportAuraActive) {
                            lazerDamage *= 0.5;
                        }
                        player.hearts -= lazerDamage;
                        z.lazerDamageCooldown = lazerCooldown;
                        createDamageImpactEffect(player, lazerDamage);
                        if (player.hearts <= 0) {
                            handlePlayerDeath(); 
                        }
                    }
                }
            }
          }
        
        if (z.lazerDamageCooldown > 0) z.lazerDamageCooldown--;
    }
}
// === 🌍 MINI MAP ===
// Toàn bản đồ rộng 3000 x 2000 (có thể điều chỉnh)
const worldWidth = 3000;
const worldHeight = 2000;
const wallThickness = 10; // Độ dày tường viền bản đồ
const miniMapCanvas = document.getElementById("miniMap");
const miniCtx = miniMapCanvas.getContext("2d");
let showMiniMap = true; //false để ẩn ban đầu
miniMapCanvas.style.display = showMiniMap ? "block" : "none";

// Bắt phím M để bật/tắt
document.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "m") {
    showMiniMap = !showMiniMap;
    miniMapCanvas.style.display = showMiniMap ? "block" : "none";
  }
  // ⌨️ Ẩn/hiện menu UI khi bấm phím t
  if (e.key.toLowerCase() === "t") {
    uiVisible = !uiVisible;
    const ui = document.getElementById("ui");
    ui.style.display = uiVisible ? "flex" : "none";
}
});
// ====== MINIMAP EQUIP VISITOR (no-alloc) ====================================
// Tái dùng mỗi frame, không tạo callback mới.
let __mmCtx = null, __mmSX = 1, __mmSY = 1;
function __visitDropForMiniMap(d) {
  if (!d || d.active === false) return;
  const mx = d.x * __mmSX, my = d.y * __mmSY;
  __mmCtx.fillStyle = d.color || '#00ffd5'; // màu theo rarity đã set trong equipment_drop.js
  __mmCtx.beginPath();
  __mmCtx.arc(mx, my, 1, 0, Math.PI * 1);
  __mmCtx.fill();
}
// Hàm vẽ mini map
function drawMiniMap() {
  if (!showMiniMap) return;

  miniCtx.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);

  const scaleX = miniMapCanvas.width / worldWidth;
  const scaleY = miniMapCanvas.height / worldHeight;
    // 🟦 Vẽ SAFE ZONES lên minimap (xanh dương)
  // Đặt ngay sau khi có scaleX/scaleY trong drawMiniMap()
  // Giữ nhẹ: chỉ ~5 vùng → không tốn CPU
  miniCtx.save();
  const rScale = Math.min(scaleX, scaleY); // giữ hình tròn ổn khi tỉ lệ khác nhau
    safeZones.forEach(zone => {
        if (zone.active) { // <-- Chỉ vẽ zone đang active
            const cx = zone.x * scaleX;
            const cy = zone.y * scaleY;
            const r  = zone.radius * rScale;

            const g = miniCtx.createRadialGradient(cx, cy, 0, cx, cy, r);
            g.addColorStop(0.00, "rgba(59,130,246,0.10)");
            g.addColorStop(0.85, "rgba(59,130,246,0.20)");
            g.addColorStop(1.00, "rgba(59,130,246,0.35)");
            miniCtx.fillStyle = g;
            miniCtx.beginPath();
            miniCtx.arc(cx, cy, r, 0, Math.PI * 2);
            miniCtx.fill();

            miniCtx.strokeStyle = "#3b82f6";
            miniCtx.lineWidth = 1;
            miniCtx.stroke();
        }
    });
    miniCtx.restore();
 // dễ chỉnh kích thước sau này
  const ITEM_SIZE   = 1.2;   // chiều rộng/ cao dấu vật phẩm (px trên minimap)
  const ZOMBIE_SIZE = 2;     // zombie thường (ô vuông)
  const DOT_PLAYER  = 3;     // bán kính chấm player & boss/mini
  // Vẽ các hòm tiếp tế (🪂) đang rơi
  supplyDrops.forEach(drop => {
      const mapX = drop.x * scaleX;
      const mapY = drop.y * scaleY;
      miniCtx.fillStyle = "cyan"; // Chấm màu xanh cyan cho dễ thấy
      miniCtx.beginPath();
      miniCtx.arc(mapX, mapY, 2, 0, Math.PI * 2); // Vẽ một chấm tròn
      miniCtx.fill();
  });

// Draw items (energy, mana, hp)
for (let it of items) {
  if (!it.active) continue;
  switch (it.type) {
    case "crazymadnesstime": miniCtx.fillStyle = "#3b82f6"; break; // Màu xanh dương cho CrazyMadnessTime
    case "energy": miniCtx.fillStyle = "yellow"; break; // Màu vàng cho năng lượng
    case "mana": miniCtx.fillStyle = "cyan"; break; // Màu xanh lam cho mana
    case "hp": miniCtx.fillStyle = "lime"; break; // Màu xanh lá cây cho HP
    case "box": miniCtx.fillStyle = "blue"; break; // Màu xanh dương cho hộp
    // Thêm các trường hợp mới cho các vật phẩm đặc biệt
    case "lucky": miniCtx.fillStyle = "#22c55e"; break; // Màu xanh lá cây cho Lucky
    case "power": miniCtx.fillStyle = "#ef4444"; break; // Màu đỏ cho Power
    case "crazy": miniCtx.fillStyle = "#f59e0b"; break; // Màu vàng cam cho Crazy
    case "exp": miniCtx.fillStyle = "#ffeb3b"; break; // Màu vàng cho Exp
    case "magnet": miniCtx.fillStyle = "#8b5cf6"; break; // Màu tím cho Magnet
    case "secret": miniCtx.fillStyle = "violet"; break; // Màu tím đậm cho Secret
    case "expBonus": miniCtx.fillStyle = "gold"; break; // Màu vàng kim cho ExpBonus
    case "potion": miniCtx.fillStyle = "red"; break; // Ví dụ: chấm màu đỏ

    default: miniCtx.fillStyle = "gray";
  }
  miniCtx.fillRect(it.x * scaleX - 0.5, it.y * scaleY - 0.5, 1, 1); // Vẽ kích thước vật phẩm trên minimap
}
// ⭐ Vẽ trang bị rơi (equipment) trên minimap
if (window.EquipmentDropAPI && typeof window.EquipmentDropAPI.forEachActiveDrop === 'function') {
  __mmCtx = miniCtx; __mmSX = scaleX; __mmSY = scaleY;
  window.EquipmentDropAPI.forEachActiveDrop(__visitDropForMiniMap);
}
// 💜 Vẽ clone trên minimap
clones.forEach(clone => {
  const mapX = (clone.x / worldWidth) * miniMapCanvas.width;
  const mapY = (clone.y / worldHeight) * miniMapCanvas.height;
  miniCtx.fillStyle = "#cc66ff";
  miniCtx.beginPath();
  miniCtx.arc(mapX, mapY, 2, 0, Math.PI * 2);
  miniCtx.fill();
});
// 🟦 Vẽ máy bay trên minimap
activePlanes.forEach(plane => {
  const mapX = (plane.x / worldWidth) * miniMapCanvas.width;
  const mapY = (plane.y / worldHeight) * miniMapCanvas.height;
  miniCtx.fillStyle = "#cc66ff";
  miniCtx.beginPath();
  miniCtx.arc(mapX, mapY, 2, 0, Math.PI * 2);
  miniCtx.fill();
});
  // Draw zombies
for (let z of zombies) {
  if (!z.active) continue;

  const mapX = (z.x / worldWidth) * miniMapCanvas.width;
  const mapY = (z.y / worldHeight) * miniMapCanvas.height;

  if (z.isBigBoss) {
    // BigBoss – to nhất, màu rõ ràng khác hẳn
    miniCtx.fillStyle = "purple";
    miniCtx.beginPath();
    miniCtx.arc(mapX, mapY, 3, 0, Math.PI * 2);
    miniCtx.fill();
  } 
  else if (z.isBoss) {
    // 🔴 Boss thường – màu đỏ hoặc cam, tuỳ bạn
    miniCtx.fillStyle = "orange";
    miniCtx.beginPath();
    miniCtx.arc(mapX, mapY, 2, 0, Math.PI * 2);
    miniCtx.fill();
  } 
  else if (z.type === "miniBoss") {
    // 🟠 MiniBoss – khác boss thường chút
    miniCtx.fillStyle = "gold";
    miniCtx.beginPath();
    miniCtx.arc(mapX, mapY, 1.5, 0, Math.PI * 2);
    miniCtx.fill();
  } 
  else {
    // 🔲 Zombie thường – vuông nhỏ
    miniCtx.fillStyle = "red";
    miniCtx.fillRect(mapX - 1, mapY - 1, 2, 2);
  }
}
  // Draw player
  miniCtx.fillStyle = "#00ccff";  // Xanh dương đồng bộ tên
  miniCtx.beginPath();
  miniCtx.arc(player.x * scaleX, player.y * scaleY, 2, 0, Math.PI * 2);
  miniCtx.fill();
  /* — chấm pet Thỏ màu hồng — */
if (petRabbit && petActive) {
  miniCtx.fillStyle = "#ff4dc4";          // hồng đậm
  miniCtx.beginPath();
  miniCtx.arc(petRabbit.x * scaleX, petRabbit.y * scaleY, 2, 0, Math.PI * 2);
  miniCtx.fill();
}
}
// 🎨 Vẽ đường chéo sọc (diagonal stripes) trên canvas
function drawDiagonalStripes(ctx, x, y, width, height, stripeColor = "#666", spacing = 10) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(x, y, width, height);
  ctx.clip();

  ctx.strokeStyle = stripeColor;
  ctx.lineWidth = 1; // Độ dày đường sọc

  const maxLength = width + height;
  for (let i = -height; i < maxLength; i += spacing) {
    ctx.beginPath();
    ctx.moveTo(x + i, y);
    ctx.lineTo(x + i - height, y + height);
    ctx.stroke();
  }

  ctx.restore();
}
function drawBloodOrb(ctx) {
    if (!bloodOrbActive) return;
    bloodOrbs.forEach(o => {
        ctx.save();
        ctx.translate(o.x, o.y);

        // Quả cầu tự xoay quanh chính nó
        ctx.rotate(frame / 100);

        // === Vẽ các gai dài ===
        ctx.shadowBlur = 6;         // Thêm blur cho các gai
        ctx.shadowColor = "red";
        for (let i = 0; i < 12; i++) {
            const angle = (Math.PI * 2 / 12) * i;
            const x = Math.cos(angle) * 24; // Gai dài hơn hẳn
            const y = Math.sin(angle) * 24;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(x, y);
            ctx.strokeStyle = "rgba(50, 0, 0, 0.7)";
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // === Vẽ vòng tròn ngoài tối, viền đỏ bóng ===
        ctx.beginPath();
        ctx.arc(0, 0, 16, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(60, 0, 0, 0.9)";
        ctx.strokeStyle = "rgba(255,0,0,0.7)";
        ctx.lineWidth = 2;
        ctx.fill();
        ctx.stroke();

        // === Vẽ vòng tròn trong đỏ nhạt, trong suốt hơn ===
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255, 80, 80, 0.05)"; // 📍 Đỏ rất nhạt, trong suốt
        ctx.fill();
        ctx.restore();

        // === Icon 🩸 chính giữa ===
        ctx.font = "1rem Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "white";
        ctx.fillText("🩸", o.x, o.y);

        // === Beam nhịp tim ===
        if (!o.target) return;
        const z = o.target;
        ctx.beginPath();
        ctx.moveTo(o.x, o.y);
        const segments = 16;
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const x = o.x + (z.x - o.x) * t;
            const y = o.y + (z.y - o.y) * t + Math.sin(t * 6 * Math.PI + frame / 8) * 5;
            ctx.lineTo(x, y);
        }
        ctx.strokeStyle = "rgba(255,0,0,0.6)";
        ctx.lineWidth = 2;
        ctx.shadowBlur = 4;
        ctx.shadowColor = "red";
        ctx.stroke();
        ctx.shadowBlur = 0;
    });
}
/**
 * Tạo hiệu ứng chữ "+EXP" bay lên khi nhận được kinh nghiệm.
 * @param {object} target - Đối tượng bị tiêu diệt (thường là zombie).
 * @param {number} amount - Lượng EXP nhận được.
 */
function createExpGainEffect(target, amount) {
    // Chỉ tạo hiệu ứng nếu nhận được EXP
    if (amount <= 0) return;

    // Tạo popup số EXP nhận được
    const radius = target.radius || target.size || 15;
    healEffects.push({
        x: target.x + 36 + (Math.random() - 0.5) * 10, // Lệch sang phải
        y: target.y - radius,
        life: 120,
        maxLife: 120,
        text: `+${amount} exp`,
        delay: 0,
        color: 'gold' // Màu vàng
    });
}
/**
 * Tạo hiệu ứng hồi máu.
 * @param {object} target - Đối tượng được hồi máu (player).
 * @param {number} amount - Lượng máu được hồi.
 */
function createHealImpactEffect(target, amount) {
    // Tạo popup số máu hồi màu xanh lá
    const radius = target.radius || target.size || 15;
    healEffects.push({
        x: target.x + (Math.random() - 0.5) * 10,
        y: target.y - radius * 2,
        life: 120,
        maxLife: 120,
        text: `+${amount}`,
        delay: 0,
        color: 'lime'
    });
}
/**
 * Tạo hiệu ứng khi một mục tiêu bị dính sát thương.
 * @param {object} target - Đối tượng bị dính sát thương (player hoặc zombie).
 * @param {number} amount - Lượng sát thương.
 */
function createDamageImpactEffect(target, amount) {
    // Nếu đối tượng chịu sát thương là người chơi, phát âm thanh "hurt"
    if (target === player && amount > 0) {
        playSound('sfx-player-hurt', 0.3); // Phát ở 30% âm lượng
    }
    let effectColor, particleColor;

    if (target === player) {
        // Nếu là người chơi, máu vẫn màu đỏ
        effectColor = '#ff4c4c';
        particleColor = 'rgba(255, 0, 0, 0.7)';
    } else {
        // Nếu là zombie, máu sẽ màu tím
        effectColor = 'violet';                      // Màu cho chữ -HP
        particleColor = 'rgba(190, 80, 220, 0.7)'; // Màu cho hạt "máu"
    }

    // Tạo popup số sát thương (dùng màu đã chọn)
    const radius = target.radius || target.size || 15;
    healEffects.push({
        x: target.x + (Math.random() - 0.5) * 10,
        y: target.y - radius * 2,
        life: 120,
        maxLife: 120,
        text: `-${amount}`,
        delay: 0,
        color: effectColor
    });

    // Tạo hiệu ứng vệt máu (dùng màu đã chọn)
    for (let i = 0; i < 2; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 1.5 + 0.5;
        particles.push({
            x: target.x, y: target.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 2 + 1,
            color: particleColor,
            alpha: 1,
            fastFade: 0.012
        });
    }
}
// hàm hiệu ứng chặn đạn
function createShieldImpactEffect(x, y) {
    // Tạo ra 5 tia lửa nhỏ bay ra ngẫu nhiên
    for (let i = 0; i < 3; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 1.5 + 0.5;
        particles.push({
            x: x, y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 2 + 1,
            color: `rgba(0, 255, 255, ${Math.random() * 0.5 + 0.5})`, // Màu xanh cyan
            alpha: 1,
            fastFade: true // Tan biến nhanh
        });
    }
}

function createBloodOrbParticleOnBeam(orb) {
    if (!orb.target) return;

    // Random vị trí dọc theo beam từ quả cầu tới zombie
    const t = Math.random(); // Từ 0 đến 1
    const x = orb.x + (orb.target.x - orb.x) * t;
    const y = orb.y + (orb.target.y - orb.y) * t;

    const dx = orb.x - x;
    const dy = orb.y - y;
    const speed = 0.5 + Math.random() * 0.5;

    particles.push({
        x: x,
        y: y,
        vx: dx * 0.02 * speed,
        vy: dy * 0.02 * speed,
        alpha: 1,
        size: 1 + Math.random() * 1,
        color: 'rgba(255, 0, 0, 0.6)',
        fastFade: true // Đánh dấu hạt tan nhanh
    });
}
// Vẽ Fairy và hiệu ứng hạt
function createFairyParticle(x, y) {
    particles.push({
        // Loại hạt này không cần type vì dùng logic mặc định
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        size: Math.random() * 0.5 + 0.5,
        color: 'rgba(0, 255, 255, 0.7)', // Màu xanh cyan phát sáng
        alpha: 1,
        fastFade: true // Mờ nhanh
    });
}
// Tạo 1 hạt nhỏ bay ngược vào quả cầu mỗi khi hút máu
function createBloodOrbParticle(orb) {
  createSuctionDust(orb.x, orb.y, 40, "rgba(255,0,0,0.6)", true);
}
/**
 * Sinh 1 hạt bụi bay vào (cx, cy)
 * @param {number} cx, cy   – toạ độ tâm cần hút
 * @param {number} spread   – khoảng đặt hạt (mặc định 250-300 px)
 * @param {string} color    – màu/độ mờ hạt
 * @param {boolean} fast    – tan nhanh (dùng cho tia máu)
 */
function createSuctionDust(cx, cy, spread = 250,
                           color = "rgba(200,200,200,0.5)",
                           fast = false) {
  const a      = Math.random() * Math.PI * 2;
  const r      = spread + Math.random() * 50;
  const px     = cx + Math.cos(a) * r;
  const py     = cy + Math.sin(a) * r;
  const speed  = 0.02;

  particles.push({
    x : px,          y : py,
    vx: (cx - px) * speed,
    vy: (cy - py) * speed,
    size  : 1 + Math.random() * 2,
    alpha : 1,
    color ,
    fastFade: fast // Nếu true, hạt sẽ tan biến nhanh
  });
}
// Hàm mới tạo hạt lốc xoáy cho cổng không gian
function createGateOrbitParticle(gate) {
    const angle = Math.random() * Math.PI * 2;
    // Bán kính quỹ đạo sẽ hơi lớn hơn bán kính của cổng một chút
    const orbitRadius = gate.radius * (1.1 + Math.random() * 0.2);

    particles.push({
        type: 'gate_orbit', // Loại hạt mới để xử lý riêng
        cx: gate.x,
        cy: gate.y,
        orbitRadius: orbitRadius,
        angle: angle,
        orbitSpeed: 0.01 + Math.random() * 0.015, // Tốc độ xoay ngẫu nhiên
        size: 1 + Math.random() * 1.5,
        alpha: 0.9,
        life: 60 + Math.floor(Math.random() * 30), // Tuổi thọ của hạt (frame)
        color: 'rgba(255, 220, 0, 0.8)' // Màu vàng
    });
}
// Hàm mới tạo hạt lốc xoáy cho hố đen
function createVortexParticle(cx, cy, spawnRadius) {
    const angle = Math.random() * Math.PI * 2;
    // Tạo hạt ở một khoảng ngẫu nhiên bên ngoài rìa
    const radius = spawnRadius * (0.8 + Math.random() * 0.4);

    particles.push({
        type: 'blackhole_vortex', // Đánh dấu đây là hạt lốc xoáy
        cx: cx,                   // Lưu tọa độ tâm để xoay quanh
        cy: cy,
        orbitRadius: radius,      // Khoảng cách ban đầu tới tâm
        angle: angle,             // Góc ban đầu
        pullSpeed: 0.5 + Math.random() * 0.5, // Tốc độ bị hút vào
        orbitSpeed: 0.02 + Math.random() * 0.001, // Tốc độ xoay
        size: 1.5 + Math.random() * 1.5,
        alpha: 0.8,
        color: 'rgba(10, 10, 20, 0.7)' // Màu tím đậm vũ trụ
    });
}
function triggerPlayerDyingEffect() {
  playSound('sfx-player-explode', 0.2); // Phát âm thanh nổ
    // Tạo một vụ nổ các hạt màu đỏ tại vị trí người chơi
    for (let i = 0; i < 150; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 6 + 2; // Tốc độ hạt ngẫu nhiên
        const color = `rgba(255, ${Math.random() * 100}, ${Math.random() * 50}, ${Math.random() * 0.5 + 0.5})`;

        particles.push({
            x: player.x,
            y: player.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 4 + 2,
            color: color,
            alpha: 1,
            fastFade: true 
        });
    }
}
function handlePlayerDeath() {
      // Kiểm tra xem kỹ năng Fairy có thể cứu mạng không
    if (fairyActive && fairyDeathDefyAvailable) {
        fairyDeathDefyAvailable = false; // Dùng hết 1 lần cứu mạng
        player.hearts = 1000; // Hồi lại 10 HP
        player.hitTimer = 180; // Bất tử 3 giây
        showWarning("🦋 Fairy đã cứu bạn!");
        
        return; 
    }

    if (player.isDying) return; // Ngăn việc gọi lại nhiều lần    
    // Dừng tất cả nhạc nền đang phát
    stopAllMusic();
    
    // Phát âm thanh thua cuộc
    playSound('sfx-game-over');
    player.isDying = true;
    triggerPlayerDyingEffect();

    // Sau 2 giây, hiện màn hình Game Over
    setTimeout(() => {
        gameOver = true;
        document.getElementById("gameOverPanel").classList.add("visible");
    }, 1500); // 1.5 giây để hiệu ứng kịp diễn ra
}
// Cập nhật trạng thái của tất cả các hạt hiệu ứng trong mỗi khung hình
function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];

// LOGIC CẢI TIẾN: Di chuyển và xử lý va chạm cho icon lửa/băng
        if (p.type === 'fire_spark' || p.type === 'ice_shard') {
            if (!p.target || !p.target.active) {
                particles.splice(i, 1);
                continue;
            }
            
            const angle = Math.atan2(p.target.y - p.y, p.target.x - p.x);
            p.rotation = angle;
            p.x += Math.cos(angle) * p.speed;
            p.y += Math.sin(angle) * p.speed;

            // Nếu icon đã bay tới gần mục tiêu
            if (distance(p, p.target) < p.speed) {
                // Gây sát thương và hiệu ứng TẠI ĐÂY
                if (p.target.active) {
                    dealDamageToZombie(p.target, p.damage);
                    if (p.type === 'fire_spark') {
                        p.target.burnEndTime = Date.now() + 3000;
                        // Thêm hiệu ứng hình ảnh bốc cháy
                        p.target.onFireUntil = Date.now() + 400;
                    } else { // 'ice_shard'
                        p.target.slowEndTime = Date.now() + 3000;
                        // Thêm hiệu ứng hình ảnh đóng băng
                        p.target.onIceUntil = Date.now() + 400;
                    }
                }
                particles.splice(i, 1); // Xóa icon sau khi đã trúng
            }
            continue;
        }
        // Các logic xử lý hạt
        if (p.type === 'blackhole_vortex') {
            p.orbitRadius -= p.pullSpeed;
            p.angle += p.orbitSpeed;
            p.x = p.cx + Math.cos(p.angle) * p.orbitRadius;
            p.y = p.cy + Math.sin(p.angle) * p.orbitRadius;
            p.alpha -= 0.015;
            if (p.orbitRadius <= 1 || p.alpha <= 0) {
                particles.splice(i, 1);
                continue;
            }
        } else if (p.type === 'fairy_status_effect') {
            if (p.target && p.target.active) {
                p.angle += 0.1;
                p.x = p.target.x + Math.cos(p.angle) * p.orbitRadius;
                p.y = p.target.y + Math.sin(p.angle) * p.orbitRadius;
                p.life--;
            } else {
                p.life -= 5;
            }
            p.alpha = p.life / p.maxLife;
            if (p.life <= 0) {
                particles.splice(i, 1);
                continue;
            }
        } else if (p.type === 'gate_orbit') {
            p.angle += p.orbitSpeed;
            p.x = p.cx + Math.cos(p.angle) * p.orbitRadius;
            p.y = p.cy + Math.sin(p.angle) * p.orbitRadius;
            p.life--;
            p.alpha = p.life / 90;
            if (p.life <= 0) {
                particles.splice(i, 1);
                continue;
            }
        } else if (p.type === 'aura_particle') {
            p.x += p.vx;
            p.y += p.vy;
            p.alpha -= p.alphaDecay;
        } else {
            if (p.maxDistance !== undefined) {
                const distSq = (p.x - p.originX) ** 2 + (p.y - p.originY) ** 2;
                if (distSq > p.maxDistance ** 2) {
                    p.alpha -= 0.1;
                }
            }
            p.x += p.vx;
            p.y += p.vy;
            if (typeof p.fastFade === 'number') {
                p.alpha -= p.fastFade;
            } else if (p.fastFade === true) {
                p.alpha -= 0.006;
            } else {
                p.alpha -= 0.0006;
            }
        }
        if (p.alpha <= 0) {
            if (particles[i] === p) {
                particles.splice(i, 1);
            }
        }
    }
}
// Vẽ tất cả các hạt hiệu ứng lên canvas
function drawParticles(ctx) {
    particles.forEach(p => {
        // LOGIC VẼ MỚI: Vẽ đốm lửa và mảnh băng tùy chỉnh
        if (p.type === 'fire_spark' || p.type === 'ice_shard') {
            ctx.save();
            // Di chuyển và xoay canvas đến vị trí và hướng của viên đạn
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation || 0);

            if (p.type === 'fire_spark') {
                // Vẽ đốm lửa: Gồm một "đuôi" màu cam và một "đầu" màu vàng sáng
                // Đuôi lửa (mờ hơn)
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = '#ff8c00'; // DarkOrange
                ctx.beginPath();
                ctx.arc(-3, 0, 5, 0, Math.PI * 2); // Vòng tròn lớn hơn ở phía sau
                ctx.fill();

                // Đầu lửa (sáng rõ)
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = '#ffd700'; // Gold
                ctx.beginPath();
                ctx.arc(2, 0, 4, 0, Math.PI * 2); // Vòng tròn nhỏ hơn ở phía trước
                ctx.fill();
            } else { // 'ice_shard'
                // Vẽ mảnh băng: một hình thoi dài, sắc nhọn
                ctx.fillStyle = '#afeeee'; // PaleTurquoise
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(8, 0);   // Mũi nhọn
                ctx.lineTo(-4, -4); // Cạnh trên
                ctx.lineTo(-8, 0);  // Đuôi
                ctx.lineTo(-4, 4);  // Cạnh dưới
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            ctx.restore();
            return; // Bỏ qua, không vẽ hạt tròn mặc định
        }

        // Logic vẽ các hạt mặc định (giữ nguyên)
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.color;
        ctx.shadowColor = 'purple';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    });
    // Reset độ trong suốt về mặc định
    ctx.globalAlpha = 1;
}
// === 🌗 NGÀY ĐÊM ===
function updateDayNight() {
    const now = Date.now();
    const deltaTime = (now - lastUpdateTime) / 1000;
    lastUpdateTime = now;

    dayTime += deltaTime / dayDuration;
    if (dayTime >= 1) {
        dayTime -= 1; // Reset về 0 liên tục
        currentDay++; // Tăng số ngày khi một ngày mới bắt đầu        
    }
    // Lưu lại để chỗ khác dùng
    globalDeltaTime = deltaTime;
}

function drawBackgroundByTime(ctx) {
    const w = canvas.width;
    const h = canvas.height;

    // 🕒 Tính giờ 0 - 23
    const hour = Math.floor(dayTime * 24) % 24;
    // --- BẮT ĐẦU LOGIC MỚI ---
// Nếu là 9h sáng và sự kiện chưa được kích hoạt trong ngày hôm nay
if (hour === 9 && !morningDropTriggered) {
    triggerSupplyDrop();
    morningDropTriggered = true; // Đánh dấu đã kích hoạt 9h
}
// Nếu là 12h trưa và sự kiện chưa được kích hoạt trong ngày hôm nay
else if (hour === 12 && !morningDropTriggered12h) {
    triggerSupplyDrop();
    morningDropTriggered12h = true; // Đánh dấu đã kích hoạt 12h
}
// Nếu là 15h chiều và sự kiện chưa được kích hoạt trong ngày hôm nay
else if (hour === 15 && !morningDropTriggered15h) {
    triggerSupplyDrop();
    morningDropTriggered15h = true; // Đánh dấu đã kích hoạt 15h
}
// Reset lại các cờ khi qua ngày mới (ví dụ: lúc 0h)
else if (hour === 0) {
    morningDropTriggered = false;
    morningDropTriggered12h = false;
    morningDropTriggered15h = false;
}
    // --- KẾT THÚC LOGIC MỚI ---

    // 🌗 Xác định độ tối / sáng theo thực tế
    let darkness = 0;

    if (hour >= 0 && hour < 4) {
        darkness = 0.6;
    } else if (hour >= 4 && hour < 6) {
        darkness = (6 - hour) / 2 * 0.6; // từ 0.6 -> 0
    } else if (hour >= 6 && hour < 11) {
        darkness = 0;
    } else if (hour >= 11 && hour < 13) {
        darkness = -0.1; // sáng hơn bình thường
    } else if (hour >= 13 && hour < 17) {
        darkness = 0;
    } else if (hour >= 17 && hour < 19) {
        darkness = (hour - 17) / 2 * 0.4; // từ 0 -> 0.4
    } else if (hour >= 19 && hour <= 23) {
        darkness = 0.6;
    }

    // 🌓 Phủ tối hoặc làm sáng hơn
    if (darkness > 0) {
        ctx.fillStyle = `rgba(0, 0, 0, ${darkness})`;
        ctx.fillRect(0, 0, w, h);
    } else if (darkness < 0) {
        ctx.fillStyle = `rgba(255, 255, 255, ${-darkness})`;
        ctx.fillRect(0, 0, w, h);
    }

    // ☀️ / 🌙 Vẽ biểu tượng báo ngày / đêm
    const iconX = 28;
    const iconY = 82; // Vị trí mặt trời

    if (hour >= 6 && hour < 18) {
        ctx.beginPath();
        ctx.arc(iconX, iconY, 14, 0, Math.PI * 2);
        ctx.fillStyle = '#FFD966';
        ctx.fill();
        ctx.strokeStyle = '#CC9900';
        ctx.stroke();
    } else {
        ctx.beginPath();
        ctx.arc(iconX, iconY, 12, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(200, 200, 255, 0.8)`;
        ctx.fill();
        ctx.beginPath();
        ctx.arc(iconX - 4, iconY - 2, 10, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(0,0,0,0.6)`;
        ctx.fill();
    }

    // 🕒 Số giờ 0-23
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(`${hour}`, iconX + 20, iconY);
}
const balloonColors = ['#f87171', '#fbbf24', '#34d399', '#60a5fa', '#c084fc'];
function randomizeBackground() {
    backgroundStars = [];
    backgroundBirds = [];
    backgroundTrees = [];
    backgroundClouds = [];
    backgroundPlanes = [];
    backgroundMushrooms = [];
    backgroundRocks = [];
    backgroundBalloons = [];
    backgroundSeeds = [];
    backgroundBigStars = [];

const bigStarCount = isNight() ? 10 : 3;
for (let i = 0; i < bigStarCount; i++) {
    backgroundBigStars.push([
        Math.random() * worldWidth,
        Math.random() * (worldHeight / 2)
    ]);
}
    // ⭐ Ngôi sao nhỏ, trải dài nửa trên map
const starCount = isNight() ? 300 : 50; // Ban đêm nhiều hơn, ban ngày ít hơn
for (let i = 0; i < starCount; i++) {
    backgroundStars.push([
        Math.random() * worldWidth,
        Math.random() * (worldHeight / 2)
    ]);
}
    // 🕊️ Chim, bay ở cao trung bình
    for (let i = 0; i < 15; i++) {
        backgroundBirds.push([
            Math.random() * worldWidth,
            50 + Math.random() * 100
        ]);
    }

    // 🌳 Cây phía xa dưới mặt đất
    for (let i = 0; i < 50; i++) {
        backgroundTrees.push([
            Math.random() * worldWidth,
            worldHeight - 150 + Math.random() * 20
        ]);
    }

    // ☁️ Mây đơn giản phía trên cây
for (let i = 0; i < 5; i++) {
    backgroundClouds.push({
        x: Math.random() * worldWidth,
        y: worldHeight - 250 - Math.random() * 200,
        size: 0.5 + Math.random() * 1.5,
        speed: 0.05 + Math.random() * 0.1,
        isDark: Math.random() < 0.2 // 20% là mây xám
    });
}
    // ✈️ 🛩️Máy bay đơn giản phía trên mây
const planeIcons = ['✈️', '🛩️', '🚀'];
// Nhóm 1: Dọc rìa trái world map
for (let i = 0; i < 1; i++) {
    backgroundPlanes.push({
        x: -200 - Math.random() * 200,  // rìa trái ngoài map
        y: worldHeight / 2 + Math.random() * (worldHeight / 2), // giữa xuống dưới
        vx: 0.5 + Math.random() * 0.3,
        vy: -0.3 - Math.random() * 0.2,
        size: 0.8 + Math.random() * 1.5,
        opacity: 0.4 + Math.random() * 0.5,
        icon: planeIcons[Math.floor(Math.random() * planeIcons.length)]
    });
}
// Nhóm 2: Trải dài phía dưới toàn bản đồ
for (let i = 0; i < 2; i++) {
    backgroundPlanes.push({
        x: Math.random() * worldWidth,
        y: worldHeight - 100 - Math.random() * 100,
        vx: 0.5 + Math.random() * 0.3,
        vy: -0.3 - Math.random() * 0.2,
        size: 0.8 + Math.random() * 1.5,
        opacity: 0.4 + Math.random() * 0.5,
        icon: planeIcons[Math.floor(Math.random() * planeIcons.length)]
    });
}
    // 🍄 Nấm dưới đất
    for (let i = 0; i < 30; i++) {
        backgroundMushrooms.push([
            Math.random() * worldWidth,
            worldHeight - 70 + Math.random() * 10
        ]);
    }

    // 🪨 Đá nhỏ dưới đất
    for (let i = 0; i < 30; i++) {
        backgroundRocks.push([
            Math.random() * worldWidth,
            worldHeight - 70 + Math.random() * 10
        ]);
    }

    // 🎈 Bóng bay màu ngẫu nhiên giữa map
for (let i = 0; i < 5; i++) {
    backgroundBalloons.push({
        x: Math.random() * worldWidth,
        y: worldHeight - 300 - Math.random() * 100,
        vx: -0.05 + Math.random() * 0.1, // bay nhẹ trái/phải
        speed: 0.15 + Math.random() * 0.1, // bay lên chậm
        color: balloonColors[Math.floor(Math.random() * balloonColors.length)]
    });
}
    // 🌼 Hoa bồ công anh xuất hiện thấp, bay lên cao
for (let i = 0; i < 15; i++) {
    backgroundSeeds.push({
        x: Math.random() * worldWidth,
        y: worldHeight - 300 - Math.random() * 100,
        vx: -0.1 + Math.random() * 0.2, // ngẫu nhiên từ -0.1 (trái) -> +0.1 (phải)
        speed: 0.02 + Math.random() * 0.05
    });
}
}
function drawCuteCloud(ctx, x, y, scale = 1, isDark = false) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    const gradient = ctx.createLinearGradient(0, -20, 0, 20);
    if (isDark) {
        gradient.addColorStop(0, 'rgba(150, 150, 150, 0.5)');
        gradient.addColorStop(1, 'rgba(100, 100, 100, 0.4)');
    } else {
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
        gradient.addColorStop(1, 'rgba(230, 230, 230, 0.7)');
    }
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(-30, 0, 20, Math.PI * 0.5, Math.PI * 1.5);
    ctx.arc(0, -20, 35, Math.PI, 0);
    ctx.arc(30, 0, 20, Math.PI * 1.5, Math.PI * 0.5);
    ctx.closePath();
    ctx.shadowColor = 'rgba(0,0,0,0.1)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetY = 4;
    ctx.fill();
    ctx.restore();
}
if (prevIsNight !== isNight()) {
    randomizeBackground();
    prevIsNight = isNight();
}

function isNight() {
    const hour = Math.floor(dayTime * 24) % 24;
    return hour >= 19 || hour < 6;
}
// Hình nền
function drawBackground() {
    // ===== BẦU TRỜI =====
    const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    skyGradient.addColorStop(0, '#0f172a');
    skyGradient.addColorStop(0.6, '#1e3a8a');
    skyGradient.addColorStop(1, '#60a5fa');
    ctx.fillStyle = skyGradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

// ===== SAO NHỎ =====
backgroundStars.forEach(([x, y], index) => {
    const flicker = (Math.sin(performance.now() / 1000 + index) + 1) / 2; // 0 ~ 1 chậm, nhấp nháy nhẹ
    const alpha = isNight() ? 0.5 + flicker * 0.5 : 0.1; // Đêm sáng 0.5-1, ngày mờ nhẹ
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.fillRect(x - camera.x, y - camera.y, 1, 1);
});

// ===== SAO LỚN =====
backgroundBigStars.forEach(([x, y], index) => {
    const flicker = (Math.sin(performance.now() / 1500 + index) + 1) / 2; // chậm hơn sao nhỏ
    const alpha = isNight() ? 0.7 + flicker * 0.3 : 0.1;
    ctx.fillStyle = `rgba(255, 214, 64, ${alpha})`; // Màu vàng nhạt giống sao thật

    ctx.fillRect(x - 2 - camera.x, y - camera.y, 4, 1);
    ctx.fillRect(x - camera.x, y - 2 - camera.y, 1, 4);
});

    // ===== CHIM =====
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.beginPath();
    backgroundBirds.forEach(([x, y]) => {
        ctx.moveTo(x - camera.x, y - camera.y);
        ctx.lineTo(x + 4 - camera.x, y - 3 - camera.y);
        ctx.lineTo(x + 8 - camera.x, y - camera.y);
    });
    ctx.stroke();

    // ===== CÂY XA =====
    ctx.fillStyle = '#14532d';
    backgroundTrees.forEach(([x, y]) => {
        ctx.fillRect(x - camera.x, y - camera.y, 4, 40);
        ctx.beginPath();
        ctx.arc(x + 2 - camera.x, y - 10 - camera.y, 10, 0, Math.PI * 2);
        ctx.fill();
    });

    // ===== CÂY LỚN =====
    ctx.fillStyle = '#14532d';
    ctx.fillRect(120 - camera.x, worldHeight - 180 - camera.y, 10, 100);
    ctx.beginPath();
    ctx.arc(125 - camera.x, worldHeight - 180 - camera.y, 30, 0, Math.PI * 2);
    ctx.fill();
    for (let i = 0; i < 3; i++) {
        let x = 160 + i * 20;
        ctx.fillRect(x - camera.x, worldHeight - 130 - camera.y, 5, 50);
        ctx.beginPath();
        ctx.arc(x + 2.5 - camera.x, worldHeight - 130 - camera.y, 10, 0, Math.PI * 2);
        ctx.fill();
    }

    // ===== MÂY CUTE =====
backgroundClouds.forEach((cloud) => {
    cloud.x += cloud.speed;
    if (cloud.x - camera.x > canvas.width + 150) {
        cloud.x = camera.x - 200;
    }
    drawCuteCloud(ctx, cloud.x - camera.x, cloud.y - camera.y, cloud.size, cloud.isDark);
});
    // ===== MÁY BAY =====
backgroundPlanes.forEach(plane => {
    plane.x += plane.vx;
    plane.y += plane.vy;

    if (plane.x > worldWidth + 300 || plane.y < camera.y - 300) {
        if (Math.random() < 0.5) {
            // Reset kiểu dọc rìa trái
            plane.x = -200 - Math.random() * 200;
            plane.y = worldHeight / 2 + Math.random() * (worldHeight / 2);
        } else {
            // Reset kiểu dưới map trải ngang
            plane.x = Math.random() * worldWidth;
            plane.y = worldHeight - 100 - Math.random() * 100;
        }
        plane.vx = 0.5 + Math.random() * 0.3;
        plane.vy = -0.3 - Math.random() * 0.2;
    }

    const posX = plane.x - camera.x;
    const posY = plane.y - camera.y;

    ctx.save();
    ctx.globalAlpha = plane.opacity;
    ctx.font = `${18 * plane.size}px Arial`;
    ctx.fillText(plane.icon, posX, posY);
    ctx.restore();
});
    // ===== CỎ =====
    ctx.fillStyle = '#16a34a';
    ctx.beginPath();
    ctx.moveTo(0 - camera.x, worldHeight - 80 - camera.y);
    for (let i = 0; i <= worldWidth; i += 30) {
        ctx.lineTo(i + 15 - camera.x, worldHeight - 100 + (i % 60 ? -10 : 10) - camera.y);
    }
    ctx.lineTo(worldWidth - camera.x, worldHeight - 80 - camera.y);
    ctx.lineTo(worldWidth - camera.x, worldHeight - camera.y);
    ctx.lineTo(0 - camera.x, worldHeight - camera.y);
    ctx.closePath();
    ctx.fill();

    // ===== ĐẤT =====
    ctx.fillStyle = '#fbd38d';
    ctx.fillRect(0 - camera.x, worldHeight - 80 - camera.y, worldWidth, 40);
    ctx.fillStyle = '#d97706';
    ctx.fillRect(0 - camera.x, worldHeight - 40 - camera.y, worldWidth, 4);

    // ===== NẤM =====
    backgroundMushrooms.forEach(([x, y]) => {
        ctx.fillStyle = '#b91c1c';
        ctx.beginPath();
        ctx.arc(x - camera.x, y - camera.y, 4, 0, Math.PI);
        ctx.fill();
        ctx.fillStyle = '#92400e';
        ctx.fillRect(x - 1 - camera.x, y - camera.y, 2, 5);
    });

    // ===== ĐÁ =====
    ctx.fillStyle = '#444';
    backgroundRocks.forEach(([x, y]) => {
        ctx.beginPath();
        ctx.ellipse(x - camera.x, y - camera.y, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
    });

    // ===== BÓNG BAY =====
backgroundBalloons.forEach(balloon => {
    balloon.x += balloon.vx;
    balloon.y -= balloon.speed;

    // Khi bay quá cao so với camera thì reset về dưới thấp
    if (balloon.y < camera.y + 100) {
        balloon.x = Math.random() * worldWidth;
        balloon.y = worldHeight - 300 - Math.random() * 100;
        balloon.vx = -0.05 + Math.random() * 0.1;
        balloon.speed = 0.15 + Math.random() * 0.1;
    }

    // Vẽ dây nhỏ
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.beginPath();
    ctx.moveTo(balloon.x - camera.x, balloon.y + 20 - camera.y);
    ctx.lineTo(balloon.x - camera.x, balloon.y + 30 - camera.y);
    ctx.stroke();

    // Vẽ bóng bay
    ctx.fillStyle = balloon.color;
    ctx.beginPath();
    ctx.ellipse(balloon.x - camera.x, balloon.y - camera.y, 10, 15, 0, 0, Math.PI * 2);
    ctx.fill();

    // Hiệu ứng sáng nhẹ
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.beginPath();
    ctx.ellipse(balloon.x - 4 - camera.x, balloon.y - 6 - camera.y, 2, 4, 0, 0, Math.PI * 2);
    ctx.fill();
});
    // ===== HOA BỒ CÔNG ANH =====
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.lineWidth = 0.5;
    backgroundSeeds.forEach((seed) => {
        seed.x += seed.vx;
        seed.y -= seed.speed;

        if (seed.y < camera.y + 100) {
            seed.x = Math.random() * worldWidth;
            seed.y = worldHeight - 300 - Math.random() * 100;
            seed.vx = -0.1 + Math.random() * 0.2;
            seed.speed = 0.02 + Math.random() * 0.05;
        }

        let posX = seed.x - camera.x;
        let posY = seed.y - camera.y;

        ctx.beginPath();
        ctx.moveTo(posX, posY);
        ctx.lineTo(posX, posY + 6);
        ctx.stroke();

        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            let angle = (Math.PI * 2 / 8) * i;
            let endX = posX + Math.cos(angle) * 4;
            let endY = posY + Math.sin(angle) * 2;
            ctx.moveTo(posX, posY);
            ctx.lineTo(endX, endY);
        }
        ctx.stroke();
    });
}
/**
 * Vẽ hiệu ứng Hào quang Hỗ trợ dưới chân người chơi
 */
function drawSupportAura(ctx) {
    if (!supportAuraActive) return;

    const centerX = player.x;
    const centerY = player.y + player.size - 5;
    const rotationInner = Date.now() / 4000; // Tốc độ xoay của hoa văn bên trong
    const rotationOuter = -Date.now() / 5000; // Tốc độ xoay ngược chiều của vòng ngoài

    // --- Bắt đầu vẽ vòng tròn bên trong (GIỮ NGUYÊN) ---
    const radiusXInner = 50;
    const radiusYInner = 25;
    
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(centerX, centerY, radiusXInner, radiusYInner, 0, 0, Math.PI * 2);
    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radiusXInner);
    gradient.addColorStop(0, 'rgba(100, 80, 20, 0.5)');
    gradient.addColorStop(1, 'rgba(50, 40, 0, 0.4)');
    ctx.fillStyle = gradient;
    ctx.fill();
    ctx.clip(); 
    
    ctx.strokeStyle = `rgba(255, 215, 0, 0.7)`;
    ctx.lineWidth = 1.5;
    ctx.shadowColor = "gold";
    ctx.shadowBlur = 10;
    
    auraCrackLines.forEach(line => {
        const r_x1 = line.x1 * Math.cos(rotationInner) - line.y1 * Math.sin(rotationInner);
        const r_y1 = line.x1 * Math.sin(rotationInner) + line.y1 * Math.cos(rotationInner);
        const r_x2 = line.x2 * Math.cos(rotationInner) - line.y2 * Math.sin(rotationInner);
        const r_y2 = line.x2 * Math.sin(rotationInner) + line.y2 * Math.cos(rotationInner);
        ctx.beginPath();
        ctx.moveTo(centerX + r_x1, centerY + r_y1 * 0.5);
        ctx.lineTo(centerX + r_x2, centerY + r_y2 * 0.5);
        ctx.stroke();
    });
    ctx.restore();
    // --- Kết thúc vẽ vòng tròn bên trong ---


    // --- (MỚI) Vẽ vòng tròn bên ngoài có hoa văn và xoay ngược chiều ---
    const radiusXOuter = 52; // Bán kính vòng ngoài lớn hơn
    const radiusYOuter = 26;

    ctx.save();
    // 1. Vẽ viền phát sáng
    ctx.beginPath();
    ctx.ellipse(centerX, centerY, radiusXOuter, radiusYOuter, 0, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255, 230, 150, 0.3)`;
    ctx.lineWidth = 2;
    ctx.shadowColor = "gold";
    ctx.shadowBlur = 10;
    ctx.stroke();

    // 2. Vẽ hoa văn là các chấm nhỏ xoay ngược chiều
    const numDots = 40;
    for (let i = 0; i < numDots; i++) {
        const angle = (Math.PI * 2 / numDots) * i + rotationOuter;
        const dotRadius = 0.5;
        const dotX = centerX + Math.cos(angle) * radiusXOuter;
        const dotY = centerY + Math.sin(angle) * radiusYOuter;

        ctx.beginPath();
        ctx.arc(dotX, dotY, dotRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 230, 150, 0.8)';
        ctx.fill();
    }
    ctx.restore();
}
function drawAuraLightBeams(ctx) {
    if (!supportAuraActive) return;

    ctx.save();
    auraLightBeams.forEach(beam => {
        const groundY = player.y + player.size - 5;
        const height = 100; // Chiều cao của cột sáng

        // Tạo gradient mờ dần về phía trên
        const gradient = ctx.createLinearGradient(beam.x, groundY, beam.x, groundY - height);
        gradient.addColorStop(0, `rgba(255, 215, 0, ${beam.alpha * 0.5})`);
        gradient.addColorStop(1, `rgba(255, 215, 0, 0)`);
        
        ctx.fillStyle = gradient;
        ctx.fillRect(beam.x - beam.width / 2, groundY - height, beam.width, height);
    });
    ctx.restore();
}
// Hàm con để vẽ 2 đóm sáng cho một hiệu ứng buff cụ thể
function drawSingleBuffEffect(effect) {
    const centerX = player.x;
    const centerY = player.y;
    const baseRadius = player.size + 15;

    // --- Tính toán vị trí và vẽ vệt sáng (Trail) ---
    const trailLength = 5;
    for (let i = 1; i <= trailLength; i++) {
        const trailAngle = effect.angle - (0.05 * i);
        const radiusX = baseRadius + Math.sin(trailAngle / 2) * 8;
        const radiusY = baseRadius * 0.6;
        const x1 = centerX + Math.cos(trailAngle) * radiusX;
        const y1 = centerY + Math.sin(trailAngle * 2) * radiusY;
        const x2 = centerX - Math.cos(trailAngle) * radiusX;
        const y2 = centerY - Math.sin(trailAngle * 2) * radiusY;

        const alpha = 1.0 - (i / trailLength);
        ctx.globalAlpha = alpha * 0.5;
        ctx.fillStyle = effect.color;

        ctx.beginPath();
        ctx.arc(x1, y1, 3 - i * 0.5, 0, Math.PI * 2); // Kích thước đóm sáng
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x2, y2, 3 - i * 0.5, 0, Math.PI * 2);
        ctx.fill();
    }

    // --- Vẽ Đóm sáng chính ---
    ctx.globalAlpha = 1.0;
    const currentRadiusX = baseRadius + Math.sin(effect.angle / 2) * 8;
    const currentRadiusY = baseRadius * 0.6;
    const currentX1 = centerX + Math.cos(effect.angle) * currentRadiusX;
    const currentY1 = centerY + Math.sin(effect.angle * 2) * currentRadiusY;
    const currentX2 = centerX - Math.cos(effect.angle) * currentRadiusX;
    const currentY2 = centerY - Math.sin(effect.angle * 2) * currentRadiusY;

    ctx.fillStyle = effect.color;
    ctx.beginPath();
    ctx.arc(currentX1, currentY1, 3, 0, Math.PI * 2); // Kích thước đóm sáng
    ctx.fill();
    ctx.beginPath();
    ctx.arc(currentX2, currentY2, 3, 0, Math.PI * 2);
    ctx.fill();
}
//🎨 9. Vẽ khung hình (draw canvas)
function draw() {
  const now = Date.now(); // dùng cho các so sánh buff, crit, v.v.
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBackground();
  drawBackgroundByTime(ctx);
  ctx.save();
  ctx.translate(-camera.x, -camera.y); // dịch toàn bộ hệ tọa độ theo camera
// --- VẼ TẤT CẢ CÁC MÁI VÒM AN TOÀN ---
    safeZones.forEach(zone => {
        if (zone.active) { // <-- Chỉ vẽ zone đang active
            ctx.save();
            const pulse = Math.sin(Date.now() / 400 + zone.id) * 5;
            ctx.beginPath();
            ctx.arc(zone.x, zone.y, zone.radius + pulse, 0, Math.PI * 2);

            const gradient = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, zone.radius + pulse);
            gradient.addColorStop(0, "rgba(0, 255, 255, 0)");
            gradient.addColorStop(0.8, "rgba(0, 255, 255, 0.2)");
            gradient.addColorStop(1, "rgba(0, 255, 255, 0.5)");

            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.strokeStyle = "rgba(0, 255, 255, 0.8)";
            ctx.lineWidth = 2;
            ctx.shadowColor = "#00ffff";
            ctx.shadowBlur = 15;
            ctx.stroke();
            
            ctx.font = "bold 24px Segoe UI";
            ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.shadowBlur = 10;
            ctx.shadowColor = "#00ffff";
            ctx.fillText(zone.name, zone.x, zone.y);

            ctx.restore();
        }
    });
    
    // Dòng này sẽ tự động vẽ các shop đang active
    drawShopNPC(ctx);
// --- KẾT THÚC VẼ MÁI VÒM ---

// 🧱 Vẽ tường dày có sọc chéo
ctx.fillStyle = "#123"; // nền tối
ctx.fillRect(0, 0, worldWidth, wallThickness); // Trên
ctx.fillRect(0, worldHeight - wallThickness, worldWidth, wallThickness); // Dưới
ctx.fillRect(0, 0, wallThickness, worldHeight); // Trái
ctx.fillRect(worldWidth - wallThickness, 0, wallThickness, worldHeight); // Phải

// 🎨 Vẽ sọc chéo lên từng cạnh
drawDiagonalStripes(ctx, 0, 0, worldWidth, wallThickness); // Trên
drawDiagonalStripes(ctx, 0, worldHeight - wallThickness, worldWidth, wallThickness); // Dưới
drawDiagonalStripes(ctx, 0, 0, wallThickness, worldHeight); // Trái
drawDiagonalStripes(ctx, worldWidth - wallThickness, 0, wallThickness, worldHeight); // Phải
// (MỚI) Vẽ Hào quang Hỗ trợ dưới chân
drawSupportAura(ctx);
drawAuraLightBeams(ctx);
  // 1. VẼ CÁC ĐÓM SÁNG Ở PHÍA SAU PLAYER
  for (const buff in buffEffects) {
      const effect = buffEffects[buff];
      // Kiểm tra xem đóm sáng có đang ở nửa trên quỹ đạo không
      if (effect.active && Math.sin(effect.angle * 2) < 0) {
          ctx.save();
          ctx.shadowColor = effect.color;
          ctx.shadowBlur = 15;
          drawSingleBuffEffect(effect);
          ctx.restore();
      }
  }
  // 2. VẼ PLAYER
if (!player.isDying && player.size > 0.1) {
// 🎯 Vẽ tên người chơi trên đầu
ctx.font = "1rem sans-serif";
ctx.fillStyle = "#00ccff"; // 💙 Màu xanh dương
ctx.shadowColor = "#00ccff";
ctx.shadowBlur = 8;
ctx.textAlign = "center";
ctx.textBaseline = "bottom";
ctx.fillText(player.name, player.x, player.y - player.size - 4); // Vẽ tên trên đầu player
// --- BẮT ĐẦU: Vẽ chữ hiệu ứng trên đầu player ---
/*    let buffTextYOffset = player.y - player.size - 20;
    ctx.font = "0.8rem sans-serif";
    ctx.textAlign = "center";
    
    const now = Date.now();
    const isExpActive = now < expBuffEndTime;
    const isCrazyActive = now < crazyBuffEndTime;
    const isPowerActive = now < powerBuffEndTime;
    const isLuckyActive = now < luckyBuffEndTime;
    const isCrazyMadnessActive = now < crazyMadnessTimeEndTime;
    // VẼ CRAZYMADNESSTIME
    if (now < crazyMadnessTimeEndTime) {
        ctx.fillStyle = "#0613c5"; // Màu xanh dương
        ctx.shadowColor = "white";
        ctx.shadowBlur = 2;
        ctx.fillText("💢 CrazyMadnessTime", player.x, buffTextYOffset);
        buffTextYOffset -= 18; // Dịch chữ tiếp theo lên trên
    }
    // Vẽ ExpUp (MỚI)
    if (isExpActive) {
        ctx.fillStyle = "#ffeb3b"; // Màu vàng
        ctx.shadowColor = "white";
        ctx.shadowBlur = 2;
        ctx.fillText("🌿 ExpUp", player.x, buffTextYOffset);
        buffTextYOffset -= 18; // Dịch chữ tiếp theo lên trên
    }
    
    // Vẽ Crazy
    if (isCrazyActive) {
        ctx.fillStyle = "#f59e0b";
        ctx.shadowColor = "white";
        ctx.shadowBlur = 2;
        ctx.fillText("🍂 CrazyUp", player.x, buffTextYOffset);
        buffTextYOffset -= 18;
    }
    
    // Vẽ Power
    if (isPowerActive) {
        ctx.fillStyle = "#ef4444";
        ctx.shadowColor = "white";
        ctx.shadowBlur = 2;
        ctx.fillText("🍁 PowerUp", player.x, buffTextYOffset);
        buffTextYOffset -= 18;
    }

    // Vẽ Lucky
    if (isLuckyActive) {
        ctx.fillStyle = "#22c55e";
        ctx.shadowColor = "white";
        ctx.shadowBlur = 2;
        ctx.fillText("🍀 LuckyUp", player.x, buffTextYOffset);
    }

    ctx.shadowBlur = 0; // Reset hiệu ứng */
    // --- KẾT THÚC: Vẽ chữ hiệu ứng trên đầu player ---
ctx.shadowBlur = 0; // reset sau khi vẽ
ctx.shadowColor = "transparent";
// Vẽ hình tròn player
if (disguiseActive) {
    // --- (MỚI) LOGIC CẢNH BÁO NHẤP NHÁY ---
    const remainingTime = disguiseEndTime - Date.now();
    let shouldDraw = true;

    // Nếu thời gian còn lại dưới 2 giây
    if (remainingTime < 3000 && remainingTime > 0) {
        // Nhấp nháy mỗi 150 mili giây
        if (Math.floor(Date.now() / 150) % 2 === 0) {
            shouldDraw = false;
        }
    }
    
    // Chỉ vẽ nếu không trong giai đoạn "tắt" của hiệu ứng
    if (shouldDraw) {
        // 🐸 Vẽ ếch thay cho player
        ctx.save();
        ctx.font = "2rem serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "lime";
        ctx.shadowBlur = 8;
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = "white";
        ctx.fillText("🐸", player.x, player.y);
        ctx.restore();
    }
} else {
  // 🧍 Vẽ player bình thường
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);

  if (levelUpGlowTime > 0) {
    ctx.shadowBlur = 4;
    ctx.shadowColor = "gold";
    ctx.fillStyle = "gold";
  } else {
    ctx.shadowBlur = 0;
    ctx.shadowColor = "transparent";
    ctx.fillStyle = (player.hitTimer % 10 < 5) ? "#ff4c4c" : "#00ff00";
  }
}
  ctx.fill();
  ctx.lineWidth = 2.2;
  ctx.strokeStyle = "rgba(0, 255, 255, 0.4)";
  ctx.shadowColor = "rgba(0, 255, 255, 0.25)";
  ctx.stroke();
  drawPlayerHealthBar(ctx);
  drawPlayerStaminaBar(ctx)
    // 3. VẼ CÁC ĐÓM SÁNG Ở PHÍA TRƯỚC PLAYER
  for (const buff in buffEffects) {
      const effect = buffEffects[buff];
      // Kiểm tra xem đóm sáng có đang ở nửa dưới quỹ đạo không
      if (effect.active && Math.sin(effect.angle * 2) >= 0) {
          ctx.save();
          ctx.shadowColor = effect.color;
          ctx.shadowBlur = 15;
          drawSingleBuffEffect(effect);
          ctx.restore();
      }
  }
      // ✨✨ DỜI TOÀN BỘ KHỐI VẼ MẮT VÀ MIỆNG VÀO ĐÂY ✨✨
    if (zombies.length > 0) {
        const target = zombies.reduce((a, b) => distance(a, player) < distance(b, player) ? a : b);
        const angle = Math.atan2(target.y - player.y, target.x - player.x);
        const eyeOffsetX = Math.cos(angle) * (player.size * 0.3); // Điều chỉnh theo size
        const eyeOffsetY = Math.sin(angle) * (player.size * 0.3);
        const mouthOffsetX = Math.cos(angle) * (player.size * 0.5);
        const mouthOffsetY = Math.sin(angle) * (player.size * 0.5);

        // Mắt trái
        ctx.beginPath();
        ctx.arc(player.x + eyeOffsetX - (player.size * 0.2), player.y + eyeOffsetY - (player.size * 0.2), 2, 0, Math.PI * 2);
        ctx.fillStyle = "white";
        ctx.fill();

        // Mắt phải
        ctx.beginPath();
        ctx.arc(player.x + eyeOffsetX + (player.size * 0.2), player.y + eyeOffsetY - (player.size * 0.2), 2, 0, Math.PI * 2);
        ctx.fill();

        // Miệng
        ctx.beginPath();
        ctx.arc(player.x + mouthOffsetX, player.y + mouthOffsetY + (player.size * 0.15), 2, 0, Math.PI);
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1;
        ctx.stroke();
    }
}
if (playerTeleportState.isTeleporting || playerTeleportState.alpha < 1) {
    ctx.restore();
}

// 🎭 Vẽ các ảo ảnh phân thân
clones.forEach((c,i) => {
  ctx.save();
  ctx.beginPath();
  ctx.arc(c.x, c.y, player.size * 0.75, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
  ctx.shadowBlur = 8;
  ctx.shadowColor = "#aaaaff";
  ctx.fill();
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = "rgba(0,255,255,0.6)";
  ctx.stroke();
  ctx.restore();

  // 👁️ Mắt của clone
  ctx.beginPath();
  ctx.arc(c.x - 3, c.y - 5, 1.5, 0, Math.PI * 2);
  ctx.arc(c.x + 3, c.y - 5, 1.5, 0, Math.PI * 2);
  ctx.fillStyle = "white";
  ctx.fill();
// 👄 Miệng clone
  ctx.beginPath();
  ctx.arc(c.x, c.y + 4, 5, 0, Math.PI); // nửa cung tròn hướng lên (miệng cười)
  ctx.strokeStyle = "rgba(0, 100, 200, 0.6)";
  ctx.lineWidth = 1.2;
  ctx.stroke();
   // 🏷️ Tên clone (Clone 1, 2, ...)
  ctx.font = "bold 12px Segoe UI";
  ctx.fillStyle = "#00ccff"; // Màu xanh dương
  ctx.textAlign = "center";
  ctx.fillText(`Clone ${i + 1}`, c.x, c.y - 22);
});

  bullets.forEach(b => {
  if (!b.active) return; // 🛡 bỏ qua đạn đã bị gỡ
ctx.save();
ctx.translate(b.x, b.y);
    // Nếu là đạn của Fairy, vẽ nó theo kiểu khác
    if (b.isFairyBullet) {
        ctx.fillStyle = 'rgba(100, 255, 150, 0.9)';
        ctx.shadowColor = 'lime';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(0, 0, 5, 0, Math.PI * 2);
        ctx.fill();
    }
    // 2. Nếu là đạn Cà rốt của Pet
    else if (b.isPetBullet) {
        ctx.font = "1.2rem serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(b.icon, 0, 0); // Vẽ icon cà rốt 🥕
    }
      else if (b.isIceArrow) {
    // 🏹 VẼ MŨI TÊN BĂNG KHÔNG ROTATE/SHADOW (ít rác, nhanh)
    // Dựa vào hướng bay đã có sẵn trong b.dx, b.dy
    const vx = b.dx, vy = b.dy;           // vector dọc thân
    const nx = -vy, ny = vx;              // vector vuông góc (trái/phải)

    // Tham số hình học (có thể tinh chỉnh)
    const shaftHalf  = 8;   // nửa chiều dài thân
    const headLen    = 6;   // độ dài đầu nhọn
    const headWidth  = 4;   // bề ngang đầu nhọn
    const tailLen    = 6;   // độ lồi của lông đuôi
    const tailWidth  = 3;   // bề ngang lông đuôi

    // Tâm đang ở (0,0) vì đã translate(b.x, b.y)
    const cx = 0, cy = 0;

    // Các điểm chính
    const shaftStartX = cx - vx * shaftHalf;
    const shaftStartY = cy - vy * shaftHalf;
    const shaftEndX   = cx + vx * shaftHalf;
    const shaftEndY   = cy + vy * shaftHalf;

    const tipX  = cx + vx * (shaftHalf + headLen);
    const tipY  = cy + vy * (shaftHalf + headLen);

    const leftHeadX  = tipX - vx * headLen + nx * headWidth;
    const leftHeadY  = tipY - vy * headLen + ny * headWidth;
    const rightHeadX = tipX - vx * headLen - nx * headWidth;
    const rightHeadY = tipY - vy * headLen - ny * headWidth;

    const tailX = cx - vx * (shaftHalf + tailLen);
    const tailY = cy - vy * (shaftHalf + tailLen);
    const leftTailX  = tailX + nx * tailWidth;
    const leftTailY  = tailY + ny * tailWidth;
    const rightTailX = tailX - nx * tailWidth;
    const rightTailY = tailY - ny * tailWidth;

    // Vẽ bằng line (không path phức tạp, không rotate, không shadowBlur)
    ctx.beginPath();
    // thân
    ctx.moveTo(shaftStartX, shaftStartY);
    ctx.lineTo(shaftEndX,   shaftEndY);
    // đầu nhọn
    ctx.moveTo(tipX, tipY); ctx.lineTo(leftHeadX,  leftHeadY);
    ctx.moveTo(tipX, tipY); ctx.lineTo(rightHeadX, rightHeadY);
    // lông đuôi
    ctx.moveTo(shaftStartX, shaftStartY); ctx.lineTo(leftTailX,  leftTailY);
    ctx.moveTo(shaftStartX, shaftStartY); ctx.lineTo(rightTailX, rightTailY);

    ctx.lineWidth = 2;
    ctx.strokeStyle = "#aef";
    ctx.stroke();
      }
    // 3. Các loại đạn còn lại (của người chơi, clone...)
    else {
        if (b.piercing) {
            b.rotation = (b.rotation || 0) + 0.3;
            ctx.rotate(b.rotation);
            ctx.fillStyle = b.color || "cyan";
            ctx.beginPath();
            ctx.moveTo(-6, -3);
            ctx.lineTo(6, 0);
            ctx.lineTo(-6, 3);
            ctx.closePath();
            ctx.shadowBlur = 4;
            ctx.shadowColor = b.color || "cyan";
            ctx.fill();
        } else {
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI * 2);
            ctx.fillStyle = b.color || "yellow";
            ctx.fill();
        }
    }
    ctx.restore();
});
// Vẽ tia laze của người chơi
  const eyeOffsetDistance = player.size * 0.4; 

  playerLasers.forEach(laser => {
      // 1. Tính toán vector vuông góc với hướng bắn để xác định vị trí 2 mắt
      const perpAngle = laser.angle + Math.PI / 2;
      const offsetX = Math.cos(perpAngle) * eyeOffsetDistance;
      const offsetY = Math.sin(perpAngle) * eyeOffsetDistance;

      let startX, startY;

      // 2. Xác định điểm bắt đầu của tia lazer dựa trên là mắt 'trái' hay 'phải'
      if (laser.eye === 'left') {
          startX = player.x - offsetX;
          startY = player.y - offsetY;
      } else { // 'right'
          startX = player.x + offsetX;
          startY = player.y + offsetY;
      }

      // 3. Điểm kết thúc của tia lazer (rất xa)
      const endX = startX + Math.cos(laser.angle) * 2000;
      const endY = startY + Math.sin(laser.angle) * 2000;

      // 4. Bắt đầu vẽ tia lazer (logic style giữ nguyên)
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      
      ctx.strokeStyle = "cyan";
      ctx.lineWidth = 4;
      ctx.shadowColor = "cyan";
      ctx.shadowBlur = 10;
      ctx.globalAlpha = laser.life / 20; // Mờ dần

      ctx.stroke();
      ctx.restore();
  });

// 🔫 Vẽ đạn từ boss & mini boss
enemyBullets.forEach(b => {
  ctx.beginPath();
  ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
  ctx.fillStyle = "red";
  ctx.fill();
});
function fmtAbbr(n) {
  n = Math.max(0, Math.floor(n));
  if (n >= 1e9) return (n/1e9).toFixed(1).replace(/\.0$/,'') + 'B';
  if (n >= 1e6) return (n/1e6).toFixed(1).replace(/\.0$/,'') + 'M';
  if (n >= 1e3) return (n/1e3).toFixed(1).replace(/\.0$/,'') + 'k';
  return String(n);
}

// Vẽ bigboss
function drawBigBoss(ctx, z) {
    const { x, y, radius, hp } = z; // Lấy các thuộc tính từ 'z' để dùng bên dưới
    ctx.save();
    ctx.translate(x, y);

    // Ánh sáng nền
    ctx.beginPath();
    ctx.arc(0, 0, radius + 20, 0, Math.PI * 2);
    ctx.fillStyle = "#123";
    ctx.shadowColor = "#a445f5";
    ctx.shadowBlur = 20;
    ctx.fill();
    ctx.shadowBlur = 0;
    // Hiệu ứng vòng xoáy bên trong boss
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = "#a445f5";
    ctx.lineWidth = 1;

    const numCircles = 6;
    for (let i = 0; i < numCircles; i++) {
        ctx.beginPath();
        ctx.arc(0, 0, (radius / 6) * (i + 1), 0, Math.PI * 2);
        ctx.stroke();
    }

    ctx.globalAlpha = 1;
    ctx.restore();

    // Tay trái
    ctx.beginPath();
    ctx.moveTo(-radius * 0.55, -radius * 0.1);
    ctx.quadraticCurveTo(-radius, 0, -radius * 0.9, radius * 0.3);
    ctx.quadraticCurveTo(-radius * 0.8, radius * 0.1, -radius * 0.5, 0);
    ctx.closePath();
    ctx.fillStyle = "#4e2d6d";
    ctx.fill();

    // Tay phải
    ctx.beginPath();
    ctx.moveTo(radius * 0.55, -radius * 0.1);
    ctx.quadraticCurveTo(radius, 0, radius * 0.9, radius * 0.3);
    ctx.quadraticCurveTo(radius * 0.8, radius * 0.1, radius * 0.5, 0);
    ctx.closePath();
    ctx.fill();

    // Chân trái (dài hơn)
    ctx.beginPath();
    ctx.moveTo(-20, radius * 0.4);
    ctx.lineTo(-30, radius * 0.8);
    ctx.lineTo(-10, radius * 0.8);
    ctx.lineTo(0, radius * 0.4);
    ctx.closePath();
    ctx.fill();

    // Chân phải (dài hơn)
    ctx.beginPath();
    ctx.moveTo(20, radius * 0.4);
    ctx.lineTo(30, radius * 0.8);
    ctx.lineTo(10, radius * 0.8);
    ctx.lineTo(0, radius * 0.4);
    ctx.closePath();
    ctx.fill();

    // Cơ thể
    ctx.beginPath();
    ctx.moveTo(-radius * 0.6, -radius * 0.1);
    ctx.bezierCurveTo(-radius * 0.75, radius * 0.3, -30, radius * 0.6, 0, radius * 0.5);
    ctx.bezierCurveTo(30, radius * 0.6, radius * 0.75, radius * 0.3, radius * 0.6, -radius * 0.1);
    ctx.closePath();
    ctx.fillStyle = "#4e2d6d";
    ctx.fill();

    // Bụng rách
    ctx.beginPath();
    ctx.moveTo(-15, 20);
    ctx.lineTo(0, 30);
    ctx.lineTo(15, 20);
    ctx.lineTo(0, 40);
    ctx.closePath();
    ctx.fillStyle = "#8b1f1f";
    ctx.fill();

    // Đầu
    ctx.beginPath();
    ctx.ellipse(0, -radius * 0.35, 45, 60, 0, 0, Math.PI * 2);
    ctx.fillStyle = "#6f3c9c";
    ctx.fill();
    ctx.strokeStyle = "#26142e";
    ctx.lineWidth = 3;
    ctx.stroke();

    // Mắt đỏ glow
    function eye(x, y) {
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fillStyle = "#ff3333";
        ctx.shadowColor = "#ff0000";
        ctx.shadowBlur = 12;
        ctx.fill();
        ctx.shadowBlur = 0;
    }
    eye(-18, -radius * 0.4);
    eye(18, -radius * 0.4);

    // Lông mày
    ctx.strokeStyle = "#2e163a";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-28, -radius * 0.47);
    ctx.lineTo(-8, -radius * 0.5);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(28, -radius * 0.47);
    ctx.lineTo(8, -radius * 0.5);
    ctx.stroke();

    // Tóc
    ctx.beginPath();
    ctx.arc(0, -radius * 0.6, 30, Math.PI, 0);
    ctx.fillStyle = "#1e0f2a";
    ctx.fill();

    // Mũi
    ctx.beginPath();
    ctx.moveTo(-5, -radius * 0.2);
    ctx.lineTo(0, -radius * 0.15);
    ctx.lineTo(5, -radius * 0.2);
    ctx.fillStyle = "#3a1f4d";
    ctx.fill();

    // Miệng đen + răng nanh đen
    ctx.beginPath();
    ctx.moveTo(-18, -radius * 0.1);
    ctx.quadraticCurveTo(0, 0, 18, -radius * 0.1);
    ctx.quadraticCurveTo(0, 10, -18, -radius * 0.1);
    ctx.closePath();
    ctx.fillStyle = "#120000";
    ctx.fill();

    // Răng nanh đen nhỏ
    ctx.fillStyle = "#120000";
    function fang(x, y, h, flip = 1) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + 3 * flip, y + h);
        ctx.lineTo(x - 3 * flip, y + h);
        ctx.closePath();
        ctx.fill();
    }
    fang(-8, -radius * 0.1 + 5, 6);
    fang(8, -radius * 0.1 + 5, 6);

    // Vết nứt đầu
    ctx.beginPath();
    ctx.moveTo(-10, -radius * 0.6);
    ctx.lineTo(-5, -radius * 0.5);
    ctx.lineTo(-15, -radius * 0.4);
    ctx.lineTo(-5, -radius * 0.3);
    ctx.strokeStyle = "#4b2b60";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Sẹo mặt
    ctx.beginPath();
    ctx.moveTo(22, -8);
    ctx.lineTo(18, 3);
    ctx.lineTo(28, 6);
    ctx.strokeStyle = "#8a477e";
    ctx.stroke();

    // Sẹo ngực
    ctx.beginPath();
    ctx.moveTo(-18, 28);
    ctx.lineTo(-8, 38);
    ctx.lineTo(-22, 48);
    ctx.stroke();

    // Giáp vai
    ctx.fillStyle = "#2b2b2b";
    ctx.beginPath();
    ctx.moveTo(-55, -5);
    ctx.quadraticCurveTo(-90, 10, -70, 35);
    ctx.quadraticCurveTo(-40, 20, -35, 25);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(55, -5);
    ctx.quadraticCurveTo(90, 10, 70, 35);
    ctx.quadraticCurveTo(40, 20, 35, 25);
    ctx.closePath();
    ctx.fill();

    // Sừng vỡ
    function horn(x, y, flip = 1) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.bezierCurveTo(x + 15 * flip, y - 35, x + 25 * flip, y - 55, x + 10 * flip, y);
        ctx.lineTo(x + 4 * flip, y);
        ctx.closePath();
        ctx.fillStyle = "#444";
        ctx.fill();
        ctx.strokeStyle = "#222";
        ctx.stroke();
    }
    horn(-30, -radius * 0.6, -1);
    horn(30, -radius * 0.6, 1);

    /*// BOSS + HP
    ctx.font = `${radius * 0.3}px sans-serif`;
    ctx.fillStyle = "violet";
    ctx.textAlign = "center";
    ctx.strokeStyle = "#bb99ff";
    ctx.lineWidth = 2;
    ctx.strokeText(`BOSS ${hp}`, 0, -radius - 30); // Thêm viền chữ
    ctx.fillText(`BOSS ${hp}`, 0, -radius - 30); // Tên boss */
    // --- thêm tên và level của boss (theo local coords) ---
    const lvl = (z.level ?? 1);
const title = `${z.style || 'Boss'} Lv${lvl}`;
/*ctx.font = `${Math.max(12, Math.floor(radius * 0.22))}px sans-serif`;*/
ctx.font = `${radius * 0.3}px sans-serif`;
ctx.fillStyle = "violet";
ctx.textAlign = "center";
ctx.strokeStyle = "#bb99ff";
ctx.lineWidth = 2;
ctx.strokeText(title, 0, -radius - 30);
ctx.fillText(title,   0, -radius - 30);

// --- thêm thanh HP của boss (theo local coords) ---
const maxHp = z.baseHp || z.maxHp || z.hp || 1;
const pct   = Math.max(0, Math.min(1, z.hp / maxHp));
const barW  = Math.max(90, Math.floor(radius * 2)); // chiều rộng thanh HP
const barH  = Math.max(6,  Math.floor(radius * 0.12)); // chiều cao thanh HP
const bx = Math.round(-barW / 2), by = Math.round(radius + 24); // vị trí thanh HP

// khung
ctx.fillStyle = "rgba(255,255,255,0.15)";
ctx.fillRect(bx, by, barW, barH);
// nền
ctx.fillStyle = "rgba(0,0,0,0.4)";
ctx.fillRect(bx + 1, by + 1, barW - 2, barH - 2);
// fill
let color;
if (pct > 0.6) color = "#a855f7"; // màu tím
else if (pct > 0.3) color = "#ffca28";
else color = "#f44336";
const fw = Math.max(0, Math.round((barW - 2) * pct));
ctx.fillStyle = color;
ctx.fillRect(bx + 1, by + 1, fw, barH - 2);
// highlight
ctx.fillStyle = "rgba(255,255,255,0.12)";
ctx.fillRect(bx + 1, by + 1, fw, 1);
// viền
ctx.strokeStyle = "rgba(255,255,255,0.2)";
ctx.lineWidth = 1;
ctx.strokeRect(bx + 0.5, by + 0.5, barW - 1, barH - 1);
// --- HP text inside the bar ---
const hpText = `${fmtAbbr(z.hp)} / ${fmtAbbr(maxHp)}`;
ctx.save();
ctx.font = `${Math.max(12, Math.floor(barH * 1))}px sans-serif`; // kích thước chữ dựa trên chiều cao thanh HP
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';

// viền chữ để dễ đọc trên nền tím
ctx.lineWidth = 1;
ctx.strokeStyle = 'rgba(0,0,0,0.6)';
ctx.strokeText(hpText, bx + barW / 2, by + barH / 2);

// chữ trắng nổi bật
ctx.fillStyle = '#fff';
ctx.fillText(hpText, bx + barW / 2, by + barH / 2);
ctx.restore();

    // ✨ THÊM HIỆU ỨNG CẢNH BÁO KHI BOSS ĐANG NGẮM BẮN
    if (z.isChargingLazer) {
        // Vẽ một tia laser mỏng, mờ, màu đỏ từ boss đến người chơi
        const chargeProgress = z.lazerTimer / 2; // 2 là CHARGE_TIME
        const alpha = 0.3 + chargeProgress * 0.4; // Độ mờ tăng dần
        
        ctx.save();
        ctx.beginPath();
        // Điểm bắt đầu là giữa 2 mắt của boss
        ctx.moveTo(0, -z.radius * 0.4); 
        // Điểm kết thúc là vị trí của người chơi (tính tương đối)
        const relativePlayerX = player.x - z.x;
        const relativePlayerY = player.y - z.y;
        ctx.lineTo(relativePlayerX, relativePlayerY);
        
        ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
        ctx.lineWidth = 1;
        ctx.shadowColor = 'red';
        ctx.shadowBlur = 10;
        ctx.stroke();
        ctx.restore();
        }
        ctx.restore();
}
function drawBigBossLazer(ctx, z) {
    if (!z.isBigBoss || !z.isLazerAttacking || z.lazerAngle === undefined) return;

    ctx.save();
    ctx.translate(z.x, z.y);

    // Vẽ vòng tròn phát sáng ở tâm bắn
    ctx.save();
    ctx.beginPath();
    ctx.arc(0, 0, 28, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(200,100,255,0.18)";
    ctx.shadowColor = "violet";
    ctx.shadowBlur = 20;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();

    // Vẽ vòng tròn nhỏ hơn, đậm hơn ở tâm
    ctx.save();
    ctx.beginPath();
    ctx.arc(0, 0, 12, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(200,100,255,0.45)";
    ctx.shadowColor = "violet";
    ctx.shadowBlur = 12;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();

    // Vẽ tia lazer
    ctx.rotate(z.lazerAngle);
    ctx.strokeStyle = "rgba(200, 100, 255, 0.7)";
    ctx.lineWidth = 8;
    ctx.shadowColor = "violet";
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    const lazerRange = 600; // Đảm bảo biến này có tồn tại
    ctx.lineTo(lazerRange, 0);
    ctx.stroke();
    ctx.restore();

    // Sử dụng 'z' thay vì 'bigBoss'
    const endX = z.x + Math.cos(z.lazerAngle) * lazerRange;
    const endY = z.y + Math.sin(z.lazerAngle) * lazerRange;
    const glowRadius = 30;

    const glow = ctx.createRadialGradient(endX, endY, 0, endX, endY, glowRadius);
    glow.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
    glow.addColorStop(0.4, 'rgba(128, 0, 128, 0.5)');
    glow.addColorStop(1, 'rgba(128, 0, 128, 0)');

    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(endX, endY, glowRadius, 0, Math.PI * 2);
    ctx.fill();
}

// Vẽ toàn bộ zombie hoạt động kèm icon, HP, trạng thái, biểu cảm (tối ưu fillText)
// Vòng lặp zombie
zombies.forEach(z => { 
    // ✨ BẮT ĐẦU ĐOẠN MÃ TĂNG HP MỚI ✨
    // Kiểm tra xem zombie có sống sót qua ngày mới không
    if (currentDay > z.lastDayBuffed) {
        const hpIncreaseMultiplier = 1.1; // Tăng 10% HP mỗi ngày
        // Tăng cả HP hiện tại và HP gốc để buff có hiệu lực vĩnh viễn
        z.hp = Math.round(z.hp * hpIncreaseMultiplier);
        z.baseHp = Math.round(z.baseHp * hpIncreaseMultiplier);
        z.lastDayBuffed = currentDay; // Cập nhật ngày đã được buff
        z.isBuffed = true; // Tạo hiệu ứng nhấp nháy trong 60 frame (khoảng 1 giây)
    }
    // ✨ KẾT THÚC ĐOẠN MÃ TĂNG HP MỚI ✨
  if (!z.active) return;
  // 🆕 Vẽ BigBoss giống Boss nhưng riêng block để dễ quản lý
  if (z.isBigBoss) {
    drawBigBoss(ctx, z);
    drawBigBossLazer(ctx, z);
    return;
  }
ctx.save();

// ✨ Glow cho Boss hoặc MiniBoss
if (z.isBoss || z.type === "miniBoss") {
  ctx.shadowColor = z.color || "#ffffff";
  ctx.shadowBlur = z.isBoss ? 8 : 4;
} else {
  ctx.shadowColor = "transparent";
  ctx.shadowBlur = 0;
}

// 🔵 Nếu zombie bị stun bởi lôi
if (z.stunned && Date.now() < z.stunnedUntil) {
  ctx.shadowColor = "#00e5ff";
  ctx.shadowBlur = 8;
  ctx.fillStyle = "#b3f0ff";
}
// 🔥 Nếu zombie bị trúng lửa
else if (z.onFireUntil && Date.now() < z.onFireUntil) {
  ctx.shadowColor = "orange";
  ctx.shadowBlur = 8;
  ctx.fillStyle = "#ffb347";
}
// ❄️ Nếu zombie bị trúng băng
else if (z.onIceUntil && Date.now() < z.onIceUntil) {
  ctx.shadowColor = "#00e5ff";
  ctx.shadowBlur = 8;
  ctx.fillStyle = "#b3e0ff";
}
else {
  ctx.fillStyle = z.color || "#ff69b4";
}

// 🎯 Vẽ hình tròn zombie
ctx.beginPath();
ctx.arc(z.x, z.y, z.radius, 0, Math.PI * 2);
ctx.fill();
ctx.restore();

// Vẽ chi tiết dựa trên style của zombie
switch (z.style) {
    case "Walker": // Zombie đi bộ thông thường
        ctx.fillStyle = "#333";
        ctx.fillRect(z.x - 5, z.y - 10, 10, 4); // Vết nứt trên đầu
        break;

    case "Brute": // Zombie to khỏe, trâu bò
        ctx.fillStyle = "#4a4a4a"; // Giáp vai
        ctx.fillRect(z.x - 15, z.y - 8, 30, 8);
        ctx.fillStyle = "darkred"; // Mắt đỏ
        ctx.beginPath();
        ctx.arc(z.x, z.y, 4, 0, Math.PI * 2);
        ctx.fill();
        break;

    case "Spitter": // Zombie phun độc
        ctx.fillStyle = "yellow"; // Túi độc
        ctx.beginPath();
        ctx.arc(z.x, z.y + 4, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "orange";
        ctx.stroke();
        break;

    case "Mutant": // Zombie đột biến
        ctx.fillStyle = "purple"; // Các khối u
        ctx.beginPath();
        ctx.arc(z.x - 8, z.y - 8, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(z.x + 10, z.y, 8, 0, Math.PI * 2);
        ctx.fill();
        break;
    case "Cyber":
      ctx.fillStyle = "#00ffff";
      ctx.fillRect(z.x - 10, z.y - 3, 20, 6);
      break;
    case "Hunter":
      ctx.fillStyle = "#654321";
      ctx.fillRect(z.x - 4, z.y - 8, 8, 16);
      ctx.fillStyle = "#432";
      ctx.fillRect(z.x - 6, z.y + 6, 12, 4);
      break;
    case "Shadow":
      ctx.fillStyle = "#333";
      ctx.fillRect(z.x - 10, z.y - 4, 20, 8);
      ctx.fillStyle = "red";
      ctx.fillRect(z.x - 5, z.y - 2, 10, 4);
      break;
    case "Arcanist":
      ctx.fillStyle = "purple";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 12, Math.PI, 2 * Math.PI);
      ctx.fill();
      ctx.fillStyle = "#ff0";
      ctx.fillRect(z.x - 3, z.y - 5, 6, 10);
      break;
    case "Soldier":
      ctx.fillStyle = "green";
      ctx.fillRect(z.x - 10, z.y - 8, 20, 5);
      ctx.fillStyle = "#444";
      ctx.fillRect(z.x - 3, z.y, 6, 12);
      break;
    case "Robot":
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 3, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#888";
      ctx.fillRect(z.x - 8, z.y + 4, 16, 4);
      break;
    case "Knight":
      ctx.fillStyle = "#999";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 4, 10, 0, Math.PI);
      ctx.fill();
      ctx.fillStyle = "#555";
      ctx.fillRect(z.x - 6, z.y, 12, 4);
      break;
    case "Rogue":
      ctx.strokeStyle = "orange";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(z.x, z.y, 6, 0, Math.PI * 2);
      ctx.stroke();
      break;
    case "Wraith":
      ctx.fillStyle = "#333";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "aqua";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 4, 2.5, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Astronaut":
      ctx.strokeStyle = "#ccc";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(z.x, z.y, 14, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillStyle = "#999";
      ctx.fillRect(z.x - 4, z.y + 2, 8, 4);
      break;
    case "Beast":
      ctx.fillStyle = "brown";
      ctx.fillRect(z.x - 5, z.y + 5, 10, 6);
      ctx.fillStyle = "#333";
      ctx.fillRect(z.x - 3, z.y - 6, 6, 3);
      break;
    case "Spectre":
      ctx.fillStyle = "lime";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#0f0";
      ctx.stroke();
      break;
    case "Ninja":
      ctx.fillStyle = "#111";
      ctx.fillRect(z.x - 8, z.y - 8, 16, 16);
      ctx.fillStyle = "red";
      ctx.fillRect(z.x - 4, z.y - 2, 8, 4);
      break;
    case "Samurai":
      ctx.fillStyle = "#444";
      ctx.fillRect(z.x - 10, z.y - 6, 20, 12);
      ctx.strokeStyle = "#c00";
      ctx.strokeRect(z.x - 10, z.y - 6, 20, 12);
      break;
    case "Alien":
      ctx.fillStyle = "lime";
      ctx.beginPath();
      ctx.ellipse(z.x, z.y, 10, 14, 0, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Skeleton":
      ctx.fillStyle = "#ddd";
      ctx.fillRect(z.x - 6, z.y - 10, 12, 20);
      ctx.strokeStyle = "#000";
      ctx.strokeRect(z.x - 6, z.y - 10, 12, 20);
      break;
    case "Mage":
      ctx.fillStyle = "violet";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 4, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "yellow";
      ctx.fillRect(z.x - 2, z.y + 2, 4, 10);
      break;
    case "Ghost":
      ctx.fillStyle = "#aaa";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 14, 0, Math.PI);
      ctx.fill();
      ctx.fillRect(z.x - 14, z.y, 28, 10);
      break;
    case "Monk":
      ctx.fillStyle = "#964B00";
      ctx.fillRect(z.x - 6, z.y - 8, 12, 16);
      ctx.fillStyle = "gold";
      ctx.fillRect(z.x - 3, z.y, 6, 10);
      break;
    case "Cyborg":
      ctx.fillStyle = "#999";
      ctx.fillRect(z.x - 10, z.y - 6, 20, 12);
      ctx.fillStyle = "red";
      ctx.fillRect(z.x + 6, z.y - 2, 4, 4);
      break;
    case "Shaman":
      ctx.fillStyle = "green";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "white";
      ctx.fillRect(z.x - 2, z.y - 8, 4, 16);
      break;
    case "Demon":
      ctx.fillStyle = "darkred";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#444";
      ctx.fillRect(z.x - 6, z.y, 12, 8);
      break;
    case "Angel":
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "gold";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 14, 4, 0, Math.PI * 2);
      ctx.stroke();
      break;
    case "Guardian":
      ctx.fillStyle = "#555";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.strokeStyle = "yellow";
      ctx.strokeRect(z.x - 10, z.y - 10, 20, 20);
      break;
    case "Pilot":
      ctx.fillStyle = "#005588";
      ctx.fillRect(z.x - 8, z.y - 8, 16, 16);
      ctx.fillStyle = "#eee";
      ctx.fillRect(z.x - 4, z.y - 4, 8, 4);
      break;
    case "Engineer":
      ctx.fillStyle = "#b8860b";
      ctx.fillRect(z.x - 10, z.y - 6, 20, 12);
      ctx.fillStyle = "#222";
      ctx.fillRect(z.x - 2, z.y - 2, 4, 4);
      break;
    case "Android":
      ctx.fillStyle = "#666";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "blue";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 5, 3, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Starfighter":
      ctx.fillStyle = "#800080";
      ctx.beginPath();
      ctx.moveTo(z.x - 10, z.y + 10);
      ctx.lineTo(z.x, z.y - 10);
      ctx.lineTo(z.x + 10, z.y + 10);
      ctx.closePath();
      ctx.fill();
      break;
    case "Commander":
      ctx.fillStyle = "#333366";
      ctx.fillRect(z.x - 12, z.y - 8, 24, 16);
      ctx.fillStyle = "gold";
      ctx.fillRect(z.x - 8, z.y - 4, 16, 8);
      break;
    case "Medic":
      ctx.fillStyle = "#fff";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "red";
      ctx.fillRect(z.x - 8, z.y - 2, 16, 4);
      ctx.fillRect(z.x - 2, z.y - 8, 4, 16);
      break;
    case "Barbarian":
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(z.x - 8, z.y - 10, 16, 20);
      ctx.fillStyle = "#555";
      ctx.fillRect(z.x - 10, z.y - 12, 20, 4);
      break;
    case "Paladin":
      ctx.fillStyle = "#ffd700";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "#4682B4";
      ctx.fillRect(z.x - 6, z.y - 6, 12, 12);
      break;
    case "Druid":
      ctx.fillStyle = "#228B22";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "brown";
      ctx.fillRect(z.x - 4, z.y - 12, 8, 4);
      break;
    case "Necromancer":
      ctx.fillStyle = "#000";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "darkgreen";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 4, 6, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Archer":
      ctx.fillStyle = "#556B2F";
      ctx.fillRect(z.x - 8, z.y - 8, 16, 16);
      ctx.strokeStyle = "brown";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(z.x + 5, z.y - 10);
      ctx.lineTo(z.x + 15, z.y);
      ctx.stroke();
      break;
    case "Sorcerer":
      ctx.fillStyle = "#8A2BE2";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#ffff00";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 5, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Bard":
      ctx.fillStyle = "#DC143C";
      ctx.fillRect(z.x - 8, z.y - 8, 16, 16);
      ctx.fillStyle = "#DAA520";
      ctx.beginPath();
      ctx.arc(z.x, z.y + 8, 6, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Cleric":
      ctx.fillStyle = "#F8F8FF";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "#B22222";
      ctx.fillRect(z.x - 2, z.y - 10, 4, 20);
      break;
    case "Vampire":
      ctx.fillStyle = "#8B0000";
      ctx.beginPath();
      ctx.ellipse(z.x, z.y, 12, 18, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.fillRect(z.x - 2, z.y + 8, 4, 4);
      break;
    case "Werewolf":
      ctx.fillStyle = "#696969";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 16, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "brown";
      ctx.beginPath();
      ctx.moveTo(z.x - 8, z.y - 10);
      ctx.lineTo(z.x - 4, z.y - 16);
      ctx.lineTo(z.x, z.y - 10);
      ctx.fill();
      break;
    case "Goblin":
      ctx.fillStyle = "#3CB371";
      ctx.beginPath();
      ctx.ellipse(z.x, z.y, 10, 15, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#8B4513";
      ctx.beginPath();
      ctx.moveTo(z.x + 6, z.y - 8);
      ctx.lineTo(z.x + 10, z.y - 12);
      ctx.lineTo(z.x + 12, z.y - 8);
      ctx.fill();
      break;
    case "Elf":
      ctx.fillStyle = "#008000";
      ctx.beginPath();
      ctx.ellipse(z.x, z.y, 10, 16, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "lightgoldenrodyellow";
      ctx.beginPath();
      ctx.moveTo(z.x + 8, z.y - 10);
      ctx.lineTo(z.x + 14, z.y - 6);
      ctx.lineTo(z.x + 8, z.y - 2);
      ctx.fill();
      break;
    case "Dwarf":
      ctx.fillStyle = "#A52A2A";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(z.x - 8, z.y + 6, 16, 8);
      break;
    case "Orc":
      ctx.fillStyle = "#4B0082";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 16, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#00FF7F";
      ctx.beginPath();
      ctx.moveTo(z.x + 5, z.y + 5);
      ctx.lineTo(z.x + 10, z.y + 10);
      ctx.lineTo(z.x + 5, z.y + 15);
      ctx.fill();
      break;
    case "Detective":
      ctx.fillStyle = "#4682B4";
      ctx.fillRect(z.x - 8, z.y - 10, 16, 20);
      ctx.fillStyle = "#333";
      ctx.fillRect(z.x - 10, z.y - 12, 20, 4);
      break;
    case "Swat":
      ctx.fillStyle = "#2F4F4F";
      ctx.fillRect(z.x - 12, z.y - 12, 24, 24);
      ctx.fillStyle = "#808080";
      ctx.fillRect(z.x - 4, z.y - 10, 8, 4);
      break;
    case "Firefighter":
      ctx.fillStyle = "#FF4500";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "#8B0000";
      ctx.fillRect(z.x - 4, z.y - 12, 8, 4);
      break;
    case "Doctor":
      ctx.fillStyle = "#ADD8E6";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "red";
      ctx.fillRect(z.x - 8, z.y - 2, 16, 4);
      ctx.fillRect(z.x - 2, z.y - 8, 4, 16);
      break;
      
case "Wastelander":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#A9A9A9";
  ctx.fillRect(z.x - 5, z.y - 2.5, 10, 2.5);
  ctx.fillStyle = "black";
  ctx.fillRect(z.x - 2.5, z.y - 6, 5, 1);
  break;
case "Scavenger":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#D2B48C";
  ctx.fillRect(z.x - 5, z.y + 2.5, 10, 2.5);
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.arc(z.x - 2.5, z.y - 6, 1, 0, Math.PI * 2);
  ctx.arc(z.x + 2.5, z.y - 6, 1, 0, Math.PI * 2);
  ctx.fill();
  break;
case "Hunter":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#6B8E23";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 10);
  ctx.fillStyle = "#8B4513";
  ctx.fillRect(z.x - 2.5, z.y - 10, 5, 5);
  break;
case "Plaguebearer":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#800080";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#FF00FF";
  ctx.fillRect(z.x - 4, z.y, 8, 2.5);
  break;
case "Gravekeeper":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#555";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#000";
  ctx.fillRect(z.x - 5, z.y + 10, 10, 2.5);
  ctx.fillStyle = "white";
  ctx.fillRect(z.x - 2.5, z.y - 7.5, 1, 2.5);
  ctx.fillRect(z.x + 1.5, z.y - 7.5, 1, 2.5);
  break;
case "Revenant":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#ADD8E6";
  ctx.beginPath();
  ctx.arc(z.x - 2.5, z.y - 6, 1, 0, Math.PI * 2);
  ctx.arc(z.x + 2.5, z.y - 6, 1, 0, Math.PI * 2);
  ctx.fill();
  break;
case "Stalker":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#2F4F4F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#B22222";
  ctx.fillRect(z.x - 5, z.y, 10, 2.5);
  ctx.fillStyle = "black";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 6, 2.5, 0, Math.PI * 2);
  ctx.fill();
  break;
case "Abomination":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#FF4500";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#8B0000";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 10);
  ctx.fillRect(z.x, z.y - 10, 2.5, 5);
  break;
case "Wraith":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "rgba(173, 216, 230, 0.7)";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "black";
  ctx.fillRect(z.x - 2.5, z.y - 6, 5, 1);
  break;
case "Butcher":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#DCDCDC";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#B22222";
  ctx.fillRect(z.x - 5, z.y + 2.5, 10, 5);
  ctx.fillStyle = "black";
  ctx.fillRect(z.x - 2.5, z.y - 7.5, 5, 2.5);
  break;
}

// ⚡ Hiệu ứng điện động khi bị stun bởi lôi
if (z.stunnedByThunder && Date.now() < z.stunnedThunderUntil) {
    // Hiệu ứng tia điện động
    ctx.save();
    ctx.strokeStyle = "#00ffff"; // Xanh điện sáng hơn
    ctx.lineWidth = 1;
    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = 8;
    for (let i = 0; i < 2; i++) {
        const angle = Math.random() * Math.PI * 2;
        const r1 = z.radius + 2;
        const r2 = z.radius + 4 + Math.random() * 4;
        ctx.beginPath();
        ctx.moveTo(z.x + Math.cos(angle) * r1, z.y + Math.sin(angle) * r1);
        ctx.lineTo(z.x + Math.cos(angle) * r2, z.y + Math.sin(angle) * r2);
        ctx.stroke();
    }
    ctx.restore();
}

// 🔥 Hiệu ứng lửa động khi bị trúng lửa
if (z.onFireUntil && Date.now() < z.onFireUntil) {
    ctx.save();
    // Lớp sáng cam phủ ngoài (chỉ 1 lần shadowBlur)
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    ctx.arc(z.x, z.y, z.radius + 2, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(255,120,0,0.25)";
    ctx.shadowColor = "orange";
    ctx.shadowBlur = 8;
    ctx.fill();
    ctx.shadowBlur = 0;

    // Vẽ 2 ngọn lửa động (fill, không blur)
    for (let i = 0; i < 2; i++) {
        const angle = (Math.PI * 2 / 2) * i + frame / 15;
        const len = 10 + Math.sin(frame / 7 + i + frame / 10) * 3;
        ctx.save();
        ctx.translate(z.x + Math.cos(angle) * (z.radius - 2), z.y + Math.sin(angle) * (z.radius - 2));
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(2, -len / 2, 0, -len);
        ctx.quadraticCurveTo(-2, -len / 2, 0, 0);
        ctx.fillStyle = "rgba(255,140,0,0.85)";
        ctx.globalAlpha = 0.8;
        ctx.fill();
        ctx.restore();
    }
    ctx.restore();
}

// ❄️ Hiệu ứng băng động khi bị trúng băng
if (z.onIceUntil && Date.now() < z.onIceUntil) {
    ctx.save();
    // Lớp băng phủ ngoài (chỉ 1 lần shadowBlur)
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.arc(z.x, z.y, z.radius + 2, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(180,220,255,0.45)";
    ctx.shadowColor = "#b3e0ff";
    ctx.shadowBlur = 8;
    ctx.fill();
    ctx.shadowBlur = 0;

    // Vẽ 2 tinh thể băng nhỏ (fill, không blur)
    for (let i = 0; i < 2; i++) {
        const angle = (Math.PI * 2 / 2) * i + frame / 30;
        const len = 7 + Math.sin(frame / 8 + i) * 1.5;
        ctx.save();
        ctx.translate(z.x + Math.cos(angle) * (z.radius + 4), z.y + Math.sin(angle) * (z.radius + 4));
        ctx.rotate(angle + frame / 40);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(2, -len / 2);
        ctx.lineTo(0, -len);
        ctx.lineTo(-2, -len / 2);
        ctx.closePath();
        ctx.fillStyle = "#e0f7fa";
        ctx.globalAlpha = 0.7;
        ctx.fill();
        ctx.restore();
    }
    ctx.restore();
}
// --- Vẽ chữ hiệu ứng trên đầu zombie ---
let yOffset = 0;

// Vẽ chữ "CHOÁNG"
if (z.stunnedByThunder && Date.now() < z.stunnedThunderUntil) {
    ctx.save();
    ctx.font = "0.8rem Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.fillStyle = "#00ffff";
    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = 12;
    ctx.globalAlpha = 0.92;
    ctx.fillText("Choáng", z.x, z.y - z.radius - 18 - yOffset);
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
    ctx.restore();
    yOffset += 20;
}

// Vẽ chữ "Cháy"
if (z.burnEndTime && Date.now() < z.burnEndTime) {
    ctx.save();
    ctx.font = "0.8rem Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.fillStyle = "orange";
    ctx.shadowColor = "red";
    ctx.shadowBlur = 10;
    ctx.fillText("Cháy", z.x, z.y - z.radius - 18 - yOffset);
    ctx.restore();
    yOffset += 20;
}
// Vẽ chữ "Cháy" cho burn từ vũ khí
if (z.weaponBurnUntil && now < z.weaponBurnUntil) {
  ctx.save();
  ctx.font = "0.8rem Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillStyle = "orange";
  ctx.shadowColor = "red";
  ctx.shadowBlur = 10;
  ctx.fillText("Cháy", z.x, z.y - z.radius - 18 - (yOffset || 0));
  ctx.restore();
  yOffset = (yOffset || 0) + 20;
}

// Vẽ chữ "Chậm"
if (z.slowEndTime && Date.now() < z.slowEndTime) {
    ctx.save();
    ctx.font = "0.8rem Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.fillStyle = "#87ceeb";
    ctx.shadowColor = "blue";
    ctx.shadowBlur = 10;
    ctx.fillText("Chậm", z.x, z.y - z.radius - 18 - yOffset);
    ctx.restore();
    yOffset += 20;
}
// Burn từ SPECIAL vũ khí
if (z.weaponBurnUntil && now < z.weaponBurnUntil) {
  if (!z._wburnTick || now - z._wburnTick >= 1000) {
    z._wburnTick = now;
    const d = Math.max(1, Math.round((playerUpgrades.damageBoost || 1) * (z.weaponBurnDpsMul || 0.15)));
    dealDamageToZombie(z, d);
  }
} else if (z.weaponBurnUntil && now >= z.weaponBurnUntil) {
  z.weaponBurnUntil = 0; z._wburnTick = 0;
}

drawZombieNameAndHP(ctx, z);
// Vẽ tên zombie bên dưới
// Chọn màu chữ: nếu là Tinh Anh thì màu đỏ, không thì màu trắng
ctx.fillStyle = z.isElite ? "#ff4c4c" : "#fff"; 
ctx.font = "12px Arial";
ctx.textAlign = "center";
ctx.shadowBlur = 0;
/*ctx.fillText(z.style || 'Normal', z.x, z.y + z.radius + 16); // Vẽ tên zombie bên dưới*/

// === 🆕 fillText gộp toàn bộ thông tin ===
ctx.save();

// 🧠 Font chung
ctx.fillStyle = "#fff";
ctx.textAlign = "center";
ctx.textBaseline = "middle";

/*// 🅰️ Vẽ cấp + HP trên đầu zombie
let levelChar = "";
if (z.isBoss) levelChar = "SS";
else if (z.type === "miniBoss") levelChar = "S";
else levelChar = String.fromCharCode(96 + (z.level || 1));

// ✨ Giảm kích thước font nếu là boss hoặc mini boss
let levelFontSize = z.radius * 0.9; // mặc định cho zombie thường
if (z.type === "miniBoss") levelFontSize = z.radius * 0.6;
if (z.isBoss) levelFontSize = z.radius * 0.5;

ctx.font = `${levelFontSize}px sans-serif`;
ctx.textAlign = "center";
ctx.textBaseline = "middle"; // Vị trí icon zombie
ctx.fillStyle = z.color || "#fff";
// 1. Tạo chuỗi HP cơ bản
let hpText = `${levelChar}-${z.hp}`;
// 2. Nếu zombie vừa được buff, thêm dấu "+" vào chuỗi
if (z.isBuffed) {
    hpText += "*";
}
// 3. Vẽ chuỗi text cuối cùng lên màn hình
ctx.fillText(hpText, z.x, z.y - z.radius - 8);*/

// 🧟 Vẽ icon zombie ở giữa thân
ctx.font = `${z.radius * 1.5}px sans-serif`;
const iconChar = z.isBoss ? "💀" : "";
ctx.fillText(iconChar, z.x, z.y);

// 😴 Trạng thái (chỉ zombie thường & có icon)
// 🎯 Hiển thị icon hành vi: 😡 khi chasing, 😫/💤Zzz khi wandering (30%)
let behaviorIcon = null;
// Boss sẽ không có icon trạng thái
if (!z.isBoss && z.state === "chasing" && z.showStatusIcon) {
  behaviorIcon = "😡";
} else if (!z.isBoss && z.type !== "miniBoss" && z.state === "wandering") {
  const isSleeping = z.wanderBehavior === "pause";

  // 💤 Đang lang thang & đứng im
  if (isSleeping && isNight()) {
    behaviorIcon = "💤"; // 💯 luôn hiển thị khi ban đêm
  } else if (z.showStatusIcon) {
    behaviorIcon = isSleeping ? "💤" : "😫"; // Ngày thường theo 30%
  }
}
    // Vẽ icon Suy yếu nếu có
if (z.isWeakened && Date.now() < z.weakenEndTime) {
  ctx.font = `${z.radius * 0.8}px sans-serif`; // nhỏ hơn
  ctx.textAlign = "center";                     // canh giữa
  ctx.textBaseline = "top";
  ctx.fillStyle = "#ff4c4c";
  ctx.fillText("weaken", z.x, z.y - z.radius * 3); // ngay trên đầu
}

if (behaviorIcon) {
  ctx.font = `${z.radius}px sans-serif`;
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillStyle = "#fff";
  ctx.fillText(behaviorIcon, z.x + z.radius * 0.6, z.y - z.radius * 1.2);
}
ctx.restore();

  // 💬 Biểu cảm (chỉ zombie thường mới có)
  if (!z.isBoss && z.iconToDraw) {
    ctx.save();
    ctx.font = `${z.radius}px sans-serif`;
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillStyle = "#fff";
    ctx.fillText(z.iconToDraw, z.x + z.radius * 0.6, z.y - z.radius * 1.2);
    ctx.restore();
}
});

// Vẽ lớp khiên nếu đang hoạt động
function drawHex3D(ctx, x, y, size) {
  const gradient = ctx.createRadialGradient(x, y, size * 0.3, x, y, size);
  gradient.addColorStop(0, "rgba(0,255,255,0.25)");
  gradient.addColorStop(1, "rgba(0,200,255,0.05)");

  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    const angle = Math.PI / 3 * i;
    const px = x + size * Math.cos(angle);
    const py = y + size * Math.sin(angle);
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fillStyle = gradient;
  ctx.strokeStyle = "rgba(0,255,255,0.1)";
  ctx.lineWidth = 0.8;
  ctx.fill();
  ctx.stroke();
}

if (player.shieldActive) {
// Vòng tròn ngoài cùng
  const pulse = Math.sin(Date.now() / 200) * 2;
  ctx.save();
  ctx.globalAlpha = 0.6;
  ctx.beginPath();
  ctx.arc(player.x, player.y, 48 + pulse, 0, Math.PI * 2);
  ctx.strokeStyle = "rgba(0,200,255,0.7)";
  ctx.lineWidth = 4;
  ctx.shadowColor = "#00eaff";
  ctx.shadowBlur = 10;
  ctx.stroke();
  ctx.restore();

// Vẽ mạng lưới lục giác đều trong khiên
const hexSize = 10;
const spacingX = hexSize * Math.sqrt(3);
const spacingY = hexSize * 1.5;
const radius = 45;
const angleOffset = Date.now() / 3000; // Góc xoay theo thời gian

for (let row = -5; row <= 5; row++) {
  for (let col = -5; col <= 5; col++) {
    const offsetX = (row % 2 === 0) ? 0 : spacingX / 2;
    const x0 = col * spacingX + offsetX;
    const y0 = row * spacingY;

    const dx = x0;
    const dy = y0;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < radius) {
// 👉 Xoay điểm quanh tâm player
      const angle = angleOffset;
      const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
      const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);
      const px = player.x + rotatedX;
      const py = player.y + rotatedY;
      drawHex3D(ctx, px, py, hexSize);
}
}
}
}

// Vẽ vệ tinh laze 🛰️
satellites.forEach(sat => {
  ctx.save();
  ctx.translate(sat.x, sat.y);
  ctx.shadowBlur = 10;
  ctx.shadowColor = "cyan";
  ctx.fillStyle = "white";
  ctx.font = "1.2rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("🛰️", 0, 0);
  ctx.restore();
});

explosions.forEach(e => {
  ctx.beginPath();
  ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
  ctx.fillStyle = `rgba(255, 200, 0, ${e.life / 20})`;
  ctx.fill();
});
// Vẽ tia laze cho từng vệ tinh
satellites.forEach(sat => {
  if (sat.laserBeam && sat.laserBeam.life > 0) {
    const x1 = sat.x, y1 = sat.y;
    const angle = sat.laserBeam.angle;
    const x2 = x1 + Math.cos(angle) * 500;
    const y2 = y1 + Math.sin(angle) * 500;

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = "rgba(0, 255, 255, 0.8)";
    ctx.lineWidth = 3;
    ctx.shadowColor = "cyan";
    ctx.shadowBlur = 12;
    ctx.stroke();
    ctx.restore();
  }
});
// Vẽ UFO
if (ufoActive) {
ufos.forEach(ufo => {
    // Logic kiểm tra và đổi hướng bay
    if (Date.now() > ufo.nextDirectionChangeTime) {
        // Hết giờ, tạo tốc độ ngẫu nhiên mới
        ufo.speedX = (Math.random() - 0.5) * 2;
        ufo.speedY = (Math.random() - 0.5) * 0.5;

        // Đặt lại mốc thời gian cho lần đổi hướng tiếp theo
        ufo.nextDirectionChangeTime = Date.now() + ufo.directionChangeInterval;
    }

    // --- Di chuyển UFO ---
    ufo.relativeX += ufo.speedX;
    ufo.relativeY += ufo.speedY;

        // --- Giữ UFO trong khung hình (hiệu ứng "dội tường") ---
        // Dội cạnh trái/phải
        if (ufo.relativeX < 0 || ufo.relativeX > canvas.width) {
            ufo.speedX *= -1;
        }
        // Dội cạnh trên/dưới (trong một khoảng giới hạn)
        if (ufo.relativeY < 120 || ufo.relativeY > 360) {
            ufo.speedY *= -1;
        }

        // --- Logic tấn công ---
        if (Date.now() > ufo.laserCooldown) {
            // Tọa độ thực của UFO trên bản đồ
            const ufoWorldX = camera.x + ufo.relativeX;
            const ufoWorldY = camera.y + ufo.relativeY;
            
            // Tìm zombie gần nhất để bắn
            const target = zombies.find(z => z.active && distance({x: ufoWorldX, y: ufoWorldY}, z) < 400);

            if (target) {
              playSound('sfx-laser', 0.5);
                const angle = Math.atan2(target.y - ufoWorldY, target.x - ufoWorldX);
                ufo.angle = angle; // Lưu góc bắn để vẽ tia laser
                ufo.laserLife = 30; // Tia laser tồn tại trong 0.5 giây

                // Gây sát thương cho tất cả zombie trên đường bắn
                zombies.forEach(z => {
                    if (!z.active) return;
                    const dx = Math.cos(angle), dy = Math.sin(angle);
                    const proj = (z.x - ufoWorldX) * dx + (z.y - ufoWorldY) * dy;
                    const perp = Math.abs((z.x - ufoWorldX) * dy - (z.y - ufoWorldY) * dx);
                    if (proj > 0 && proj < 1200 && perp < 20) {
                        dealDamageToZombie(z, ufo.damage);
                    }
                });
            }
            // Đặt lại thời gian hồi chiêu
            ufo.laserCooldown = Date.now() + 1500; // Bắn mỗi 1.5 giây
        }
        
        if (ufo.laserLife > 0) ufo.laserLife--;
    });
}
ufos.forEach(ufo => {
    // Tính toán tọa độ vẽ thực tế dựa trên camera và vị trí tương đối
    const drawX = camera.x + ufo.relativeX;
    const drawY = camera.y + ufo.relativeY;

    // UFO icon
    ctx.save();
    ctx.translate(drawX, drawY); // <-- Dùng tọa độ mới
    ctx.shadowBlur = 10;
    ctx.shadowColor = "red";
    ctx.fillStyle = "white";
    ctx.font = "1.4rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("🛸", 0, 0);
    ctx.restore();

    // Tia laser đỏ
    if (ufo.laserLife > 0) {
        const x1 = drawX; // <-- Dùng tọa độ mới
        const y1 = drawY; // <-- Dùng tọa độ mới
        const laserLength = 1200;
        const x2 = x1 + Math.cos(ufo.angle) * laserLength;
        const y2 = y1 + Math.sin(ufo.angle) * laserLength;

        ctx.save();
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = "rgba(255, 0, 0, 0.8)";
        ctx.lineWidth = 3;
        ctx.shadowColor = "red";
        ctx.shadowBlur = 15;
        ctx.stroke();
        ctx.restore();
    }
});
// Vẽ các vòng nổ phụ của bom hạt nhân
extraShockwaves.forEach(sw => {
  ctx.save();
  ctx.beginPath();
  ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2);
  ctx.strokeStyle = sw.color;
  ctx.globalAlpha = sw.alpha;
  ctx.lineWidth = 3;
  ctx.shadowColor = sw.color;
  ctx.shadowBlur = 12;
  ctx.stroke();
  ctx.restore();
});

drawItems();
drawSupplyDrops();
drawEffects();
window.EquipmentDropAPI && EquipmentDropAPI.drawEquipDrops(ctx);

// 🎨 Vẽ vật phẩm hiện có trên màn hình
function drawItems() {
  items.forEach(it => {
    if (!it.active) return;
    ctx.save();

    // Cài đặt font chữ và căn chỉnh cho vật phẩm
    ctx.font = "0.9rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    let icon, color;

    // Chọn icon và màu sắc phù hợp với từng vật phẩm
    switch (it.type) {
      case 'potion':
        icon = "💊";
        color = "red";
        break;
      case 'lucky':
        icon = "🍀";
        color = "#22c55e";
        break;
      case 'power':
        icon = "🍁";
        color = "#ef4444";
        break;
      case 'crazy': 
        icon = "🍂";
        color = "#f59e0b";
        break;
      case 'exp': 
        icon = "🌿";
        color = "#ffeb3b";
        break;
      case 'magnet':
        icon = "🧲";
        color = "#8b5cf6"; // Màu tím
        break;
      case 'secret':
        icon = "❓";
        color = "#ffeb3b"; // Màu vàng
        break;
      case 'expBonus':
        icon = "🌟";
        color = "#ffeb3b"; // Màu vàng
        break;
      case 'crazymadnesstime':
        icon = "💢";
        color = "#0613c5"; // Màu xanh dương đồng bộ với halo và UI
        break;
      case 'critRateBuff':
        icon = "✨";
        color = "orange";
        break;
      case 'critDmgBuff':
        icon = "💥";
        color = "#c084fc"; // Dùng màu tím nhạt giống màu hào quang
        break;
      case 'coin':
        icon = "🪙";
        color = "gold";
        break;
      case 'energy':
        icon = "⚡";
        color = "gold";
        break;
      case 'mana':
        icon = "💠";
        color = "cyan";
        break;
      case 'hp':
        icon = "❤️";
        color = "red";
        break;
      case 'box':
        icon = "📦";
        color = "#fff";
        break;
    }

    // Tạo hiệu ứng nhẹ (bóng đổ và chuyển động nhẹ nhàng)
    if (icon) {
        ctx.shadowBlur = 3;
        ctx.shadowColor = color;
        ctx.fillStyle = color;
        const bob = Math.sin(frame / 10 + it.x + it.y) * 1; // Hiệu ứng bobbing nhẹ
        ctx.fillText(icon, it.x, it.y + bob);
    }
    ctx.restore();
  });
}
// 🌩️ Vẽ tia sét
function drawLightningBolts() {
    // Chỉ chạy nếu một trong hai kỹ năng (Bão sét hoặc Lôi) đang hoạt động
    if (!lightningActive && !thunderActive) return;
    
    ctx.save();
    
    // Vẽ các đám mây của Bão sét (nếu có)
    if (lightningActive) {
        lightningBolts.forEach(bolt => {
            ctx.font = "2rem serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "yellow";
            ctx.shadowColor = "gold";
            ctx.shadowBlur = 8;
            ctx.fillText("🌩️", bolt.x, bolt.y);
        });
    }

    // Vẽ các tia sét đang hoạt động (cho cả hai kỹ năng)
    activeLightningStrikes.forEach(strike => {
        if (strike.type === 'chain') {
            const path = strike.path;
            const alpha = strike.life / 30;
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.lineWidth = 1.5;
            ctx.shadowColor = "white";
            ctx.shadowBlur = 10;
            ctx.stroke();
        } else {
            // --- Vẽ SÉT CHÍNH (vàng, dày, từ trên trời) ---
            const path = strike.path;
            if (path.length < 2) return;
            const endPoint = path[path.length - 1];
            const alpha = strike.life / 60;

            if (strike.life > 35) { 
                ctx.beginPath();
                ctx.arc(endPoint.x, endPoint.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 200, ${alpha * 0.8})`;
                ctx.shadowColor = "yellow"; ctx.shadowBlur = 20;
                ctx.fill(); ctx.shadowBlur = 0;
            }
            
            ctx.shadowColor = "yellow"; ctx.shadowBlur = 20;
            for (let i = 1; i < path.length; i++) {
                const p = i / (path.length - 1);
                const lw = 4 * (1 - p);
                ctx.beginPath();
                ctx.moveTo(path[i-1].x, path[i-1].y);
                ctx.lineTo(path[i].x, path[i].y);
                ctx.strokeStyle = `rgba(255, 255, 0, ${alpha * 0.6})`;
                ctx.lineWidth = lw;
                ctx.stroke();
            }
            
            ctx.shadowBlur = 0;
            for (let i = 1; i < path.length; i++) {
                const p = i / (path.length - 1);
                const lw = 1.5 * (1 - p);
                ctx.beginPath();
                ctx.moveTo(path[i-1].x, path[i-1].y);
                ctx.lineTo(path[i].x, path[i].y);
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.lineWidth = lw;
                ctx.stroke();
            }
        }
    });

    ctx.restore();
}

function drawBlackHole() {
    let sumY = 0;
    let planeCount = 0;
    const BLACK_HOLE_X = worldWidth - 100;
    const FILTER_X = worldWidth - 200;
    // Duyệt qua một lần để vừa lọc máy bay vừa tính tổng vị trí Y
    for (const p of activePlanes) {
        if (p.x > FILTER_X) {
            sumY += p.y;
            planeCount++;
        }
    }
    // ❌ Không có máy bay nào gần hố đen thì không vẽ
    if (planeCount === 0) return;
    // 🎯 Tính trung bình độ cao
    const blackHoleY = sumY / planeCount;
    // 🔵 Hiệu ứng phồng nhẹ
    const pulse = Math.sin(Date.now() / 300);
    const radius = 40 + pulse * 5;
    // 🎨 Vẽ hố đen
    ctx.save();
    ctx.beginPath();
    ctx.arc(BLACK_HOLE_X, blackHoleY, radius, 0, Math.PI * 2);
    ctx.fillStyle = "black";
    ctx.shadowColor = "purple";
    ctx.shadowBlur = 20;
    ctx.fill();
    ctx.restore();
}
if (petRabbit && petActive) {
  const { x, y, radius } = petRabbit;

  /* — thân — */
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fillStyle   = "#fff0fa";   // thân trắng-hồng
  ctx.fill();
  ctx.strokeStyle = "#ff7ad9";   // viền hồng nhạt
  ctx.lineWidth   = 2;
  ctx.stroke();

  /* — tai — */
  ctx.beginPath();
  ctx.ellipse(x - 6, y - 18, 3, 6, 0, 0, Math.PI * 2);
  ctx.ellipse(x + 6, y - 18, 3, 6, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  /* — mắt — */
  ctx.beginPath();
  ctx.arc(x - 4, y - 3, 1.5, 0, Math.PI * 2);
  ctx.arc(x + 4, y - 3, 1.5, 0, Math.PI * 2);
  ctx.fillStyle = "#000";
  ctx.fill();

  /* — miệng — */
  ctx.beginPath();
  ctx.arc(x, y + 4, 2, 0, Math.PI);
  ctx.strokeStyle = "#000";
  ctx.stroke();

  /* — tên “Thỏ” — */
  ctx.font         = "0.8rem sans-serif";
  ctx.fillStyle    = "#ff7ad9";   // cùng màu viền
  ctx.shadowColor  = "#ff7ad9";
  ctx.shadowBlur   = 8;
  ctx.textAlign    = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText("Thỏ", x, y - radius - 10);
  ctx.shadowBlur   = 0;
  ctx.shadowColor  = "transparent";
}

// ================== VẼ CỔNG KHÔNG GIAN ==================
if (spaceGateActive && spaceGate && spaceGate.radius > 0.1) { // Sử dụng radius > 0.1
    ctx.save();
    // Áp dụng hiệu ứng mờ dần khi cổng mới xuất hiện
    ctx.globalAlpha = spaceGate.alpha;

    const x = spaceGate.x;
    const y = spaceGate.y;
    const radius = spaceGate.radius;

    // Lớp hào quang bên ngoài
// Lớp hào quang bên ngoài
const pulse = Math.sin(frame * 0.1) * 5;
ctx.beginPath();
// ✨ SỬA LỖI: Dùng Math.max để đảm bảo bán kính không bao giờ âm
ctx.arc(x, y, Math.max(0, radius + pulse), 0, Math.PI * 2); 
ctx.fillStyle = `rgba(255, 100, 0, 0.2)`;
ctx.fill();

    // Vòng xoáy lửa trung tâm
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
    gradient.addColorStop(0, 'rgba(255, 255, 180, 0.9)');
    gradient.addColorStop(0.5, 'rgba(255, 180, 0, 0.8)');
    gradient.addColorStop(1, 'rgba(200, 50, 0, 0.5)');
    
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.fill();

    // Viền ngoài phát sáng
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.strokeStyle = "gold";
    ctx.lineWidth = 3;
    ctx.shadowColor = "orange";
    ctx.shadowBlur = 15;
    ctx.stroke();

    // Các tia lửa xoáy bên trong
    ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
    ctx.lineWidth = 1.5;
    ctx.shadowColor = "yellow";
    ctx.shadowBlur = 15;
    for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        const startAngle = spaceGate.rotation + (i * Math.PI / 2);
        const endAngle = startAngle + Math.PI * 0.8;
        ctx.arc(x, y, radius * (0.3 + (i * 0.15)), startAngle, endAngle);
        ctx.stroke();
    }
    
    ctx.restore();
}

// Đoạn này xử lý việc làm mờ người chơi khi dịch chuyển, giữ nguyên
if (playerTeleportState.isTeleporting || playerTeleportState.alpha < 1) {
    ctx.save();
    ctx.globalAlpha = playerTeleportState.alpha;
}

drawParticles(ctx);

drawBloodOrb(ctx);
drawBlackHole();
drawLightningBolts(); // 🌩️ Vẽ tia sét
updateAndDrawHealEffects();
ctx.restore(); // kết thúc dịch chuyển camera
drawMiniMap();
// 🎨 Vẽ bản đồ thu nhỏ
}
/**
 * THÊM MỚI: Hàm vẽ thanh HP cho người chơi.
 * @param {CanvasRenderingContext2D} ctx - Bối cảnh vẽ của canvas.
 */
function drawPlayerHealthBar(ctx) {
    // Không cần vẽ nếu không có máu hoặc máu tối đa
    if (player.hearts <= 0 || !player.maxHearts) {
        return;
    }

    // 1. Tính toán các giá trị cần thiết
    const hpPercent = player.hearts / player.maxHearts;
    const barWidth = 50; // Chiều rộng thanh máu
    const barHeight = 3; // Chiều cao thanh máu
    const barX = player.x - barWidth / 2;
    const barY = player.y + player.size + 5;

    // 2. Chọn màu cho thanh máu dựa trên tỷ lệ HP
    let barColor;
    if (hpPercent < 0.25) {
        barColor = '#ff4c4c'; // Đỏ khi dưới 25%
    } else if (hpPercent < 0.75) {
        barColor = '#ffcc00'; // Vàng khi từ 25% - 75%
    } else {
        barColor = '#00ff00'; // Xanh lá khi đầy máu
    }

    // 3. Bắt đầu vẽ
    ctx.save();

    // Vẽ phần nền (màu xám, thể hiện lượng máu đã mất)
    ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
    ctx.fillRect(barX, barY, barWidth, barHeight);

    // Vẽ phần máu hiện tại (có màu)
    ctx.fillStyle = barColor;
    ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);

    // (Tùy chọn) Có thể thêm viền mỏng để thanh máu nổi bật hơn
    // ctx.strokeStyle = '#000';
    // ctx.lineWidth = 1;
    // ctx.strokeRect(barX, barY, barWidth, barHeight);

    ctx.restore();
}
function drawPlayerStaminaBar(ctx) {
    if (player.stamina < 0 || !player.staminaMax) {
        return;
    }

    const staminaPercent = player.stamina / player.staminaMax;
    const barWidth = 50;
    const barHeight = 3;
    const barX = player.x - barWidth / 2;
    // Tọa độ Y của thanh stamina, cách thanh HP một khoảng cố định
    const barY = player.y + player.size + 5 + 3; // 3 là chiều cao của thanh HP

    // Vẽ nền thanh stamina
    ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
    ctx.fillRect(barX, barY, barWidth, barHeight);

    // Vẽ phần stamina hiện tại
    const staminaColor = '#36a2eb'; // Màu xanh dương
    ctx.fillStyle = staminaColor;
    ctx.fillRect(barX, barY, barWidth * staminaPercent, barHeight);
}
// Vẽ tên và thanh HP của zombie
function drawZombieNameAndHP(ctx, z) {
  // ====== TÊN + LEVEL TRÊN ĐẦU ======
  const lvl = (z.level ?? 1);
  const name = `${z.style || 'Zombie'} Lv${lvl}`;
  ctx.save();
  ctx.font = `${Math.max(11, Math.floor(z.radius * 0.8))}px Arial`;
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillStyle = z.isElite ? "#ff4c4c" : "#fff";
  ctx.shadowColor = z.isElite ? "#ff4c4c" : "transparent";
  ctx.shadowBlur = z.isElite ? 6 : 0;
  ctx.fillText(name, z.x, z.y - z.radius - 4);
  ctx.restore();

  // ====== THANH HP DƯỚI CHÂN ======
  const maxHp = z.baseHp || z.maxHp || z.hp || 1;
  const pct   = Math.max(0, Math.min(1, z.hp / maxHp));

  const barW = Math.max(28, Math.min(64, Math.floor(z.radius * 2))); // Giới hạn chiều rộng
  const barH = Math.max(4,  Math.floor(z.radius * 0.3)); // Chiều cao thanh máu
  const barX = Math.round(z.x - barW / 2);
  const barY = Math.round(z.y + z.radius + 4);

  ctx.save();
  // viền ngoài mờ nhẹ
  ctx.fillStyle = "rgba(255,255,255,0.15)";
  ctx.fillRect(barX, barY, barW, barH);

  // nền trong
  ctx.fillStyle = "rgba(0,0,0,0.4)";
  ctx.fillRect(barX + 1, barY + 1, barW - 2, barH - 2);

  // màu theo % máu
  let color;
  if (pct > 0.6) color = "#a855f7"; // tím (violet-500)
  else if (pct > 0.3) color = "#ffca28";
  else color = "#f44336";

  const fillW = Math.max(0, Math.round((barW - 2) * pct));
  ctx.fillStyle = color;
  ctx.fillRect(barX + 1, barY + 1, fillW, barH - 2);

  // highlight mỏng trên đỉnh thanh để giống player
  ctx.fillStyle = "rgba(255,255,255,0.12)";
  ctx.fillRect(barX + 1, barY + 1, fillW, 1);

  // viền mảnh
  ctx.strokeStyle = "rgba(255,255,255,0.2)";
  ctx.lineWidth = 1;
  ctx.strokeRect(barX + 0.5, barY + 0.5, barW - 1, barH - 1);
  ctx.restore();
}

// 🎨 Vẽ tất cả hiệu ứng kỹ năng gọn lại
function drawEffects() {
  // === VẼ ĐÁM MÂY CỦA MƯA KIẾM ===
    swordRainClouds.forEach(cloud => {
        ctx.save();
        // Vị trí vẽ = vị trí camera + vị trí tương đối của mây
        const drawX = camera.x + cloud.relativeX;
        const drawY = camera.y + cloud.relativeY;
        
        ctx.font = "2rem serif";
        ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
        ctx.shadowColor = "rgba(0, 0, 0, 0.3)";
        ctx.shadowBlur = 2;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("☁️", drawX, drawY);
        ctx.restore();
    });
    // vẽ các Fairy
    fairies.forEach(fairy => {
        ctx.save();
        ctx.font = "1.2rem serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "cyan";
        ctx.shadowBlur = 8;
        ctx.fillStyle = 'white'; 
        ctx.fillText("🦋", fairy.x, fairy.y);
        ctx.restore();
    });
    
  fireballs.forEach(f => {
    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.shadowBlur = 8;
    ctx.shadowColor = "orange";
    ctx.fillStyle = "orange";
    ctx.font = "1.3rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("🔥", 0, 0);
    ctx.restore();
  });

  iceballs.forEach(f => {
    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.shadowBlur = 8;
    ctx.shadowColor = "#00e5ff";
    ctx.fillStyle = "#00e5ff";
    ctx.font = "1.3rem serif";
// ctx.font = (f.radius * 0.9) + " serif"; Kỹ năng to ra khi lên level
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("❄️", 0, 0);
    ctx.restore();
  });
// Vẽ quả cầu lôi
if (thunderActive) {
  thunderBalls.forEach(f => {
    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.shadowBlur = 8;
    ctx.shadowColor = "#00e5ff";
    ctx.fillStyle = "#00e5ff";
    ctx.font = "1rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("🔵", 0, 0);
    // Hiệu ứng điện xung quanh
    for (let i = 0; i < 6; i++) {
      const angle = (Math.PI * 2 / 6) * i + frame / 10;
      ctx.beginPath();
      ctx.arc(Math.cos(angle) * 12, Math.sin(angle) * 12, 2, 0, Math.PI * 2);
      ctx.fillStyle = "#b3f0ff";
      ctx.fill();
    }
    ctx.restore();
  });
}

swords.forEach(s => {
    ctx.save();
    ctx.translate(s.x, s.y);
    if (s.state === 'charging') {
  ctx.shadowBlur = 8; // Hiệu ứng bóng mờ
  ctx.shadowColor = '#00ffff';
  ctx.fillStyle = '#00ffff';
} else {
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'white';
}
    ctx.font = "1.2rem serif";
//ctx.font = (s.radius * 0.9) + " serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("🔪", 0, 0);
    ctx.restore();
  });

downwardSwords.forEach(s => {
  ctx.save();
  ctx.translate(s.x, s.y);
  ctx.shadowBlur = 8;
  ctx.shadowColor = '#00ffff';
  ctx.fillStyle = 'white';
  ctx.font = "1.2rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("⚔️", 0, 0);
  ctx.restore();
});
// Vẽ tên lửa
missiles.forEach(m => {
  ctx.save();
  ctx.translate(m.x, m.y);
  ctx.shadowColor = m.state === "delay" ? "gray" : "orange";
  ctx.shadowBlur = 8;
  ctx.fillStyle = "white";
  ctx.font = "1.3rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("🚀", 0, 0);
  ctx.restore();
});

// 💣 B52 Bombs + 🛬 Máy bay
ctx.save();
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.font = "1.3rem serif";
ctx.shadowBlur = 8;
ctx.shadowColor = "black";

// 🛬 Vẽ máy bay đang hoạt động
activePlanes.forEach(plane => {
  ctx.fillStyle = "cyan";
ctx.save();
  ctx.shadowBlur = 4;
  ctx.shadowColor = "cyan";
ctx.translate(plane.x, plane.y);
ctx.scale(plane.scale ?? 1, plane.scale ?? 1);
ctx.globalAlpha = plane.opacity ?? 1;
ctx.fillText("🛬", 0, 0);
ctx.restore();
});

// 💣 Vẽ từng quả bom đang rơi hoặc sắp nổ
bombsB52.forEach(bomb => {
  if (bomb.exploded) return;
  ctx.fillStyle = bomb.landed ? "orange" : "white";
  ctx.fillText("💣", bomb.x, bomb.y);
});

ctx.restore();
// ☢️ Vẽ bom hạt nhân
nuclearBombs.forEach(bomb => {
// ----------- Vẽ bom hạt nhân khi chưa nổ -----------
if (!bomb.exploded) {
  let offsetX = 0, offsetY = 0;

  // 🔔 Nếu còn ≤ 3 giây và đã chạm đất → rung lắc
  if (bomb.landed && bomb.timerAfterLand <= 180) {
    offsetX = (Math.random() - 0.5) * 4;
    offsetY = (Math.random() - 0.5) * 4;
  }

  ctx.save();
  // Vẽ icon bom ☢️ to, sáng (có rung)
  ctx.font = "2.2rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.shadowBlur = 12;
  ctx.shadowColor = "orange";
  ctx.fillStyle = "white";
  ctx.fillText("☢️", bomb.x + offsetX, bomb.y + offsetY);

  // -- Nếu đã chạm đất, vẽ icon 💥 và giây countdown nằm ngang --
  if (bomb.landed) {
    const baseY = bomb.y - 35;
    const iconX = bomb.x - 1;
    const secX  = bomb.x + 1;

    // Vẽ icon 💥 nhỏ
    ctx.font = "1rem serif";
    ctx.shadowBlur = 2;
    ctx.textAlign = "right";
    ctx.fillStyle = "#ffb300";
    ctx.fillText("💥", iconX, baseY);

    // Vẽ số giây nhỏ, màu đỏ
    ctx.font = "1rem sans-serif";
    ctx.fillStyle = "#ff3333";
    ctx.textAlign = "left";
    let sec = Math.max(1, Math.ceil(bomb.timerAfterLand / 60));
    ctx.fillText(`${sec}`, secX, baseY - 2);
  }

  ctx.restore();
}

// ----------- Vẽ hiệu ứng sóng xung kích khi bom phát nổ -----------
if (bomb.exploded && bomb.shockwave) {
// Hiệu ứng vòng nổ chính – nét to, vàng đậm rõ ràng
  ctx.save();
  ctx.beginPath();
  ctx.arc(bomb.x, bomb.y, bomb.shockwaveRadius, 0, Math.PI * 2);
  ctx.strokeStyle = "rgba(255, 222, 44, 0.88)";   // Vàng tươi, gần như vàng nguyên chất
  ctx.lineWidth = 16;
  ctx.shadowBlur = 20;
  ctx.shadowColor = "#ffec70";
  ctx.globalAlpha = 0.58; // Đậm và rõ
  ctx.stroke();
  ctx.restore();

  // Viền ngoài phụ - vàng trắng, rõ hơn, tạo cảm giác “hào quang”
  ctx.save();
  ctx.beginPath();
  ctx.arc(bomb.x, bomb.y, bomb.shockwaveRadius + 8, 0, Math.PI * 2);
  ctx.strokeStyle = "rgba(255,255,180,0.73)";
  ctx.lineWidth = 7;
  ctx.shadowBlur = 20;
  ctx.shadowColor = "#fffbe2";
  ctx.globalAlpha = 0.45;
  ctx.stroke();
  ctx.restore();
}
});
blackHoles.forEach(h => {
  ctx.save();
  ctx.beginPath();
  ctx.arc(h.x, h.y, h.radius, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
  ctx.shadowColor = "purple";
  ctx.shadowBlur = 20;
  ctx.fill();
  ctx.closePath();

  // Icon giữa hố đen
  ctx.font = "2rem serif";
  ctx.fillStyle = "#fff";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("🕳️", h.x, h.y);
  ctx.restore();
});
// Vẽ lazer cho clone
activeCloneLasers.forEach(laser => {
    // Tìm clone đã bắn ra tia lazer này bằng ID
    const firingClone = clones.find(c => c.id === laser.cloneId);

    // Chỉ vẽ tia lazer nếu clone đó còn tồn tại
    if (firingClone) {
        ctx.save();
        ctx.beginPath();
        // Điểm bắt đầu của lazer là vị trí HIỆN TẠI của clone
        ctx.moveTo(firingClone.x, firingClone.y);
        ctx.lineTo(laser.endX, laser.endY);
        
        ctx.strokeStyle = `rgba(255, 100, 255, ${laser.life / 120})`;
        ctx.lineWidth = 6;
        ctx.shadowColor = "#ff00ff";
        ctx.shadowBlur = 20;
        
        ctx.stroke();
        ctx.restore();
    }

  });
}

//🔁 10. Vòng lặp chính và khởi tạo game
let fps = 0, lastFrameTime = performance.now(), frameCount = 0, lastFpsUpdate = performance.now(); // biến cập nhật FPS

function loop() {
  updateDayNight(); // <-- chỉ gọi 1 lần ở đây tránh lặp lại
  const now = performance.now();
  frameCount++;

// Cập nhật FPS mỗi 500ms
if (now - lastFpsUpdate >= 500) {
    fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
    const fpsText = `FPS: ${fps}`;
if (fpsText !== lastFpsText) {
  lastFpsText = fpsText;
  document.getElementById("fpsCounter").innerText = fpsText;
}
    frameCount = 0;
    lastFpsUpdate = now;
}

  update();
  draw();
  frame++;
  
if (frame % 60 === 0 && gameStarted) {
// Giới hạn zombie tối đa là 200 - Số lượng zombie hiện tại
if (zombies.length < 200) {
    const spawnCount = Math.min(10, 200 - zombies.length);
    for (let i = 0; i < spawnCount; i++) {
    spawnZombie();
}
}
}
requestAnimationFrame(loop);
}

// ▶️ Khởi chạy ban đầu
spawnZombie();
loop();

//🧼 11. Các đoạn khởi tạo UI sau canvas
// Hàm bắt đầu game
function startGame() {
    // 1. Xóa dữ liệu đã lưu khi bắt đầu game mới
    localStorage.removeItem(SAVE_KEY);
    
    // 2. Gọi hàm reset để đưa mọi thứ về trạng thái ban đầu
    resetGame();
    
    // 3. Các logic bắt đầu game như cũ
    document.getElementById('statsOverlay')?.classList.remove('hidden');
    document.getElementById('skillsOverlay')?.classList.remove('hidden');
    playSound('sfx-game-start', 0.3);
    
    randomizeBackground();
    const nameInput = document.getElementById("playerNameInput");
    player.name = nameInput.value.trim() || "Player";
    document.getElementById("startMenu").style.display = "none";
    gameStarted = true;
    
    // Đoạn này đã có trong resetGame nên có thể bỏ, nhưng để lại cho chắc chắn
    waveTimer = waveTime; 
    lastWaveTime = Date.now();
     // Bắt đầu chạy bản tin sau 3 giây
    if (typeof NewsTicker !== 'undefined' && NewsTicker.start) {
        NewsTicker.start(3000);
    }
    playRandomNormalMusic();
    showUpgradePopup();
    pendingWave = wave;
    updateAmmoDisplay();
}
/**
 * Thiết lập lại toàn bộ trạng thái của game để bắt đầu một lượt chơi mới.
 * Hàm này không tải lại trang, giúp tiết kiệm thời gian và tài nguyên.
 */
function resetGame() {
    localStorage.removeItem(SAVE_KEY); // Xóa save cũ khi người chơi chọn chơi lại
    console.log("Resetting game state...");

    // 1. Ẩn các giao diện không cần thiết
    document.getElementById('gameOverPanel').classList.remove('visible');
    document.getElementById('pauseMenu').classList.add('hidden');
    
    // 2. Reset các biến trạng thái cốt lõi của game
    gameOver = false;
    isPaused = false;
    gameStarted = true; // Game được bắt đầu ngay lập tức
    wave = 1;
    waveTimer = waveTime;
    lastWaveTime = Date.now();
    frame = 0;
    currentDay = 1;
    dayTime = 0.25; // Reset lại thời gian trong ngày về 6h sáng
    zombieSpawnedCount = 0;
    bigBossRespawnTimer = 0;
    pendingWave = null;
    // 3. Reset toàn bộ trạng thái người chơi về ban đầu
    player.hearts = 10;
    player.maxHearts = 10;
    lastHpRegenTime = 0;
    player.statPoints = 3; // Cho 3 điểm kỹ năng ban đầu
    // ✅ Reset đúng: mutate cùng object đang được STAT_DEFS dùng
if (!window.CharacterPanelState) window.CharacterPanelState = { baseline: null, spent: {} };
window.CharacterPanelState.baseline = null;
const spent = window.CharacterPanelState.spent || (window.CharacterPanelState.spent = {});
spent.damage = 0;
spent.crit = 0;
spent.hp = 0;
spent.stamina = 0;
spent.armor = 0;

// (khuyến nghị) đồng bộ core stat nền để panel chụp baseline mới chính xác
playerUpgrades.damageBoost = 0;
baseCritRate = 0;
player.armor = 0;

// Cập nhật UI
updateStatsOverlay?.();
window.CharacterPanel?.refresh?.();

    player.stamina = 10;
    player.staminaMax = 10;
    player.energy = 0;
    player.mana = 0;
    player.coins = 0;
    player.level = 1;
    player.speed = 1;
    player.exp = 0;
    player.armor = 0;
    player.currentLevelExp = 0;
    player.requiredExp = INITIAL_REQUIRED_EXP;
    player.score = 0;
    zombieKillCount = 0;
    player.isDying = false;
    player.ammo = { 0: 100, 1: 150, 2: 100, 3: 50, 4: 20 };
    player.x = canvas.width / 2; // Đưa player về giữa màn hình
    player.y = canvas.height / 2;

    // 4. Reset các chỉ số nâng cấp của người chơi
    // QUAN TRỌNG: Xem lưu ý ở dưới về các nâng cấp vĩnh viễn
    playerUpgrades.iceArrow = 1;
    playerUpgrades.damageBoost = 1;
    playerUpgrades.hpBoost = 0;
    playerUpgrades.bulletSpeed = 1;
    playerUpgrades.lineBulletCount = 1;
    // Xóa các nâng cấp mua trong Shop
    shopUpgrades.iceArrowSpeedLevel = 0; // xóa bonus tốc độ mũi tên băng
    iceArrowRateShopSteps = 0;                 // xóa bonus tốc độ mua trong Shop
    iceArrowDamageShop    = 0;                 // xóa bonus sát thương mua trong Shop
    window.manualShootCooldownBase = manualShootCooldown; // trả cooldown gốc 1x
    lastManualShootTime = 0;                   // cho phép bắn ngay khi vào game
      // 4.z. Reset các trang bị đang đeo + reset applied để tránh bị trừ âm chỉ số
  if (window.Equip) {
    // Bảo đảm cấu trúc slots tồn tại
    if (!Equip.slots) Equip.slots = {};

    // Xác định danh sách slot
    const slots = (Array.isArray(window.EQUIP_SLOTS) && window.EQUIP_SLOTS.length)
      ? window.EQUIP_SLOTS
      : Object.keys(Equip.slots);

    // Xoá sạch trang bị đang đeo
    for (const s of slots) Equip.slots[s] = null;

    // RÀO CHẮN QUAN TRỌNG: reset applied về 0 để applyEquipmentBonuses không trừ “dư”
    Equip.applied = {
      armor: 0,
      damageBoost: 0,
      bulletSpeed: 0,
      moveSpeed: 0,
      hearts: 0,
      iceArrow: 0,
      lineBulletCount: 0,
      critRate: 0,
      critDmg: 0,
      hpRegen: 0,
      spRegen: 0,
    };
  }

  // Tính lại chỉ số & refresh UI ngay sau khi reset trang bị
  window.recalcEquipStats?.();
  window.CharacterPanel?.refresh?.();
    // 5. Reset các nâng cấp kỹ năng
    skillUpgrades.bladeCount = 2;
    skillUpgrades.bladeDamage = 1;
    skillUpgrades.swordLevel = 1;
    skillUpgrades.swordDamage = 3;
    skillUpgrades.fireCount = 2;
    skillUpgrades.fireDamage = 1;
    skillUpgrades.iceCount = 2;
    skillUpgrades.iceDamage = 2;
    skillUpgrades.thunderCount = 2;
    skillUpgrades.thunderDamage = 3;
    skillUpgrades.auraHealLevel = 0;
    skillUpgrades.fairyCount = 1;
    skillUpgrades.fairyHealLevel = 0;
    skillUpgrades.fairyDamageLevel = 0;

    // 6. Dọn dẹp tất cả các mảng chứa đối tượng trong game
    // Cách .length = 0 là cách xóa mảng hiệu quả nhất, không "gây rác"
    zombies.length = 0;
    bullets.length = 0;
    enemyBullets.length = 0;
    items.length = 0;
    explosions.length = 0;
    particles.length = 0;
    swords.length = 0;
    downwardSwords.length = 0;
    fireballs.length = 0;
    iceballs.length = 0;
    thunderBalls.length = 0;
    fairies.length = 0;
    clones.length = 0;
    activeSkills.length = 0; // Xóa các kỹ năng đã học
    supplyDrops.length = 0;
    // --- Dọn dẹp các mảng chứa đối tượng của kỹ năng ---
    satellites.length = 0;
    ufos.length = 0;
    lightningBolts.length = 0;
    activeLightningStrikes.length = 0;
    blackHoles.length = 0;
    bloodOrbs.length = 0;
    missiles.length = 0;
    nuclearBombs.length = 0;
    bombsB52.length = 0;
    activePlanes.length = 0;
    auraCrackLines.length = 0;
    auraLightBeams.length = 0;
// 7. Reset trạng thái và thời gian hồi của các kỹ năng/buff
    lastManualShootTime = 0; // Reset thời gian hồi bắn tay
    lastAutoShootTime = 0;   // Reset thời gian hồi auto-shoot
    autoBurstIndex = 0;      // Reset loạt đạn của auto-shoot
    autoLastBurstTime = 0;
    levelUpGlowTime = 0;     // Tắt hiệu ứng sáng khi lên cấp

    // Dọn dẹp các bộ đệm thông báo vật phẩm để tránh popup thừa
    clearTimeout(playerLootTimer);
    clearTimeout(petLootTimer);
    Object.keys(playerLootBuffer).forEach(k => delete playerLootBuffer[k]);
    Object.keys(petLootBuffer).forEach(k => delete petLootBuffer[k]);

    // Dọn dẹp các đối tượng thống kê
    // Cách này sẽ xóa sạch các key trong object
    for (let key in zombieByLevel) {
        delete zombieByLevel[key];
    }
    for (let key in skillStats) {
        delete skillStats[key];
    }
    // --- Reset các Buff nhặt được ---
    luckyBuffEndTime = 0;
    powerBuffEndTime = 0;
    isPowerBuffActive = false;
    powerBuffDamageBonus = 0;
    crazyBuffEndTime = 0;
    isCrazyBuffActive = false;
    crazyBuffStats = {};
    expBuffEndTime = 0;
    magnetBuffEndTime = 0;
    crazyMadnessTimeEndTime = 0;
    isCrazyMadnessTimeActive = false;
    crazyMadnessTimeBuffStats = {};
    _critRateBuffs.length = 0; // Xóa tất cả buff cộng tỉ lệ chí mạng
    _critDmgBuffs.length = 0;  // Xóa tất cả buff cộng sát thương chí mạng

    // --- Reset các Kỹ năng Passive (có nút bấm trên UI) ---
    autoShoot = false; // Tắt auto-shoot để người chơi tự bật lại
    
    swordActive = false;
    swordEndTime = 0;
    
    bladeActive = false;
    bladeEndTime = 0;
    
    fireActive = false;
    fireEndTime = 0;
    
    iceActive = false;
    iceEndTime = 0;
    
    thunderActive = false;
    thunderEndTime = 0;
    
    petActive = false;
    petEndTime = 0;
    petRabbit = null;
    
    supportAuraActive = false;
    supportAuraEndTime = 0;

    fairyActive = false;
    fairyEndTime = 0;
    fairyDeathDefyAvailable = false;
    fairyDamageBonus = 0;

    // --- Reset các Kỹ năng Active (học khi lên cấp) ---
    player.shieldActive = false;
    if (player.shieldEndTime) player.shieldEndTime = 0;

    satelliteActive = false;
    satelliteEndTime = 0;
    
    ufoActive = false;
    ufoEndTime = 0;

    lightningActive = false;
    lightningEndTime = 0;
    
    disguiseActive = false;
    disguiseEndTime = 0;

    clonesActive = false;
    clonesEndTime = 0;

    bloodOrbActive = false;
    bloodOrbEndTime = 0;

    spaceGateActive = false;
    spaceGateEndTime = 0;
    spaceGate = null;
    
    // 8. Cập nhật lại toàn bộ giao diện (UI)
    updateUI();
    updateStatsOverlay();
    updateSkillsList(); // Cập nhật lại bảng kỹ năng (sẽ trống)
    document.querySelectorAll('#ui button.active').forEach(btn => btn.classList.remove('active'));

    // 9. Bật lại nhạc nền mặc định và sinh lứa zombie đầu tiên
    playRandomNormalMusic();
    spawnZombie();
    showUpgradePopup(); // Hiển thị nâng cấp cho lượt chơi mới
window.resetStarterEquip?.();
window.recalcEquipStats?.();
window.CharacterPanel?.refresh?.();
// Khởi tạo: cố định Zone 2 làm vùng an toàn đầu game
currentActiveSafeZoneId = 2;
lastSafeZoneChangeHour = Math.floor(dayTime * 24) % 24;
// Đồng bộ cờ active ngay thay vì đợi updateSafeZoneStatus()
safeZones.forEach(z => z.active = (z.id === currentActiveSafeZoneId));
console.log(`Initial Safe Zone set to: ${currentActiveSafeZoneId}`);
}

// Hàm bật/tắt Shop
function toggleShop() {
    const shop = document.getElementById('shopOverlay');
    if (!shop) return;
    const isHidden = shop.classList.toggle('hidden');
    isPaused = !isHidden;

    if (!isHidden) {
        populateShop(); // Khi mở shop, hiển thị các vật phẩm
    }
}

// Hàm hiển thị các vật phẩm trong Shop
function populateShop() {
    const container = document.getElementById('shopItemsContainer');
    container.innerHTML = '';
    document.getElementById('shopCoinBalance').innerText = player.coins;
    shopItems.forEach(item => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'shop-item';
        itemDiv.innerHTML = `
            <div class="icon">${item.icon}</div>
            <div class="name">${item.name}</div>
            <button onclick="purchaseShopItem('${item.id}')">${item.cost} 🪙</button>`;
        container.appendChild(itemDiv);
    });
}

// Hàm xử lý khi mua một vật phẩm
/**
 * Xử lý logic khi người chơi mua một vật phẩm trong cửa hàng.
 * @param {string} itemId - ID của vật phẩm được chọn mua.
 */
function purchaseShopItem(itemId) {
    // Ghi chú: Tìm toàn bộ thông tin của vật phẩm trong mảng `shopItems` dựa vào ID.
    const item = shopItems.find(i => i.id === itemId);
    if (!item) return; // Nếu không tìm thấy vật phẩm, thoát khỏi hàm.

    // Ghi chú: Kiểm tra xem người chơi có đủ xu để mua không.
    if (player.coins >= item.cost) {

        // Ghi chú: Đây là bước kiểm tra đặc biệt. Trước khi trừ tiền, hãy chắc chắn rằng
        // người chơi đã học kỹ năng active trước khi mua nâng cấp cho nó.
        if (item.type === 'active_skill_damage_upgrade') {
            // Dùng `some` để kiểm tra xem trong mảng `activeSkills` có kỹ năng nào trùng tên không.
            const skillIsLearned = activeSkills.some(s => s.name === item.skillName);
            if (!skillIsLearned) {
                showWarning(`Bạn cần học kỹ năng "${item.skillName}" trước!`);
                return; // Dừng việc mua bán lại nếu chưa học.
            }
        }

        // Ghi chú: Trừ số xu của người chơi, phát âm thanh và hiển thị thông báo mua thành công.
        player.coins -= item.cost;
        playSound('sfx-powerup', 0.8);
        showWarning(`Đã mua: ${item.name}!`);

        // Ghi chú: Sử dụng cấu trúc `switch` dựa trên `item.type` để xử lý các loại vật phẩm khác nhau.
        // Cách này giúp code gọn gàng và dễ mở rộng hơn.
        switch (item.type) {
            // Trường hợp mua tài nguyên (máu, mana, năng lượng).
            case 'resource':
                if (item.id.includes('mana')) player.mana += item.value;
                if (item.id.includes('energy')) player.energy += item.value;
                if (item.id.includes('hp')) player.hearts = Math.min(player.maxHearts, player.hearts + item.value); 
                break;
            case 'crit': {
                if (player.coins < item.cost) { showWarning('Không đủ xu'); return; }
                player.coins -= item.cost;

                if (item.sub === 'rate') {
                  // Không cộng vượt trần ngay tại đây; trần áp ở getCritRate()
                  addCritRateBuff(item.value, item.durationMs);
                  showWarning(`✨ Crit Rate +${Math.round(item.value*100)}% trong ${Math.round(item.durationMs/1000)}s`);
                } else if (item.sub === 'dmg') {
                  addCritDmgBuff(item.value, item.durationMs);
                  showWarning(`💥 Crit Dmg +${Math.round(item.value*100)}% trong ${Math.round(item.durationMs/1000)}s`);
                } else {
                  // nếu sau này còn subtype khác
                  showWarning('Crit item chưa hỗ trợ');
                  player.coins += item.cost; // hoàn xu
                }}
                break;
            case 'ice': {
              if (item.id === 'buy_ice_rate') {
                // chặn vượt trần 3x
                if (getIceArrowRate() >= ICE_ARROW_RATE_MAX) {
                  showWarning('Tốc độ Ice Arrow đã tối đa!');
                  player.coins += item.cost; // hoàn lại xu vì không áp dụng được
                } else {
                  iceArrowRateShopSteps += 1; // mỗi lần mua +0.5x
                }
              } else if (item.id === 'buy_ice_damage') {
                iceArrowDamageShop += item.value; // mỗi lần mua +dmg riêng (vd +1)
              }
              break;
            }
           case 'ammo':
                if (player.ammo.hasOwnProperty(item.targetAmmoIndex)) {
                    player.ammo[item.targetAmmoIndex] += item.value;
                    // Cập nhật hiển thị ngay lập tức nếu người chơi đang chọn loại đạn đó
                    if (clickShotMode === item.targetAmmoIndex) {
                        updateAmmoDisplay();
                    }
                }
                break;
            // Trường hợp mua nâng cấp vĩnh viễn cho chỉ số cơ bản của người chơi.
            case 'permanent_upgrade': {
              if (item.id === 'buy_damage') {
                playerUpgrades.damageBoost += item.value;
                break;
              }
              if (item.id === 'buy_ice_arrow_speed') {
                // Chặn mua khi đã đạt trần 3.0
                if (getIceArrowSpeed() >= 3) {
                  showWarning("🏹 Ice Arrow speed đã tối đa!");
                  // Hoàn xu nếu trước đó đã bị trừ bởi logic ở trên (tuỳ bản hàm bạn giữ)
                  player.coins += item.cost;
                  break;
                }
                // +0.5 mỗi lần
                shopUpgrades.iceArrowSpeedLevel = (shopUpgrades.iceArrowSpeedLevel || 0) + 1;

                showWarning(`🏹 Ice Arrow speed: x${getIceArrowSpeed().toFixed(1)}`);
                updateStatsOverlay();
                populateShop();
                break;
              }
              break;
            }
            // Trường hợp mua các loại buff tạm thời.
            case 'buff':
                if (item.id === 'buy_lucky') luckyBuffEndTime = Date.now() + 45000;
                if (item.id === 'buy_power') powerBuffEndTime = Date.now() + 45000;
                if (item.id === 'buy_crazy') crazyBuffEndTime = Date.now() + 45000;
                if (item.id === 'buy_exp') expBuffEndTime = Date.now() + 45000;
                if (item.id === 'buy_magnet') magnetBuffEndTime = Date.now() + 30000;
                if (item.id === 'buy_madness') crazyMadnessTimeEndTime = Date.now() + 30000;
                break;
            
            // Trường hợp mua nâng cấp sát thương cho các kỹ năng mặc định (Đao, Kiếm, Lửa...).
            case 'skill_damage_upgrade':
                // `hasOwnProperty` kiểm tra xem `skillUpgrades` có thuộc tính `item.skillTarget` không.
                if (item.skillTarget && skillUpgrades.hasOwnProperty(item.skillTarget)) {
                    // Tăng sát thương cho kỹ năng tương ứng. Ví dụ: skillUpgrades['bladeDamage'] += 0.2;
                    skillUpgrades[item.skillTarget] += item.value;
                }
                break;

            // Trường hợp mua nâng cấp sát thương cho các kỹ năng Active (học khi lên cấp).
            case 'active_skill_damage_upgrade':
                // Tìm kỹ năng đã học trong mảng `activeSkills`.
                const skillToUpgrade = activeSkills.find(s => s.name === item.skillName);
                if (skillToUpgrade) {
                    // Nếu tìm thấy, cộng dồn sát thương.
                    skillToUpgrade.baseDamage += item.value;
                    // Cập nhật lại tooltip của kỹ năng trong bảng (phím X) để hiển thị sát thương mới.
                    updateSkillsList(); 
                }
                break;
        }

        // Ghi chú: Sau khi mua thành công, cập nhật lại toàn bộ giao diện liên quan.
        populateShop();       // Cập nhật lại số xu và các vật phẩm trong cửa hàng.
        updateUI();           // Cập nhật thanh trạng thái chính (HP, Mana, Xu...).
        updateStatsOverlay(); // Cập nhật bảng thống kê (phím Z).

    } else {
        // Ghi chú: Nếu không đủ xu, chỉ hiển thị thông báo.
        showWarning("Không đủ xu!");
    }
}

// 🌊 Hiện popup "Wave X bắt đầu"
function showWavePopup() {
  const popup = document.getElementById("wavePopup");
  popup.innerText = `Wave ${wave} bắt đầu!`;
  popup.style.animation = "none";
  void popup.offsetWidth; // force reflow để reset animation
  popup.style.display = "block";
  popup.style.animation = "waveFade 1s ease-out forwards";
  setTimeout(() => {
    popup.style.display = "none";
  }, 2000); // ẩn sau 2 giây
}

// 🎯 Giá trị theo cấp độ kỹ năng (mỗi cấp tăng dần)
const UPGRADE_TIERS = {
  iceArrow: [1, 2, 3],
  damageBoost: [0.5, 1, 1.5],
  hpBoost: [5, 10, 15],            
  bulletSpeed: [0.25, 0.5, 1]
};

// 🌟 Hiển thị popup chọn nâng cấp kỹ năng
function showUpgradePopup() {
  playSound('sfx-wave-up', 0.3); // Phát âm thanh nâng cấp
  const popup = document.getElementById("upgradePopup");
  const container = document.getElementById("upgradeChoices");
  container.innerHTML = "";

  // 📌 Bảng giá trị tương ứng với từng bậc nâng cấp
  const UPGRADE_VALUES = {
    Bạc: { iceArrow: 1, damageBoost: 0.5, hpBoost: 5, bulletSpeed: 0.25 },
    Vàng: { iceArrow: 2, damageBoost: 1, hpBoost: 10, bulletSpeed: 0.5 },
    Kim: { iceArrow: 3, damageBoost: 1.5, hpBoost: 15, bulletSpeed: 1 },
    Rare: { moveSpeed: 0.2 } // 👟 tốc độ chạy – bậc hiếm
  };
  // 🎖 Màu viền tương ứng từng bậc
  const TIER_COLORS = {
    Bạc: "#aaa",
    Vàng: "gold",
    Kim: "#c770ff",
    Rare: "#3399ff" // màu xanh bậc hiếm
  };
  // Giới hạn nâng cấp kỹ năng
  const MAX_FIRE_RATE = 21; // 🏹 Ice Arrow
  const MAX_LINE_BULLETS = 10; // 🔫 số lượng đạn
  const MAX_MOVE_SPEED = 3; // 👟 tốc độ di chuyển tối đa
  const MAX_BULLET_SPEED = 10; // 🚀 tốc độ đạn tối đa

  const allUpgrades = [];

  // 🔪 Đao – tăng số lượng (tối đa 20), sau đó tăng sát thương
  // ĐIỀU KIỆN: Chỉ hiển thị nâng cấp khi người chơi đạt level 1
  if (player.level >= 1) {
    if (skillUpgrades.bladeCount < 20) {
      const tier = randomTier();
      const value = { Bạc: 1, Vàng: 2, Kim: 3 }[tier];
      allUpgrades.push({
        name: `🔪 +${value} đao xoay`,
        tier,
        effect: () => {
          skillUpgrades.bladeCount = Math.min(skillUpgrades.bladeCount + value, 20);
          showWarning(`🔪 +${value} đao`);
          updateStatsOverlay();
        }
      });
    } else {
      const tier = randomTier();
      const value = { Bạc: 0.5, Vàng: 1, Kim: 1.5 }[tier];
      allUpgrades.push({
        name: `🔪 +${value} Dmg đao`,
        tier,
        effect: () => {
          skillUpgrades.bladeDamage += value;
          showWarning(`🔪 +${value} dmg`);
          updateStatsOverlay();
        }
      });
    }
  }

  // ⚔️ Kiếm – tăng cấp (tối đa 10), sau đó tăng sát thương
  // ĐIỀU KIỆN: Chỉ hiển thị nâng cấp khi người chơi đạt level 2
  if (player.level >= 2) {
    if (skillUpgrades.swordLevel < 10) {
      const tier = randomTier();
      const value = { Bạc: 1, Vàng: 2, Kim: 3 }[tier];
      allUpgrades.push({
        name: `⚔️ +${value} cấp mưa kiếm`,
        tier,
        effect: () => {
          skillUpgrades.swordLevel = Math.min(skillUpgrades.swordLevel + value, 10);
          showWarning(`⚔️ +${value} cấp kiếm`);
          updateStatsOverlay();
        }
      });
    } else {
      const tier = randomTier();
      const value = { Bạc: 0.5, Vàng: 1, Kim: 1.5 }[tier];
      allUpgrades.push({
        name: `⚔️ +${value} Dmg kiếm`,
        tier,
        effect: () => {
          skillUpgrades.swordDamage += value;
          showWarning(`⚔️ +${value} dmg`);
          updateStatsOverlay();
        }
      });
    }
  }

  // 🔥 Lửa – tăng số lượng (tối đa 10), sau đó tăng sát thương
  // ĐIỀU KIỆN: Chỉ hiển thị nâng cấp khi người chơi đạt level 3
  if (player.level >= 3) {
    if (skillUpgrades.fireCount < 10) {
      const tier = randomTier();
      const value = { Bạc: 1, Vàng: 2, Kim: 3 }[tier];
      allUpgrades.push({
        name: `🔥 +${value} cầu lửa`,
        tier,
        effect: () => {
          skillUpgrades.fireCount = Math.min(skillUpgrades.fireCount + value, 10);
          showWarning(`🔥 +${value} lửa`);
          updateStatsOverlay();
        }
      });
    } else {
      const tier = randomTier();
      const value = { Bạc: 0.5, Vàng: 1, Kim: 1.5 }[tier];
      allUpgrades.push({
        name: `🔥 +${value} Dmg lửa`,
        tier,
        effect: () => {
          skillUpgrades.fireDamage += value;
          showWarning(`🔥 +${value} dmg`);
          updateStatsOverlay();
        }
      });
    }
  }

  // ❄️ Băng – tăng số lượng (tối đa 10), sau đó tăng sát thương
  // ĐIỀU KIỆN: Chỉ hiển thị nâng cấp khi người chơi đạt level 3
  if (player.level >= 3) {
    if (skillUpgrades.iceCount < 10) {
      const tier = randomTier();
      const value = { Bạc: 1, Vàng: 2, Kim: 3 }[tier];
      allUpgrades.push({
        name: `❄️ +${value} cầu băng`,
        tier,
        effect: () => {
          skillUpgrades.iceCount = Math.min(skillUpgrades.iceCount + value, 10);
          showWarning(`❄️ +${value} băng`);
          updateStatsOverlay();
        }
      });
    } else {
      const tier = randomTier();
      const value = { Bạc: 0.5, Vàng: 1, Kim: 1.5 }[tier];
      allUpgrades.push({
        name: `❄️ +${value} Dmg băng`,
        tier,
        effect: () => {
          skillUpgrades.iceDamage += value;
          showWarning(`❄️ +${value} dmg`);
          updateStatsOverlay();
        }
      });
    }
  }
  
  // 🔵 Lôi – tăng số lượng (tối đa 6), sau đó tăng sát thương
  // ĐIỀU KIỆN: Chỉ hiển thị nâng cấp khi người chơi đạt level 5
  if (player.level >= 5) {
    if (skillUpgrades.thunderCount < 6) {
      const tier = randomTier();
      const value = 1;
      allUpgrades.push({
        name: `🔵 +${value} cầu lôi`,
        tier,
        effect: () => {
          skillUpgrades.thunderCount = Math.min(skillUpgrades.thunderCount + value, 6);
          showWarning(`🔵 +${value} cầu lôi`);
          updateStatsOverlay();
        }
      });
    } else {
      const tier = randomTier();
      const value = { Bạc: 1, Vàng: 2, Kim: 3 }[tier];
      allUpgrades.push({
        name: `🔵 +${value} Dmg lôi`,
        tier,
        effect: () => {
          skillUpgrades.thunderDamage += value;
          showWarning(`🔵 +${value} dmg lôi`);
          updateStatsOverlay();
        }
      });
    }
  }

  // 🏹 Ice Arrow – nếu chưa max
  if (playerUpgrades.iceArrow < MAX_FIRE_RATE) {
    const tier = randomTier();
    const value = UPGRADE_VALUES[tier].iceArrow;
    allUpgrades.push({
      name: "🏹 Ice Arrow",
      key: "iceArrow",
      tier,
      value,
      effect: () => {
        const added = Math.min(playerUpgrades.iceArrow + value, MAX_FIRE_RATE) - playerUpgrades.iceArrow;
        playerUpgrades.iceArrow += added;
        showWarning(`🏹 +${added} Ice Arrow`);
        updateStatsOverlay();
      }
    });
  }

  // 💥 Sát thương – luôn có thể nâng
  {
    const tier = randomTier();
    const value = UPGRADE_VALUES[tier].damageBoost;
    allUpgrades.push({
      name: "💥 Sát thương",
      key: "damageBoost",
      tier,
      value,
      effect: () => {
        playerUpgrades.damageBoost += value;
        showWarning(`💥 +${value} sát thương`);
        updateStatsOverlay();
      }
    });
  }

  // ❤️ Máu – luôn có thể nâng
  {
    const tier = randomTier();
    const value = UPGRADE_VALUES[tier].hpBoost;
    allUpgrades.push({
      name: "❤️ Tăng máu",
      key: "hpBoost",
      tier,
      value,
      effect: () => {
      player.maxHearts += value; // 1. Tăng giới hạn máu tối đa
      player.hearts = Math.min(player.maxHearts, player.hearts + value); // 2. Hồi máu ngay lập tức
        showWarning(`❤️ +${value}`);
        updateUI();
        updateStatsOverlay();
      }
    });
  }

  // 💨 Tốc độ đạn tối đa 10
  if (playerUpgrades.bulletSpeed < MAX_BULLET_SPEED) {
    const tier = randomTier();
    const value = UPGRADE_VALUES[tier].bulletSpeed;
    allUpgrades.push({
      name: "💨 Tốc độ đạn",
      key: "bulletSpeed",
      tier,
      value,
      effect: () => {
        const added = Math.min(playerUpgrades.bulletSpeed + value, MAX_BULLET_SPEED) - playerUpgrades.bulletSpeed;
        playerUpgrades.bulletSpeed += added;
        showWarning(`💨 +${added.toFixed(1)} tốc độ đạn`);
        updateStatsOverlay();
      }
    });
  }

  // 🧨 Số lượng đạn – nếu chưa max
  if (playerUpgrades.lineBulletCount < MAX_LINE_BULLETS) {
    const tier = randomTier();
    const value = 1;
    allUpgrades.push({
      name: "🧨 số lượng đạn",
      key: "lineBulletCount",
      tier,
      value,
      effect: () => {
        playerUpgrades.lineBulletCount += value;
        showWarning(`🧨 +${value} viên mỗi hàng`);
        updateStatsOverlay();
      }
    });
  }

  // 👟 Tốc độ chạy – hiếm và chỉ 1 cấp (nếu chưa max)
  if (player.speed < MAX_MOVE_SPEED) {
    const value = UPGRADE_VALUES.Rare.moveSpeed;
    allUpgrades.push({
      name: "👟 Tốc độ chạy",
      key: "moveSpeed",
      tier: "Rare",
      value,
      effect: () => {
        player.speed = Math.min(player.speed + value, MAX_MOVE_SPEED);
        showWarning(`👟 +${value.toFixed(1)} tốc độ`);
        updateStatsOverlay();
      }
    });
  }
  
  // --- Nâng cấp kỹ năng Fairy ---
  // ĐIỀU KIỆN: Chỉ hiển thị nâng cấp khi người chơi đạt level 7
  if (player.level >= 7) {
    if (skillUpgrades.fairyCount < 3) {
      allUpgrades.push({
        name: `🦋 +1 Fairy (Tối đa 3)`,
        tier: "Kim",
        effect: () => {
          skillUpgrades.fairyCount++;
          showWarning(`🦋 Số lượng Fairy: ${skillUpgrades.fairyCount}`);
        }
      });
    } else {
      // Khi đã đủ 3 Fairy, bắt đầu nâng cấp chỉ số
      // Nâng cấp hồi máu
      const healTier = randomTier();
      const healValue = { Bạc: 1, Vàng: 2, Kim: 3 }[healTier];
      allUpgrades.push({
        name: `🦋 +${healValue} Hồi máu/giây`,
        tier: healTier,
        effect: () => {
          skillUpgrades.fairyHealLevel += healValue;
          showWarning(`🦋 Nâng cấp hồi máu!`);
        }
      });

      // Nâng cấp sát thương
      const dmgTier = randomTier();
      const dmgValue = { Bạc: 1, Vàng: 2, Kim: 3 }[dmgTier];
      allUpgrades.push({
        name: `🦋 +${dmgValue} Sát thương`,
        tier: dmgTier,
        effect: () => {
          skillUpgrades.fairyDamageLevel += dmgValue;
          showWarning(`🦋 Nâng cấp sát thương!`);
        }
      });
    }
  }
  
  // --- Nâng cấp Hồi máu cho Hào quang ---
  // ĐIỀU KIỆN: Chỉ hiển thị nâng cấp khi người chơi đạt level 6
  if (player.level >= 6) {
    const currentAuraHeal = 1 + skillUpgrades.auraHealLevel;
    if (currentAuraHeal < 5) { // Chỉ hiển thị nếu chưa đạt tối đa
      const tier = randomTier();
      const value = { Bạc: 1, Vàng: 2, Kim: 3 }[tier];

      allUpgrades.push({
        name: `✨ +${value} Hồi máu`,
        tier: tier,
        effect: () => {
          skillUpgrades.auraHealLevel += value;
          const finalHeal = Math.min(1 + skillUpgrades.auraHealLevel, 5);
          showWarning(`✨ Hồi máu: ${finalHeal} HP/3s`);
          updateStatsOverlay(); // Cập nhật bảng thống kê nếu có
        }
      });
    }
  }

  // 🎲 Xáo trộn và chọn ngẫu nhiên 3 nâng cấp
  const choices = allUpgrades.sort(() => Math.random() - 0.5).slice(0, 3);
  // 🖱️ Tạo nút cho từng nâng cấp
  choices.forEach(up => {
    const btn = document.createElement("button");
    btn.innerText = up.name;
    btn.style.borderColor = TIER_COLORS[up.tier];
    btn.onclick = () => {
      playSound('sfx-upgrade-select'); // ÂM THANH KHI CLICK
      up.effect();
      popup.classList.remove('visible'); // <-- Dùng class để ẩn popup
      isPaused = false;
      lastWaveTime = Date.now();

      if (pendingWave !== null) {
        setTimeout(() => {
          showWavePopup();
          pendingWave = null;
        }, 500);
      }
    };
    container.appendChild(btn);
  });

  popup.classList.add('visible'); // <-- Dùng class để hiện popup
  isPaused = true;
}
// 🛠️ Hiển thị thông báo khi nâng cấp thành công
// 🎲 Chọn bậc nâng cấp ngẫu nhiên theo tỷ lệ
function randomTier() {
  const tiers = ["Bạc", "Vàng", "Kim"];
  const weights = [0.7, 0.25, 0.05]; // tỷ lệ gặp: 60% Bạc, 30% Vàng, 10% Kim
  const r = Math.random();
  let sum = 0;
  for (let i = 0; i < tiers.length; i++) {
    sum += weights[i];
    if (r < sum) return tiers[i];
  }
  return "Bạc"; // fallback nếu có lỗi
}

// 🌟 Hiển thị popup chọn kỹ năng khi tăng level
/* ========= CẤU HÌNH ========= */
const MAX_LV = {                         // giới hạn số-lượng
  ufo        : 3,                        // UFO tấn công
  missile    : 5,                        // tên lửa F18
  lightning  : 5,                        // tia sét diện rộng
  satellite  : 2,                        // vệ tinh laze
  blackhole  : 2,                        // Hố đen
  bloodorb   : 2
};

/* tên ngắn → regex nhận diện chuỗi nâng cấp */
const UP_RX = {
  ufo       : /\+1 UFO/i,
  missile   : /\+1 tên lửa/i,
  lightning : /\+1 tia sét/i,
  satellite : /\+1 vệ tinh/i,
  blackhole : /\+1 hố đen/i,
  bloodorb  : /\+1 quả cầu/i
};

/* ========= TRỢ GIÚP ========= */
const rand    = arr => arr[Math.random() * arr.length | 0];          // pickRandom
const shuffle = a => a.sort(() => Math.random() - .5);               // Fisher–Yates 1-liner

/* kiểm tra 1 nâng cấp có “hết đát” chưa */
function isOverLimit(upgrade){
  const key = Object.keys(UP_RX).find(k => UP_RX[k].test(upgrade.name));
  if (!key) return false;                                            // gói sát thương, v.v.
  const active = activeSkills.find(s => s.name === upgrade.skillName);
  return active && (active.level || 0) >= MAX_LV[key];
}

/* ========= POPUP ========= */
function showSkillLevelUpPopup() {
    isPaused = true;
    const popup = document.getElementById('skillPopup');
    const container = document.getElementById('skillChoices');
    container.innerHTML = '';

    const newSkills = [];
    const upgradesBySkill = {};

    // 1. Duyệt qua TẤT CẢ kỹ năng trong một vòng lặp duy nhất để thu thập các lựa chọn
    for (const skill of skillsData) {
        // Kiểm tra kỹ năng mới có thể học
        const requiredLevel = skillsData.indexOf(skill) + 1;
        if (!activeSkills.includes(skill) && player.level >= requiredLevel) {
            newSkills.push(skill);
        }

        // Lấy các nâng cấp của kỹ năng đã học
        const activeSkill = activeSkills.find(s => s.name === skill.name);
        if (activeSkill && skill.upgrades) {
            upgradesBySkill[skill.name] = upgradesBySkill[skill.name] || [];
            for (const upgrade of skill.upgrades) {
                if (!isOverLimit(upgrade)) {
                    upgradesBySkill[skill.name].push({ ...upgrade, skillName: skill.name });
                }
            }
        }
    }

    // 2. Chọn 3 lựa chọn từ các pool đã thu thập
    let choices = [];
    if (newSkills.length > 0) {
        // Ưu tiên 1 kỹ năng mới
        const newSkillIndex = Math.floor(Math.random() * newSkills.length);
        const pickNew = newSkills[newSkillIndex];
        choices.push(pickNew);

        // Tạo pool để chọn 2 nâng cấp còn lại
        const pool = [];
        // Thêm các kỹ năng mới còn lại vào pool
        for (let i = 0; i < newSkills.length; i++) {
            if (i !== newSkillIndex) {
                pool.push(newSkills[i]);
            }
        }
        // Thêm các nâng cấp vào pool
        for (const skillName in upgradesBySkill) {
            const upgrades = upgradesBySkill[skillName];
            if (upgrades.length > 0) {
                const randomUpgrade = upgrades[Math.floor(Math.random() * upgrades.length)];
                pool.push(randomUpgrade);
            }
        }
        shuffle(pool).slice(0, 2).forEach(choice => choices.push(choice));

    } else {
        // Nếu không có kỹ năng mới, chọn ngẫu nhiên 3 nâng cấp
        const uniqueUpgrades = Object.values(upgradesBySkill).map(upgrades => upgrades[Math.floor(Math.random() * upgrades.length)]);
        choices = shuffle(uniqueUpgrades).slice(0, 3);
    }

    // 3. Render nút bấm
    choices.forEach(ch => {
        const btn = document.createElement('button');
        if (ch.icon) { // Đây là kỹ năng mới
            btn.textContent = `${ch.icon} ${ch.name}`;
            btn.onclick = () => {
                playSound('sfx-upgrade-select');
                learnSkill(skillsData.indexOf(ch));
                popup.style.display = 'none';
                isPaused = false;
            };
        } else { // Đây là nâng cấp
            btn.textContent = ch.name;
            btn.style.borderColor = { Bạc: '#aaa', Vàng: 'gold', Kim: '#c770ff', Đỏ: 'red' }[ch.tier] || '#ccc';
            btn.onclick = () => {
                playSound('sfx-upgrade-select');
                ch.effect?.();
                showWarning(` ${ch.name}`);
                popup.style.display = 'none';
                isPaused = false;
            };
        }
        container.appendChild(btn);
    });

    popup.style.display = 'block';
}

// 🧾 Cập nhật thông tin thống kê trong overlay
function updateStatsOverlay() {
  /* 👇 1. Tính lại tổng mỗi lần vẽ */
  const alive  = zombies.length;      // đang còn trên bản đồ
  const killed = zombieKillCount;     // đã tiêu diệt
  const total  = alive + killed;      // tổng thực
const now = Date.now();
  document.getElementById("stat-damage").innerText =
  `💥 Dmg: ${(playerUpgrades.damageBoost || 1).toFixed(1)} | Crit: ${Math.round(getCritRate(now)*100)}% | x ${(1+getCritDmg(now)).toFixed(2)}`;
  document.getElementById("stat-spawned").innerText = `🧟 Tổng số zombie: ${total}`;
  document.getElementById("stat-alive").innerText   = `🧟 Đang còn sống: ${alive}`;
  document.getElementById("stat-total").innerText   = `🧟 Đã tiêu diệt: ${killed}`;
  document.getElementById("stat-speed").innerText =
  `💨 Att.speed: ${playerUpgrades.bulletSpeed.toFixed(1)} | 🏹: ${getIceArrowSpeed().toFixed(1)}`;
  document.getElementById("stat-iceArrow").innerText =
  `🏹 Ice Arrow: ${playerUpgrades.iceArrow} | +${getIceArrowBonusDamage().toFixed(1)} dmg | ${getIceArrowRate().toFixed(1)}x `;
  document.getElementById("stat-lineCount").innerText = `🧨 Số lượng đạn: ${playerUpgrades.lineBulletCount}`;
  document.getElementById("stat-moveSpeed").innerText = `👟 Tốc độ chạy: ${player.speed.toFixed(1)}`;
  // 🔪 Thống kê kỹ năng mặc định
  document.getElementById("stat-blade").innerText = `🔪 Đao: ${skillUpgrades.bladeCount} đao, ${skillUpgrades.bladeDamage.toFixed(1)} dmg`;
  document.getElementById("stat-sword").innerText = `⚔️ Kiếm: Lv${skillUpgrades.swordLevel}, ${skillUpgrades.swordDamage.toFixed(1)} dmg`;
  document.getElementById("stat-fire").innerText = `🔥 Lửa: ${skillUpgrades.fireCount} lửa, ${skillUpgrades.fireDamage.toFixed(1)} dmg`;
  document.getElementById("stat-ice").innerText = `❄️ Băng: ${skillUpgrades.iceCount} băng, ${skillUpgrades.iceDamage.toFixed(1)} dmg`;
  document.getElementById("stat-thunder").innerText = `🔵 Lôi: ${skillUpgrades.thunderCount} cầu, ${skillUpgrades.thunderDamage.toFixed(1)} dmg`;
// Kỹ năng khác
const skillText = Object.entries(skillStats)
  .map(([key, value]) => `${key}: ${value}`)
  .join("<br>");
  document.getElementById("stat-skills").innerHTML = skillText;

// 🧟 Zombie theo cấp: chỉ hiển thị từ Cấp 1 → 10
  let breakdown = "";
  for (let i = 1; i <= 10; i++) {
    breakdown += `<div>🧟 Cấp ${i}: ${zombieByLevel[i] || 0}</div>`;
  }

// 💀 Thống kê Mini Boss & Boss ở cuối
  const miniBossLine = `<div>💀 Mini Boss: ${zombieByLevel.miniBoss || 0}</div>`;
  const bossLine = `<div>💀 Boss: ${zombieByLevel.boss || 0}</div>`;
  const bigBossLine = `<div>💀 BigBoss: ${zombieByLevel.bigBoss || 0}</div>`;
  document.getElementById("stat-breakdown").innerHTML =
  breakdown + miniBossLine + bossLine + bigBossLine;
}
const activeSkills = [];

// Kỹ năng mẫu
const skillsData = [
  {
    name: "Khiên bảo vệ",
    icon: "🛡️",
    manaCost: 10,
    duration: 60000,
    description: "Tạo một vòng bảo vệ hoàn hảo chắn mọi sát thương."
  },
  {
    name: "Vệ tinh laze",
    icon: "🛰️",
    manaCost: 20,
    duration: 30000,
    baseDamage: 3,
    description: "Triệu hồi 1~2 vệ tinh xoay quanh và bắn laze xuyên zombie."
  },
{
  name: "Tên lửa F18",
  icon: "🚀",
  manaCost: 25,
  duration: 30000,
  baseDamage: 6,
  description: "Gọi 1~5 tên lửa truy tìm và tiêu diệt zombie.",
  upgrades: []
},
{
  name: "UFO tấn công",
  icon: "🛸",
  manaCost: 30,
  duration: 30000,
  baseDamage: 5,
  description: "Gọi UFO hỗ trợ bắn laze đỏ tiêu diệt zombie xung quanh.",
  upgrades: []
},
{
  name: "Bão sét",
  icon: "🌩️",
  manaCost: 35,
  duration: 33000,
  baseDamage: 8,
  description: "Gọi 1~5 tia sét ngẫu nhiên đánh quanh bản đồ.",
  upgrades: []
},
{
  name: "Bom B52",
  icon: "💣",
  manaCost: 52,
  duration: 52000,
  baseDamage: 10,
  description: "Máy bay mang theo Bom B52 thả hàng loạt tiêu diệt zombie."
},
  {
    name: "Ảo ảnh phân thân",
    icon: "🎭",
    manaCost: 20,
    duration: 45000,
    baseDamage: 5,
    description: "Triệu hồi 2 bản sao hỗ trợ bắn."
  },
  {
    name: "Hố đen",
    icon: "🕳️",
    manaCost: 60,
    duration: 30000,
    baseDamage: 50,
    description: "Tạo một hố đen hút zombie xung quanh."
  },
  {
    name: "Biến hình",
    icon: "🐸",
    manaCost: 5,
    duration: 10000,
    description: "Giả dạng thành ếch đồng thời tăng tốc, zombie sẽ bỏ đi không tấn công."
  },
  {
    name: "Boom hạt nhân",
    icon: "☢️",
    manaCost: 100,
    duration: 20000,
    baseDamage: 100,
    description: "Bom hạt nhân phát nổ toàn bản đồ, sát thương cực lớn."
  },
{
    name: "Quả cầu hấp huyết",
    icon: "🩸",
    manaCost: 25,
    duration: 25000,
    baseDamage: 2,
    description: "Triệu hồi 1~2 quả cầu đỏ.\nMỗi giây hút máu zombie gần nhất, gây sát thương và hồi 1 HP.",
    upgrades: []
},
{
    name: "Cổng Không Gian",
    icon: "🌀",
    manaCost: 50,
    duration: 30000,
    baseDamage: 10,
    description: "Mở một cổng dịch chuyển đưa bạn đến một vị trí ngẫu nhiên an toàn trên bản đồ."
  },
];
/* đặt sau khai báo skillsData */
const skillTooltipMap = Object.fromEntries(
  skillsData.map(sk => [
    sk.name,
    `${sk.icon} ${sk.name}\n─ Mana ${sk.manaCost}💠, ${sk.duration/1000}s\n${sk.description}`
  ])
);

// 🧪 Thêm nâng cấp cho từng kỹ năng có baseDamage
skillsData.forEach(skill => {
  if (skill.baseDamage !== undefined) {
      skill.upgrades = [
{
        name: `${skill.icon} +1 sát thương`,
        tier: "Bạc",
        effect: () => { skill.baseDamage += 1; 
        updateSkillsList(); 
}
},
{
      name: `${skill.icon} +2 sát thương`,
      tier: "Vàng",
      effect: () => { skill.baseDamage += 2;
      updateSkillsList();
}
},
{
        name: `${skill.icon} +3 sát thương`,
        tier: "Kim",
        effect: () => { skill.baseDamage += 3;
        updateSkillsList();
}
}
];

    if (skill.name === "Bão sét") {
    skill.upgrades.push({
    name: "🌩️ +1 tia sét (tối đa 5)",
    tier: "Đỏ",
    effect: () => {
  const skill = activeSkills.find(s => s.name === "Bão sét");
  if (skill) {
    skill.level = (skill.level || 0) + 1;
    showWarning("🌩️ +1 tia sét!");
    updateSkillsList();
}
}
});
}
if (skill.name === "Hố đen") {
  skill.upgrades.push({
    name: "🕳️ +1 hố đen (tối đa 2)",
    tier: "Đỏ",
    effect: () => {
      const skill = activeSkills.find(s => s.name === "Hố đen");
      if (skill) {
        skill.level = Math.min((skill.level || 0) + 1, 2); // +1 tới tối đa 2 hố đen
        showWarning("🕳️ +1 hố đen!");
        updateSkillsList();
      }
    }
  });
}

if (skill.name === "Vệ tinh laze") {
  skill.upgrades.push({
    name: "🛰️ +1 vệ tinh (tối đa 2)",
    tier: "Đỏ",
    effect: () => {
      const skill = activeSkills.find(s => s.name === "Vệ tinh laze");
      if (skill) {
        skill.level = Math.min((skill.level || 0) + 1, 2); // +1 tới tối đa 2 vệ tinh
        showWarning("🛰️ +1 vệ tinh!");
        updateSkillsList();
}
}
});
}

if (skill.name === "UFO tấn công") {
  skill.upgrades.push({
    name: "🛸 +1 UFO (tối đa 3)",
    tier: "Đỏ",
effect: () => {
  const skill = activeSkills.find(s => s.name === "UFO tấn công");
  if (skill) {
    skill.level = (skill.level || 0) + 1;
    showWarning("🛸 +1 UFO!");
    updateSkillsList();
}
}
});
}

// 🎯 Nếu là kỹ năng Tên lửa thì thêm nâng cấp số lượng
    if (skill.name === "Tên lửa F18") {
      skill.upgrades.push({
        name: `${skill.icon} +1 tên lửa (tối đa 5)`,
        tier: "Đỏ",
effect: () => {
  const skill = activeSkills.find(s => s.name === "Tên lửa F18");
  if (skill) {
    skill.level = (skill.level || 0) + 1;
    showWarning("🚀 +1 tên lửa!");
    updateSkillsList();
}
}
});
}
if (skill.name === "Quả cầu hấp huyết") {
    skill.upgrades.push({
        name: "🩸 +1 quả cầu (tối đa 2)",
        tier: "Đỏ",
        effect: () => {
            const skill = activeSkills.find(s => s.name === "Quả cầu hấp huyết");
            if (skill) {
                skill.level = Math.min((skill.level || 0) + 1, 2);
                showWarning("🩸 +1 Quả cầu!");
                updateSkillsList();
            }
        }
    });
}
}
});
// 🔍 Ghép mô tả chi tiết cho mỗi skill
function buildSkillTooltip(skill) {
  const secs = (skill.duration ?? 0) / 1000;
  const rows = [
    `${skill.icon} ${skill.name}`,
    `Mana: ${skill.manaCost}💠  •  Thời gian: ${secs ? secs + " s" : "tức thì"}`,
  ];

  // --- Sát thương hiện tại (nếu có) ---
  if (skill.baseDamage !== undefined)
    rows.push(`Sát thương: ${skill.baseDamage}`);

  // --- Level hiện tại của các nâng cấp đỏ ---
  if (skill.level !== undefined)
    rows.push(`Cấp hiện tại: ${skill.level}`);

  // --- Danh sách nâng cấp khả dụng ---
  /*if (skill.upgrades?.length) {
    rows.push("Nâng cấp:");
    skill.upgrades.forEach(u => rows.push(`• ${u.name}  [${u.tier}]`));
  }*/

  // --- Mô tả gốc --- "", chèn trước mô tả nếu có
  if (skill.description) rows.push(`Mô tả: ${skill.description}`);

  return rows.join("\n");
}
// 🧪 Hàm học kỹ năng mới
function updateSkillsList() {
    const list = document.getElementById('skills-list');
    list.innerHTML = '';
    
    // Chỉ tạo lại các item trong danh sách kỹ năng
    activeSkills.forEach(skill => {
        const div = document.createElement('div');
        div.className = 'skill-item';
        div.dataset.tooltip = buildSkillTooltip(skill);

        // Luôn hiển thị thông tin cơ bản
        div.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${skill.manaCost}💠`;

        // Gán sự kiện click trực tiếp
      div.onclick = () => {
          // 🔒 Khóa click ở safe zone
          if (window.isPlayerInSafeZone || safeZones.some(zone => distance(player, zone) < zone.radius)) {
              // (Không làm gì cả để tránh spam)
              return;
          }
          if (player.mana >= skill.manaCost && (!skill.endTime || Date.now() > skill.endTime)) {
              activateSkill(skill);
          }
      };

      // Đồng bộ trạng thái disable ngay khi render
      if (window.isPlayerInSafeZone) {
          div.classList.add('disabled');
      }
        list.appendChild(div);
    });

    // Gán lại sự kiện cho tooltip (giữ nguyên logic gốc của bạn)
    document.querySelectorAll('#skills-list .skill-item[data-tooltip]').forEach(it => {
        it.addEventListener('mouseenter', () => {
            const ln = (it.dataset.tooltip.match(/\n/g)?.length || 0) + 1;
            const hTip = ln * 18 + 12;
            const r = it.getBoundingClientRect();
            const gap = 8;
            const overTop = Math.max(gap - r.top, 0);
            const overBottom = Math.max((r.top + hTip) - (innerHeight - gap), 0);
            const shiftValue = overTop - overBottom;
            it.style.setProperty('--tip-shift', `${shiftValue}px`);
        });

        it.addEventListener('mouseleave', () => {
            it.style.removeProperty('--tip-shift');
        });
    });
}

// 🧪 Test: Thêm kỹ năng bất kỳ bằng phím số 1–9, 0
document.addEventListener("keydown", (e) => {
    // Nếu người dùng đang gõ trong một ô INPUT, hãy thoát ra ngay và không làm gì cả.
    if (e.target.tagName === 'INPUT') {
        return;
    }

    const keys = "1234567890-=";
    const index = keys.indexOf(e.key);

    // Nếu phím được nhấn nằm trong danh sách phím test
    if (index >= 0 && skillsData[index]) {
        // Gọi trực tiếp hàm learnSkill để đảm bảo logic đồng nhất
        learnSkill(index);
    }
});

function activateSkill(skill) {
  // Kiểm tra nếu không đủ mana hoặc kỹ năng đang hồi chiêu
  if (!skill || player.mana < skill.manaCost || (skill.endTime && Date.now() < skill.endTime)) {
    return;
  }
  playSound('sfx-ui-click', 0.2); // Phát âm thanh khi kích hoạt kỹ năng
  player.mana -= skill.manaCost;
  // Gán thời gian kết thúc hồi chiêu vào chính đối tượng skill
  skill.endTime = Date.now() + skill.duration;

  // Logic kích hoạt hiệu ứng của kỹ năng
  switch (skill.name) {
    case "Khiên bảo vệ": activateShield(skill); break;
    case "Vệ tinh laze":
      // --- BẮT ĐẦU ĐOẠN MÃ MỚI ---
      satelliteActive = true;
      satelliteEndTime = Date.now() + skill.duration;
      
      const satCount = Math.min(skill.level || 1, 2);
      const orbitRadius = 60; // chỉnh bán kính quay ở đây
      const orbitSpeed = 0.002; // chỉnh tốc độ quay ở đây

      satellites = [];
      for (let i = 0; i < satCount; i++) {
          satellites.push({
              // Gán cho mỗi vệ tinh một góc ban đầu để chúng cách đều nhau
              angle: (2 * Math.PI / satCount) * i, 
              orbitRadius: orbitRadius,
              orbitSpeed: orbitSpeed
          });
      }
      showWarning(`${skill.icon} ${skill.name}!`); // Giữ lại thông báo
      // --- KẾT THÚC ĐOẠN MÃ MỚI ---
      break;
    case "Tên lửa F18": activateTwinMissiles(skill); break;
    case "UFO tấn công": activateUFO(skill); break;
    case "Bão sét": activateLightning(skill); break;
    case "Bom B52": activateBombs(skill); break;
    case "Ảo ảnh phân thân": activateClones(skill); break;
    case "Hố đen": activateBlackHole(skill); break;
    case "Biến hình": activateDisguise(skill); break;
    case "Boom hạt nhân": activateNuclearBomb(skill); break;
    case "Quả cầu hấp huyết": activateBloodOrb(skill); break;
    case "Cổng Không Gian": activateSpaceGate(skill); break;
  }

// Làm sáng nút kỹ năng tương ứng và đếm ngược
const list = document.getElementById('skills-list').children;
for (let i = 0; i < list.length; i++) {
  const item = list[i];
  if (item.textContent.includes(skill.name)) {
    item.classList.add("active");
    const endTime = Date.now() + skill.duration;
    const interval = setInterval(() => {
      const remain = Math.ceil((endTime - Date.now()) / 1000);
      if (remain > 0) {
        item.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${remain}s`;
} else {
        item.classList.remove("active");
        item.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${skill.manaCost}💠`;
        clearInterval(interval);
}
}, 1000);
break;
}
}
// Hiển thị thông báo kỹ năng đã kích hoạt
  showWarning(`${skill.icon} ${skill.name}!`);
}
// 🧟‍♂️ Kỹ năng: Tạo các kỹ năng đặc biệt cho người chơi
// 🛡️ Khiên bảo vệ: Tạo lớp chắn chặn sát thương và hiển thị hiệu ứng
function activateShield(skill) {
  player.shieldActive = true;
  player.shieldEndTime = Date.now() + skill.duration;

  setTimeout(() => {
    player.shieldActive = false;
}, skill.duration);
}

// 🚀 Tên lửa F18: 2 tên lửa bay quanh người chơi, xuyên và gây sát thương zombie
// ===== Twin Missiles (tối ưu, không filter/sort) =====

// Buffer tạm dùng lại cho lần gọi sau (giảm GC):
const twinTmpTargets = []; // sẽ chỉ chứa tối đa K phần tử { z, d2 }

// Chọn tối đa K zombie xa người chơi nhất trong bán kính TWIN_R (một pass, không sort)
function selectFarthestKZombies(K, R, outArr) {
  outArr.length = 0;                // tái dùng mảng, không cấp phát mảng mới
  const R2 = R * R;

  for (let i = 0; i < zombies.length; i++) {
    const z = zombies[i];
    if (!z || !z.active) continue;

    const dx = z.x - player.x, dy = z.y - player.y;
    const d2 = dx * dx + dy * dy;
    if (d2 > R2) continue;          // ngoài tầm → bỏ

    // chen vào outArr (sắp xếp giảm d2) với kích thước tối đa K
    if (outArr.length < K) {
      // chèn giữ thứ tự giảm d2
      let j = outArr.length - 1;
      outArr.push(null);            // mở rộng mảng trước khi dịch
      while (j >= 0 && outArr[j].d2 < d2) { outArr[j + 1] = outArr[j]; j--; }
      outArr[j + 1] = { z, d2 };    // (tối đa K entry → cấp phát tối đa K object)
    } else if (outArr[outArr.length - 1].d2 < d2) {
      // lớn hơn phần tử nhỏ nhất hiện có → chèn vào đúng vị trí
      let j = outArr.length - 1;
      while (j > 0 && outArr[j - 1].d2 < d2) { outArr[j] = outArr[j - 1]; j--; }
      outArr[j] = { z, d2 };
    }
  }
}

function activateTwinMissiles(skill) {
  const K = Math.min(skill.level || 1, 5); // tối đa 5 mục tiêu/đợt
  const TWIN_R = 360;                      // bán kính quét mục tiêu
  const MISSILE_RADIUS = 40;               // bán ra vòng tròn quanh player
  const SPAWN_DELAY = 2000;                // ms giữa các đợt
  const LIFE_TIME = skill.duration;        // tổng thời gian hiệu lực

  // Hàm tạo 1 đợt tên lửa
  const spawnWave = () => {
    selectFarthestKZombies(K, TWIN_R, twinTmpTargets);
    const count = twinTmpTargets.length;
    if (count === 0) return;

    for (let i = 0; i < count; i++) {
      const target = twinTmpTargets[i].z;

      // vị trí xuất phát ngẫu nhiên quanh player (bo tròn nhẹ)
      const ang = Math.random() * Math.PI * 2;
      const x = player.x + Math.cos(ang) * MISSILE_RADIUS;
      const y = player.y + Math.sin(ang) * MISSILE_RADIUS;

      missiles.push({
        x, y,
        dx: 0, dy: 0,
        target,                 // mục tiêu riêng cho missile này
        damage: skill.baseDamage,
        delay: 120,             // giữ logic delay của bạn
        state: "delay",
        startX: x,
        startY: y,
        hitSet: new Set(),      // cần theo dõi đã chạm ai; nếu không cần, bỏ để giảm cấp phát
      });
    }
  };

  // 🔵 Tạo ngay 1 đợt đầu
  spawnWave();

  // ⏱ Lặp lại đến khi hết thời gian kỹ năng
  const intervalId = setInterval(spawnWave, SPAWN_DELAY);
  setTimeout(() => clearInterval(intervalId), LIFE_TIME);
}

// UFO tấn công
function activateUFO(skill) {
  ufoActive = true;
  ufoEndTime = Date.now() + skill.duration;
  
  // Xác định số lượng UFO dựa trên cấp kỹ năng
  const ufoCount = Math.min(skill.level || 3, 3); // Tối đa 3 UFO
  const damage = skill.baseDamage;

ufos = Array.from({ length: ufoCount }, (_, i) => {
    // Thời gian ngẫu nhiên từ 1-3 giây cho mỗi lần đổi hướng
    const interval = 1000 + Math.random() * 2000; 

    return {
        relativeX: 80 + Math.random() * 120,
        relativeY: 120 + Math.random() * 120,
        speedX: (Math.random() - 0.5) * 2,
        speedY: (Math.random() - 0.5) * 1.5,
        directionChangeInterval: interval, // Khoảng thời gian giữa 2 lần đổi hướng
        nextDirectionChangeTime: Date.now() + interval, // Mốc thời gian để đổi hướng tiếp theo
        damage,
        laserCooldown: Date.now() + Math.random() * 1000, // Thời gian bắn ngẫu nhiên lúc đầu
        laserLife: 0,
        angle: 0
};
});
  // Xóa UFO sau khi hết thời gian kỹ năng
  setTimeout(() => {
    ufoActive = false;
    ufos = [];
  }, skill.duration);
}

// === Helper: vẽ đường sét ngoằn ngoèo =========================
function getZigZag(start, target, segments = 8, jitter = 20) {
  const pts = [start];                         // điểm đầu là đám mây
  for (let i = 1; i < segments; i++) {
    const t = i / segments;                    // nội suy tuyến tính
    pts.push({
      x: start.x + (target.x - start.x) * t + (Math.random() - 0.5) * jitter,
      y: start.y + (target.y - start.y) * t + (Math.random() - 0.5) * jitter
    });
  }
    pts.push({
      x: target.x + (Math.random() - 0.5) * jitter,
      y: target.y + (Math.random() - 0.5) * jitter
});
  return pts;                                  // mảng [{x,y}, …]
}

// 🌩️ bão sét: Gọi sét ngẫu nhiên gây sát thương diện rộng
function activateLightning(skill) {
    lightningActive = true;
    lightningStartTime = Date.now(); // Sử dụng biến này làm mốc thời gian bắt đầu
    lightningEndTime = lightningStartTime + skill.duration;

    const boltCount = Math.min(skill.level || 5, MAX_LV.lightning);
    lightningBolts = []; // Reset lại các đám mây
    for (let i = 0; i < boltCount; i++) {
    lightningBolts.push({
        // Đã xóa offsetX
        damage: skill.baseDamage,
        nextZapTime: Date.now() + Math.random() * 1000 // Thời gian cho lần phóng sét tiếp theo
        });
    }
    
    // Hẹn giờ để tắt kỹ năng
    setTimeout(() => {
        lightningActive = false;
        lightningBolts = [];
    }, skill.duration);
}

// Kích hoạt kỹ năng Bom B52 - tái sử dụng hàm activateBombs
function spawnPlanes(skill, amount = 3) {
  const planeYBase = player.y - 180; // Vị trí máy bay bắt đầu

  for (let i = 0; i < amount; i++) {
    const plane = {
      x: -100,
      y: planeYBase - i * 20,
      targetY: planeYBase - i * 20,
      vx: 1.5 + i * 0.5,
      lastDropTime: Date.now(),
      nextDropDelay: 5000 + i * 500 + Math.random() * 300,

      // 👇 Hiệu ứng biến mất
      scale: 1,
      opacity: 1,
      disappearing: false
    };

    activePlanes.push(plane);

    // ✅ Cập nhật tốc độ ngang mỗi 1–5 giây
    function schedulePlaneSpeedAdjust() {
      const delay = Math.random() * (5000 - 1000) + 1000;
      plane._speedTimeout = setTimeout(() => {
        plane.vx = Math.random() * (5 - 0.5) + 0.5;
        schedulePlaneSpeedAdjust(); // Gọi lại để lặp
      }, delay);
    }

    // ✅ Cập nhật độ cao dao động mỗi 1–5 giây
    function schedulePlaneHeightAdjust() {
      const delay = Math.random() * (5000 - 1000) + 1000;
      plane._heightTimeout = setTimeout(() => {
        plane.targetY += (Math.random() - 0.5) * 40; // dao động ±20
        schedulePlaneHeightAdjust(); // Lặp tiếp
      }, delay);
    }

    // 🔄 Kích hoạt 2 chu kỳ điều chỉnh
    schedulePlaneSpeedAdjust();
    schedulePlaneHeightAdjust();

    // 🎮 Cập nhật chuyển động và thả bom định kỳ
    const planeInterval = setInterval(() => {
      const now = Date.now();

      // ➡ Di chuyển theo tốc độ hiện tại
      plane.x += plane.vx;

      // 📈 Bay mượt đến targetY
      plane.y += (plane.targetY - plane.y) * 0.05;

      // 💣 Thả bom nếu đến thời điểm
      if (now - plane.lastDropTime > plane.nextDropDelay) {
        plane.lastDropTime = now;
        plane.nextDropDelay = 1000 + Math.random() * 2000; // từ 1–3s

        const targetY = plane.y + 100 + Math.random() * (canvas.height * 0.9); // 90%
        bombsB52.push({
          x: plane.x,
          y: plane.y,
          vy: 3,
          exploded: false,
          landed: false,
          finalY: targetY,
          timerAfterLand: 180,
          radius: 15,
          damage: skill.baseDamage
        });
      }

      // 🌀 Khi gần rìa map thì bắt đầu biến mất
      if (!plane.disappearing && plane.x > worldWidth - 180) {
        plane.disappearing = true;
      }

      // 🧼 Hiệu ứng thu nhỏ và xoá máy bay
      if (plane.disappearing) {
        plane.scale *= 0.95;
        plane.opacity -= 0.05;

        if (plane.scale < 0.1 || plane.opacity <= 0) {
          clearInterval(planeInterval);
          clearTimeout(plane._speedTimeout);
          clearTimeout(plane._heightTimeout);
          activePlanes.splice(activePlanes.indexOf(plane), 1);
        }
      }
    }, 50);
  }
}
const planeWaves = [
  { delay: 0, amount: 1 },      // tạo 3 máy bay ngay lập tức
  { delay: 3000, amount: 1 },  // tạo 5 máy bay sau 30s
  { delay: 6000, amount: 1 },
  { delay: 9000, amount: 1 },  // tạo 2 máy bay sau 60s
];
// 💣 Bom B52: rơi xuống, nổ khi trúng zombie, nếu không trúng thì nổ sau 5s khi chạm đất
function activateBombs(skill) {
  const skillEndTime = Date.now() + skill.duration;

  planeWaves.forEach(wave => {
    setTimeout(() => {
      spawnPlanes(skill, wave.amount);
    }, wave.delay);
  });
  // 💣 Update bom rơi
  const updateInterval = setInterval(() => {
    for (let i = bombsB52.length - 1; i >= 0; i--) {
      const bomb = bombsB52[i];
      if (bomb.exploded) continue;

      if (!bomb.landed) {
        bomb.y += bomb.vy;
        for (let z of zombies) {
          if (z.active && distance(bomb, z) < bomb.radius + z.radius) {
            explodeB52Bomb(bomb);
            bombsB52.splice(i, 1);
            break;
          }
        }
        if (bomb.y >= bomb.finalY) {
          bomb.y = bomb.finalY;
          bomb.landed = true;
        }
      } else {
        bomb.timerAfterLand--;
        if (bomb.timerAfterLand <= 0) {
          explodeB52Bomb(bomb);
          bombsB52.splice(i, 1);
        }
      }
    }

    if (Date.now() > skillEndTime && bombsB52.length === 0) {
      clearInterval(updateInterval);
    }
  }, 1000 / 60);

function explodeB52Bomb(bomb) {
    bomb.exploded = true;

    // ✨ BẮT ĐẦU PHẦN CẢI TIẾN ✨
    // 1. Vụ nổ chính (100% sát thương)
    zombies.forEach(z => {
        if (z.active && distance(bomb, z) < 200) { // Bán kính nổ 200px
            dealDamageToZombie(z, bomb.damage);
        }
    });
    createParticleExplosion(bomb.x, bomb.y, 50, 'fire'); // Hiệu ứng nổ chính

    // 2. Vụ nổ phụ (50% sát thương) sau 0.2 giây
    setTimeout(() => {
        zombies.forEach(z => {
            if (z.active && distance(bomb, z) < 200) {
                // Gây thêm 50% sát thương
                dealDamageToZombie(z, bomb.damage * 0.5); 
            }
        });
        // Tạo một vụ nổ nhỏ hơn để báo hiệu
        const secondaryExplosion = getExplosion(bomb.x, bomb.y);
        secondaryExplosion.life = 15;
        explosions.push(secondaryExplosion);
    }, 200); // 200ms = 0.2 giây
    // ✨ KẾT THÚC PHẦN CẢI TIẾN ✨
}
}
// 🎭 Ảo ảnh phân thân: Tạo 2 bản sao bắn đạn hỗ trợ
function activateClones(skill) {
  clonesActive = true;
  clonesEndTime = Date.now() + skill.duration;
  clones = [];

  const moveAngle = Math.random() * Math.PI * 2; // hướng di chuyển chung

  for (let i = 0; i < 2; i++) {
    const offset = (i === 0 ? -40 : 40); // clone trái và phải cách nhau 80px
    clones.push({
      x: player.x + Math.cos(moveAngle + Math.PI / 2) * offset,
      y: player.y + Math.sin(moveAngle + Math.PI / 2) * offset,
      moveAngle: moveAngle,
      moveSpeed: 1.2,                     // Tốc độ di chuyển clone
      baseDamage: skill.baseDamage || 5, // Sát thương riêng
      lastShot: 0,
      id: Date.now() + i, // Tạo 1 ID tia lazer
      shotCount: 0
    });
  }
}
// 🕳️ Hố đen: Hút zombie vào tâm và gây sát thương liên tục
function activateBlackHole(skill) {
  const holeCount = Math.min(skill.level || 2, 2);
  
  // Tách biệt kích thước và phạm vi hút
  const VISUAL_RADIUS = 150;  // Kích thước hố đen sẽ được vẽ trên màn hình
  const PULL_RADIUS = 200; // Phạm vi hút zombie xung quanh

  const firstAngle = Math.random() * Math.PI * 2;

  for (let i = 0; i < holeCount; i++) {
    const angle = firstAngle + (i * Math.PI);
    const distance = 80 + Math.random() * 80;

    const x = player.x + Math.cos(angle) * distance;
    const y = player.y + Math.sin(angle) * distance;

    blackHoles.push({
      x: x,
      y: y,
      radius: VISUAL_RADIUS,     // Gán kích thước VẼ
      pullRadius: PULL_RADIUS,   // Gán phạm vi HÚT
      damage: skill.baseDamage,
      pullSpeed: 3.5,
      tick: 0,
      endTime: Date.now() + skill.duration,
      dx: (Math.random() - 0.5) * 0.1,
      dy: (Math.random() - 0.5) * 0.1
    });
  }
}

// 🐸 Biến hình: Zombie tạm thời không phát hiện người chơi (ẩn thân)
function activateDisguise(skill) {
  disguiseActive = true;
  disguiseEndTime = Date.now() + skill.duration;

  // (MỚI) Buff tạm thời khi kích hoạt
  player.hearts = Math.min(player.maxHearts, player.hearts + 20);
  showWarning("🐸 Biến hình! +20 HP & Tăng tốc!");

  zombies.forEach(z => {
    if (!z.isBoss) {
      z.state = "wandering";
      z.wanderTime = Date.now() + 6000 + Math.random() * 4000;// Thời gian đi lang thang ngẫu nhiên từ 6s đến 10s
      z.wanderAngle = Math.random() * Math.PI * 2;

      // 💬 Biểu cảm ngẫu nhiên nếu không phải boss
      if (Math.random() < 0.6) {
        const expressions = ["😕", "🤢", "😴", "😳", "🤮"];
        z.iconToDraw = expressions[Math.floor(Math.random() * expressions.length)];
        setTimeout(() => { z.iconToDraw = null; }, 5000); // Biểu cảm biến mất sau 5s
      }
    }
  });
// Khi hết thời gian
setTimeout(() => {
    disguiseActive = false;
    player.hearts = Math.max(1, player.hearts - 20);
    showWarning("🐸 Hết biến hình!");

    // --- LOGIC BOM KHÓI ---
    // 1. Tạo hiệu ứng khói hình ảnh
    createParticleExplosion(player.x, player.y, 70, 'smoke');

    // 2. Đẩy lùi và làm choáng zombie ở gần
    const pushRadius = 300;
    const pushForce = 30;

    zombies.forEach(z => {
        if (z.active && distance(player, z) < pushRadius) {
            const angle = Math.atan2(z.y - player.y, z.x - player.x);
            z.x += Math.cos(angle) * pushForce;
            z.y += Math.sin(angle) * pushForce;
            z.state = "wandering"; // Buộc zombie đi lang thang
        }
    });

}, skill.duration);

}
// Màu cho bom hạt nhân khi phát nổ
const colors = [
    "rgba(255,255,255,0.7)", // trắng
    "rgba(255,0,0,0.7)",     // đỏ
    "rgba(0,255,0,0.7)",     // xanh lá
    "rgba(0,200,255,0.7)",   // cyan
    "rgba(255,200,0,0.7)",   // vàng
    "rgba(255,0,255,0.7)"    // tím
];
// ☢️ Bom Hạt Nhân: Rơi xuống giữa màn hình, đếm ngược 5s rồi tạo vòng nổ lan rộng
function activateNuclearBomb(skill) {
    if (nuclearBombs.length >= 1) return;
    document.getElementById('sfx-nuke-fall').play(); // Phát âm thanh bom rơi
    nuclearBombs.push({
        x: player.x,
        y: 100,
        vy: 3.5,
        exploded: false,
        landed: false,
        timerAfterLand: 5 * 60,
        damage: skill.baseDamage * 10,
        radius: 22,
        finalY: player.y,
        shockwave: false,
        shockwaveRadius: 0,
        shockwaveSpeed: 2
    });
    const updateInterval = setInterval(() => {
        if (nuclearBombs.length === 0) {
            clearInterval(updateInterval);
            return;
        }

        const bomb = nuclearBombs[0];
        if (bomb.exploded && !bomb.shockwave) return;
        // 💨 Khi bom chạm đất – tạo hạt bụi bay vào tâm bom
        if (bomb.landed && !bomb.exploded) {
        for (let i = 0; i < 2; i++) {
        createSuctionDust(bomb.x, bomb.y, 0.6); // Tốc độ tan nhanh chậm
        }
        }
        // Bom rơi xuống
        if (!bomb.landed) {
            bomb.y += bomb.vy;
            if (bomb.y >= bomb.finalY) {
                bomb.landed = true;
                bomb.y = bomb.finalY;
                playSound('sfx-nuke-time', 0.8); // Phát âm thanh đếm giờ
            }
        }
        // Đếm ngược nổ
        else if (!bomb.exploded) {
            bomb.timerAfterLand--;
            if (bomb.timerAfterLand <= 0) {
                explodeNuclearBomb(bomb);
            }
        }

        // Sóng xung kích sau khi nổ
        if (bomb.exploded && bomb.shockwave) {
            bomb.shockwaveRadius += bomb.shockwaveSpeed;
            zombies.forEach(z => {
                if (z.active && distance(bomb, z) < bomb.shockwaveRadius) {
                    // Chỉ gây sát thương nếu zombie không có cooldown
                    if (!z.nukeCooldown || Date.now() > z.nukeCooldown) {
                        dealDamageToZombie(z, bomb.damage);
                        
                        // Đặt lại cooldown 1 giây cho con zombie này
                        z.nukeCooldown = Date.now() + 1000; // 1s mới nhận lại sát thương
                    }
                }
            });
            enemyBullets.forEach(b => {
                if (!b.active) return;
                if (distance(bomb, b) < bomb.shockwaveRadius) {
                    releaseEnemyBullet(b);
                    explosions.push(getExplosion(b.x, b.y));
                }
            });
            if (bomb.shockwaveRadius > Math.max(canvas.width, canvas.height) * 1.4) {
                nuclearBombs.shift();
                bomb.shockwave = false;
            }
        }
    }, 1000 / 60);
    // Hàm phát nổ
    function explodeNuclearBomb(bomb) {
        // Dừng âm thanh còi hú/rơi
        const fallSound = document.getElementById('sfx-nuke-fall');
        if (fallSound) {
            fallSound.pause();
            fallSound.currentTime = 0; // Reset để lần sau có thể phát lại từ đầu
        }
        // Phát âm thanh nổ
        playSound('sfx-nuke-explode', 1.0); // Phát ở 100% âm lượng

        bomb.exploded = true;
        bomb.shockwave = true;
        bomb.shockwaveRadius = 0;
        explosions.push(getExplosion(bomb.x, bomb.y)); // 💥 hiệu ứng nổ nhỏ trung tâm
        // 🌊 Thêm 2 vòng nổ phụ mỗi 2 giây
        setTimeout(() => {
            extraShockwaves.push({
                x: bomb.x,
                y: bomb.y,
                radius: 0,
                maxRadius: 300,
                color: "red",
                alpha: 1
            });
        }, 2000);
        setTimeout(() => {
            extraShockwaves.push({
                x: bomb.x,
                y: bomb.y,
                radius: 0,
                maxRadius: 400,
                color: "cyan",
                alpha: 1
            });
        }, 4000);
        // 💨 Hạt bụi bay ra khi bom phát nổ
        for (let i = 0; i < 60; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 1 + 0.5;
    const color = colors[Math.floor(Math.random() * colors.length)]; // màu ngẫu nhiên
    particles.push({
        x: bomb.x,
        y: bomb.y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: Math.random() * 3 + 1,
        color: color,
        alpha: 1
    });
}
}
}
// 🩸 Quả cầu hấp huyết
function activateBloodOrb(skill) {
    bloodOrbActive = true;
    bloodOrbEndTime = Date.now() + skill.duration;

    // Xác định số lượng quả cầu theo level (tối đa 2)
    const maxCount = Math.min(skill.level || 2, 2); // Tối đa 2 quả cầu hấp huyết
    bloodOrbCount = maxCount;

    bloodOrbs = Array.from({ length: maxCount }, (_, i) => ({
        angle: (2 * Math.PI / maxCount) * i,
        radius: 60,
        x: player.x,
        y: player.y
    }));
}
// ================== CỔNG KHÔNG GIAN ==================

// Hàm tìm một vị trí an toàn để dịch chuyển đến
function findSafeTeleportLocation() {
  let bestX = player.x, bestY = player.y;
  let lowestZombieCount = Infinity;

  const MAX_ATTEMPTS = 20;
  const padding = 100;
  const BOSS_R2   = 500 * 500;  // khoảng cách tối thiểu với boss (bình phương)
  const ZOMBIE_R2 = 300 * 300;  // bán kính đếm zombie (bình phương)

  for (let i = 0; i < MAX_ATTEMPTS; i++) {
    // điểm ngẫu nhiên, tránh rìa
    const x = Math.random() * (worldWidth  - padding * 2) + padding;
    const y = Math.random() * (worldHeight - padding * 2) + padding;

    let isValid = true;
    let nearbyZombies = 0;

    // 1 vòng lặp duy nhất cho cả check boss + đếm zombie
    for (let j = 0; j < zombies.length; j++) {
      const z = zombies[j];
      if (!z || !z.active) continue;

      const dx = x - z.x;
      const dy = y - z.y;
      const d2 = dx*dx + dy*dy;

      // gần boss → loại ngay, không cần đếm tiếp
      if ((z.isBoss || z.isBigBoss) && d2 < BOSS_R2) { isValid = false; break; }
      if (d2 < ZOMBIE_R2) nearbyZombies++;
    }

    if (!isValid) continue;

    if (nearbyZombies < lowestZombieCount) {
      lowestZombieCount = nearbyZombies;
      bestX = x; bestY = y;
      if (nearbyZombies === 0) break; // tìm được chỗ “trống” → thoát sớm
    }
  }

  // Không tìm được gì tốt → fallback hợp lý hơn: ngẫu nhiên xa người chơi và tránh rìa
  if (lowestZombieCount === Infinity) {
    const angle = Math.random() * Math.PI * 2;
    const r = Math.min(worldWidth, worldHeight) * 0.35;
    const fx = player.x + Math.cos(angle) * r;
    const fy = player.y + Math.sin(angle) * r;
    return {
      x: Math.max(padding, Math.min(worldWidth  - padding, fx)),
      y: Math.max(padding, Math.min(worldHeight - padding, fy))
    };
  }

  return { x: bestX, y: bestY };
}

// Hàm tạo một cổng mới
function createNewGate(x, y) {
    const safeX = Math.max(wallThickness + 60, Math.min(worldWidth - wallThickness - 60, x));
    const safeY = Math.max(wallThickness + 60, Math.min(worldHeight - wallThickness - 60, y));
    const initialRadius = 40; // Bán kính ban đầu
    spaceGate = {
        x: safeX,
        y: safeY,
        radius: initialRadius,
        originalRadius: initialRadius, // Lưu lại bán kính gốc
        damage: 2,
        rotation: 0,
        alpha: 0 // Vẫn giữ alpha để cổng mới hiện ra mượt mà
    };
}

// Hàm kích hoạt chính
function activateSpaceGate(skill) {
  // Nếu đã có cổng rồi thì không tạo nữa
  if (spaceGateActive) return;

  spaceGateActive = true;
  spaceGateEndTime = Date.now() + skill.duration;

  // Tạo cổng ngay trước mặt người chơi một khoảng
  // Xác định hướng dựa trên phím đang nhấn, hoặc ngẫu nhiên nếu đứng yên
  const angle = (keys.a || keys.d || keys.w || keys.s) 
                ? Math.atan2((keys.s ? 1 : 0) - (keys.w ? 1 : 0), (keys.d ? 1 : 0) - (keys.a ? 1 : 0))
                : (zombies.length > 0 ? Math.atan2(zombies[0].y - player.y, zombies[0].x - player.x) : 0);
  const distance = 150;

  createNewGate(player.x + Math.cos(angle) * distance, player.y + Math.sin(angle) * distance, skill.baseDamage);
}

// Hàm tạo cổng mới
function createNewGate(x, y, damage) {
    // Giới hạn vị trí cổng không bị tạo ra ngoài bản đồ
    const safeX = Math.max(wallThickness + 60, Math.min(worldWidth - wallThickness - 60, x));
    const safeY = Math.max(wallThickness + 60, Math.min(worldHeight - wallThickness - 60, y));

    spaceGate = {
        x: safeX,
        y: safeY,
        radius: 50,       // Bán kính hiệu ứng của cổng
        damage: damage,   // Sát thương cơ bản
        rotation: 0,
        alpha: 0,         // Độ mờ ban đầu (để làm hiệu ứng hiện ra)
        particles: []     // Mảng chứa các hạt lửa trang trí
    };
}
// 📌 Bật/tắt bảng kỹ năng bằng phím X
document.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'x') {
    document.getElementById('skillsOverlay').classList.toggle('hidden');
    updateSkillsList();
  }
});

// Thêm kỹ năng mới (gọi hàm này khi lên cấp)
function learnSkill(index) {
  const skill = skillsData[index];
if (!activeSkills.includes(skill)) {
  activeSkills.push(skill);
  /* SỬA khối gán level */
  skill.level = 1;              // ← luôn bắt đầu ở cấp 1
if (skill.baseDamage !== undefined && skill.level === undefined) {
  skill.level = 0;
}
  updateSkillsList();
  showWarning(`🎉 Học kỹ năng: ${skill.icon} ${skill.name}`);
}
}

// 🎯 Phím Z để bật/tắt bảng thống kê
document.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "z") {
    const panel = document.getElementById("statsOverlay");
    panel.classList.toggle("hidden");
}
});

// 🎯 Gán phím ` để bật/tắt FPS
document.addEventListener("keydown", (e) => {
  if (e.key === "`") {
    const fpsDiv = document.getElementById("fpsCounter");
    fpsDiv.style.display = fpsDiv.style.display === "none" ? "block" : "none";
}
});
function showGuide() {
  playSound('sfx-ui-click', 0.2);
  document.getElementById("guideOverlay").style.display = "block";
}
function hideGuide() {
  playSound('sfx-ui-click', 0.2);
  document.getElementById("guideOverlay").style.display = "none";
}
function showInfo() {
  playSound('sfx-ui-click', 0.2);
  document.getElementById("infoOverlay").style.display = "block";
}
function hideInfo() {
  playSound('sfx-ui-click', 0.2);
  document.getElementById("infoOverlay").style.display = "none";
}

// --- LOGIC CHO DEBUG MENU ---

// Hàm mở/đóng menu
function toggleDebugMenu() {
    const debugMenu = document.getElementById('debugMenu');
    if (!debugMenu) return;

    const isHidden = debugMenu.classList.toggle('hidden');
    isPaused = !isHidden;

    if (!isHidden) {
        populateDebugMenu();
    }
}

// HÀM CẬP NHẬT: Điền giá trị vào menu
function populateDebugMenu() {
    const setSliderValue = (id, value) => {
        const slider = document.getElementById(id);
        if (slider) {
            slider.value = value;
            const valueSpan = slider.nextElementSibling;
            if (valueSpan) {
                if (slider.step.includes('.')) {
                    valueSpan.textContent = parseFloat(value).toFixed(1);
                } else {
                    valueSpan.textContent = value;
                }
            }
        }
    };

    // Chỉ số cơ bản & game
    document.getElementById('debug-exp').value = player.currentLevelExp;
    setSliderValue('debug-wave', wave);
    setSliderValue('debug-dayTime', (dayTime * 24).toFixed(1));
    setSliderValue('debug-level', player.level);
    setSliderValue('debug-hp', player.hearts);
    setSliderValue('debug-mana', player.mana);
    setSliderValue('debug-energy', player.energy);
    setSliderValue('debug-moveSpeed', player.speed);
    setSliderValue('debug-damage', playerUpgrades.damageBoost);
    setSliderValue('debug-iceArrow', playerUpgrades.iceArrow);
    setSliderValue('debug-bulletSpeed', playerUpgrades.bulletSpeed);
    setSliderValue('debug-lineCount', playerUpgrades.lineBulletCount);
    setSliderValue('debug-coin', player.coins);
    
    // Chỉ số kỹ năng passive
    setSliderValue('debug-bladeCount', skillUpgrades.bladeCount);
    setSliderValue('debug-bladeDamage', skillUpgrades.bladeDamage);
    setSliderValue('debug-swordLevel', skillUpgrades.swordLevel);
    setSliderValue('debug-swordDamage', skillUpgrades.swordDamage);
    setSliderValue('debug-fireCount', skillUpgrades.fireCount);
    setSliderValue('debug-fireDamage', skillUpgrades.fireDamage);
    setSliderValue('debug-iceCount', skillUpgrades.iceCount);
    setSliderValue('debug-iceDamage', skillUpgrades.iceDamage);
    setSliderValue('debug-thunderCount', skillUpgrades.thunderCount);
    setSliderValue('debug-thunderDamage', skillUpgrades.thunderDamage);
    setSliderValue('debug-auraHealLevel', skillUpgrades.auraHealLevel);
    setSliderValue('debug-fairyCount', skillUpgrades.fairyCount);
    setSliderValue('debug-fairyHealLevel', skillUpgrades.fairyHealLevel);
    setSliderValue('debug-fairyDamageLevel', skillUpgrades.fairyDamageLevel);

    // Cập nhật giá trị cho các thanh trượt kỹ năng active
    skillsData.forEach(skill => {
        const learnedSkill = activeSkills.find(s => s.name === skill.name);
        const currentData = learnedSkill || skill;
        const safeIdName = skill.name.replace(/\s/g, '-');

        if (document.getElementById(`debug-level-${safeIdName}`)) {
            setSliderValue(`debug-level-${safeIdName}`, currentData.level || 1);
        }
        if (document.getElementById(`debug-damage-${safeIdName}`)) {
            setSliderValue(`debug-damage-${safeIdName}`, currentData.baseDamage);
        }
    });
}

// Debug giá trị từ menu vào game
function applyDebugChanges() {
  // đọc giá trị từ UI
  const lvl   = parseInt(document.getElementById('debug-level').value) || 1;
  const expUI = parseInt(document.getElementById('debug-exp').value)   || 0;

  // 1) cập nhật level trước, rồi tính lại requiredExp
  player.level = lvl;
  player.requiredExp = calculateRequiredExp(player.level); // dùng đúng hàm hiện có【turn6file9†index.html†L34-L47】

  // 2) đồng bộ EXP: tổng & EXP của cấp hiện tại
  player.currentLevelExp = expUI;
  player.exp = expUI;
    // Chỉ số cơ bản & game
    player.exp = parseInt(document.getElementById('debug-exp').value);
    wave = parseInt(document.getElementById('debug-wave').value);
    dayTime = parseFloat(document.getElementById('debug-dayTime').value) / 24;
    updateWaveUI();
    player.level = parseInt(document.getElementById('debug-level').value);
    player.requiredExp = calculateRequiredExp(player.level);
    player.hearts = parseInt(document.getElementById('debug-hp').value);
    player.mana = parseInt(document.getElementById('debug-mana').value);
    player.energy = parseInt(document.getElementById('debug-energy').value);
    player.speed = parseFloat(document.getElementById('debug-moveSpeed').value);
    playerUpgrades.damageBoost = parseFloat(document.getElementById('debug-damage').value);
    playerUpgrades.iceArrow = parseInt(document.getElementById('debug-iceArrow').value);
    playerUpgrades.bulletSpeed = parseFloat(document.getElementById('debug-bulletSpeed').value);
    playerUpgrades.lineBulletCount = parseInt(document.getElementById('debug-lineCount').value);
    player.coins = parseInt(document.getElementById('debug-coin').value);

    // Chỉ số kỹ năng passive
    skillUpgrades.bladeCount = parseInt(document.getElementById('debug-bladeCount').value);
    skillUpgrades.bladeDamage = parseFloat(document.getElementById('debug-bladeDamage').value);
    skillUpgrades.swordLevel = parseInt(document.getElementById('debug-swordLevel').value);
    skillUpgrades.swordDamage = parseFloat(document.getElementById('debug-swordDamage').value);
    skillUpgrades.fireCount = parseInt(document.getElementById('debug-fireCount').value);
    skillUpgrades.fireDamage = parseFloat(document.getElementById('debug-fireDamage').value);
    skillUpgrades.iceCount = parseInt(document.getElementById('debug-iceCount').value);
    skillUpgrades.iceDamage = parseFloat(document.getElementById('debug-iceDamage').value);
    skillUpgrades.thunderCount = parseInt(document.getElementById('debug-thunderCount').value);
    skillUpgrades.thunderDamage = parseFloat(document.getElementById('debug-thunderDamage').value);
    skillUpgrades.auraHealLevel = parseInt(document.getElementById('debug-auraHealLevel').value);
    skillUpgrades.fairyCount = parseInt(document.getElementById('debug-fairyCount').value);
    skillUpgrades.fairyHealLevel = parseInt(document.getElementById('debug-fairyHealLevel').value);
    skillUpgrades.fairyDamageLevel = parseInt(document.getElementById('debug-fairyDamageLevel').value);
    
    // --- BẮT ĐẦU SỬA LỖI LOGIC KỸ NĂNG ACTIVE ---
    skillsData.forEach(skill => {
        const safeIdName = skill.name.replace(/\s/g, '-');
        const levelSlider = document.getElementById(`debug-level-${safeIdName}`);
        const damageSlider = document.getElementById(`debug-damage-${safeIdName}`);
        let hasChanges = false;

        const learnedSkill = activeSkills.find(s => s.name === skill.name);
        const currentData = learnedSkill || skill;

        if (levelSlider) {
            const newLevel = parseInt(levelSlider.value);
            if (newLevel !== (currentData.level || 1)) {
                skill.level = newLevel;
                hasChanges = true;
            }
        }
        
        if (damageSlider) {
            const newDamage = parseFloat(damageSlider.value);
            if (newDamage !== currentData.baseDamage) {
                skill.baseDamage = newDamage;
                hasChanges = true;
            }
        }
        
        // Nếu có thay đổi và kỹ năng chưa được học -> tự động học
        if (hasChanges && !activeSkills.includes(skill)) {
            // Đảm bảo gán level 1 khi học lần đầu
            if (skill.level === undefined) {
                skill.level = 1;
            }
            activeSkills.push(skill);
        }
    });
    // --- KẾT THÚC SỬA LỖI ---

    updateUI();
    updateStatsOverlay();
    sysPickupItemsAndLevel(Date.now());
    // Gọi updateSkillsList() ở cuối để làm mới giao diện kỹ năng và tooltip
    updateSkillsList(); 
    showWarning('🔧 Các chỉ số đã được cập nhật!');
}

// Đợi cho đến khi toàn bộ tài liệu HTML được tải xong rồi mới chạy mã bên trong
document.addEventListener('DOMContentLoaded', function () {
  // Hiển thị nút "Tiếp tục" nếu có dữ liệu lưu
      if (localStorage.getItem(SAVE_KEY)) {
        document.getElementById('continueBtn').style.display = 'block';
    }

    const loadingOverlay = document.getElementById('loadingOverlay');
    const loadingText = document.getElementById('loadingText');
    const startMenu = document.getElementById('startMenu');
        // lấy phần tử thanh loading
    const loadingBar = document.querySelector('.loading-bar');

/*
    loadingOverlay.style.display = 'none'; // Ẩn màn hình loading đi
    startMenu.style.display = 'flex';     // Hiện menu chính lên ngay lập tức
*/
    // 1. Ẩn menu chính đi ngay từ đầu
    startMenu.style.display = 'none';

    // 2. Bắt đầu quá trình tải audio
    initAudioPool(
        5,
        (loaded, total) => {
            loadingText.innerText = `Đang tải tài nguyên... (${loaded}/${total})`;
    // Tính toán và cập nhật độ rộng của thanh loading
            const progress = (loaded / total) * 100;
            loadingBar.style.width = `${progress}%`;
        },
        // 3. CẬP NHẬT LOGIC KHI TẢI XONG
        () => {
            console.log("Audio resources fully loaded and ready.");
            loadingText.innerText = 'Sẵn sàng!';
            // Giữ màn hình "Sẵn sàng!" thêm 1 giây để audio thực sự được giải mã
            setTimeout(() => {
                // Bắt đầu quá trình chuyển đổi
                loadingOverlay.classList.add('hidden'); // Bắt đầu làm mờ màn hình loading
                startMenu.style.display = 'flex';     // Hiện menu chính lên
                // Sau khi hiệu ứng mờ kết thúc, ẩn hẳn loading overlay đi
                // để không chặn click chuột vào menu
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                }, 500); // Thời gian này phải khớp với transition trong CSS
            }, 1000); // <-- Chờ 1 giây (1000ms)
        }
    );
    // Gán sự kiện nhấn phím '/' và 'o'
    document.addEventListener('keydown', (e) => {
        switch (e.key) {
            case '/':
                e.preventDefault();
                if (debugKeyTimer === null) {
                    debugKeyTimer = setTimeout(() => {
                        toggleDebugMenu();
                        debugKeyTimer = null;
                    }, 500); // Đợi 0.5 giây trước khi mở menu
                }
                break;

            case 'o':
                if (gameStarted && !gameOver) {
                    toggleShop();
                }
                break;
        }
    });

    // Bắt sự kiện khi người dùng THẢ phím `/` RA
    document.addEventListener('keyup', (e) => {
        if (e.key === '/') {
            if (debugKeyTimer) {
                clearTimeout(debugKeyTimer);
                debugKeyTimer = null;
            }
        }
    });

    // Gán sự kiện cho các nút bấm "Áp dụng" và "Đóng"
    const applyBtn = document.getElementById('applyDebugChanges');
    if (applyBtn) {
        applyBtn.onclick = applyDebugChanges;
    }

    const closeBtn = document.getElementById('closeDebugMenu');
    if (closeBtn) {
        closeBtn.onclick = toggleDebugMenu;
    }

    // Gán sự kiện 'input' cho tất cả thanh kéo để cập nhật số hiển thị khi người dùng kéo
    const sliders = document.querySelectorAll('#debugMenu input[type="range"]');
    sliders.forEach(slider => {
        const valueSpan = slider.nextElementSibling;
        if (valueSpan) {
            slider.addEventListener('input', () => {
                if (slider.step.includes('.')) {
                    valueSpan.textContent = parseFloat(slider.value).toFixed(1);
                } else {
                    valueSpan.textContent = slider.value;
                }
            });
        }
    });

    // Tự động phát bài hát ngẫu nhiên khác khi một bài hát bình thường kết thúc
    normalMusicTracks.forEach(id => {
        const track = document.getElementById(id);
        if (track) {
            track.addEventListener('ended', function () {
                if (currentMusicState === 'normal') {
                    playRandomNormalMusic();
                }
            });
        }
    });
    // Gán sự kiện nút đóng Shop
    const closeShopBtn = document.getElementById('closeShopBtn');
    if (closeShopBtn) {
        closeShopBtn.onclick = toggleShop;
    }
    // Bắt sự kiện phím ESC
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (gameStarted && !gameOver) {
                togglePauseMenu();
            }
        }
    });

    // Gán sự kiện cho các nút trong Pause Menu
    document.getElementById('resumeBtn').onclick = togglePauseMenu;
    document.getElementById('restartBtnPause').onclick = resetGame;
    document.getElementById('guideBtnPause').onclick = showGuide;
    document.getElementById('infoBtnPause').onclick = showInfo;
    document.getElementById('exitBtn').onclick = () => location.reload();

    // Gán sự kiện cho các thanh trượt âm lượng
    const masterSlider = document.getElementById('volume-master');
    const musicSlider = document.getElementById('volume-music');
    const sfxSlider = document.getElementById('volume-sfx');

    if (masterSlider) {
        masterSlider.addEventListener('input', () => {
            masterVolume = parseFloat(masterSlider.value);
            masterSlider.nextElementSibling.textContent = `${Math.round(masterVolume*100)}%`;
            updateAllMusicVolume();
        });
    }
    if (musicSlider) {
        musicSlider.addEventListener('input', () => {
            musicVolume = parseFloat(musicSlider.value);
            musicSlider.nextElementSibling.textContent = `${Math.round(musicVolume*100)}%`;
            updateAllMusicVolume();
        });
    }
    if (sfxSlider) {
        sfxSlider.addEventListener('input', () => {
            sfxVolume = parseFloat(sfxSlider.value);
            sfxSlider.nextElementSibling.textContent = `${Math.round(sfxVolume*100)}%`;
        });
    }
        // KHỞI TẠO BẢN TIN CHẠY CHỮ - THÊM VÀO ĐÂY
    if (typeof NewsTicker !== 'undefined' && NewsTicker.init) {
        NewsTicker.init();
    }
});
// --- LOGIC CHO PAUSE MENU ---
function togglePauseMenu() {
    const menu = document.getElementById('pauseMenu');
    if (!menu) return; // Thêm kiểm tra để tránh lỗi
    const isHidden = menu.classList.toggle('hidden');
    isPaused = !isHidden;
    // Khi mở menu, cập nhật giá trị các thanh trượt về giá trị hiện tại
    if (!isHidden) {
        document.getElementById('volume-master').value = masterVolume;
        document.getElementById('volume-music').value = musicVolume;
        document.getElementById('volume-sfx').value = sfxVolume;
        // Cập nhật text hiển thị %
        document.querySelector('#volume-master + .range-value').textContent = `${Math.round(masterVolume*100)}%`;
        document.querySelector('#volume-music + .range-value').textContent = `${Math.round(musicVolume*100)}%`;
        document.querySelector('#volume-sfx + .range-value').textContent = `${Math.round(sfxVolume*100)}%`;
    }
}
// Tự động lưu game khi người chơi đóng tab/trình duyệt
window.onbeforeunload = saveGame;
</script>
<!-- 🌟 Popup khi lên cấp -->
<div id="levelUpPopup">Level Up!</div>
<!-- 🌟 Popup chọn nâng cấp -->
<div id="upgradePopup">
  <h3 class="upgradeTitle">⏫ Chọn nâng cấp</h3>
  <div id="upgradeChoices" class="upgradeChoices"></div>
</div>

<!-- 📊 Overlay hiển thị thống số kỹ năng -->
<div id="statsOverlay" class="hidden">
  <h3>📊 Thống kê</h3>
  <div id="highScoreDisplay" style="text-align: center; font-weight: 300; margin: 2px 0; position: relative; top: -6px;">
  🏆 Kỷ lục: 0
  </div>
  <div id="stat-moveSpeed">👟 Tốc độ chạy: - </div>
  <div id="stat-damage">💥 Dmg: - </div>
  <div id="stat-iceArrow">🏹 Ice Arrow: - </div>
  <div id="stat-speed">💨 Tốc độ: - </div>
  <div id="stat-lineCount">🧨 Số lượng đạn: - </div>
  <div id="stat-blade">🔪 Đao: -</div>
  <div id="stat-sword">⚔️ Kiếm: -</div>
  <div id="stat-fire">🔥 Lửa: -</div>
  <div id="stat-ice">❄️ Băng: -</div>
  <div id="stat-thunder">🔵 Lôi: -</div>
  <div id="stat-skills"></div> <!-- kỹ năng khác -->
  <div id="stat-spawned">🧟 Tổng số zombie: 0</div>
  <div id="stat-alive">🧟 Đang còn sống: 0</div>
  <div id="stat-total">🧟 Đã tiêu diệt: 0</div>
  <div id="stat-breakdown">
    <!-- sẽ được cập nhật bằng JS -->
  </div>
</div>
<!-- 📚 Bảng Kỹ Năng Active mở bằng phím X -->
<div id="skillsOverlay" class="hidden">
<h3>📚 Kỹ năng Active</h3>
<div id="ui-mana" style="text-align: center; font-weight: 300; margin: -6px 0; position: relative; top: -6px;">💠 Mana: 0</div>
<div id="ui-stamina" style="text-align: center; font-weight: 300; margin: -6px 0; position: relative; top: -6px;">🔹 Stamina: 0</div>
<div id="skills-list"></div>
</div>

<!-- 🎯 Hiển thị FPS realtime -->
<div id="fpsCounter" style="
  display: none;
  position: fixed;
  top: 0.2rem;
  left: 0.3rem;
  color: lime;
  background: rgba(0, 0, 0, 0);
  padding: 0.4rem 0.8rem;
  border-radius: 0.5rem;
  font-family: monospace;
  font-size: 0.9rem;
  z-index: 9999;
  pointer-events: none;
">
FPS: --
</div>
<!-- 🎓 Popup kỹ năng khi lên cấp -->
<div id="skillPopup">
  <h3>🎓 Chọn kỹ năng hoặc nâng cấp</h3>
  <div class="upgradeChoices" id="skillChoices"></div>
</div>
<div id="notificationContainer" aria-live="polite"></div>

<!-- Bảng menu gỡ lỗi (Debug Menu) -->
<div id="debugMenu" class="infoOverlay hidden">
  <h3>🔧 Debug Menu </h3>
  <div class="debug-grid">
    
    <label for="debug-level">🧑‍🦰 Level:</label>
    <div class="range-container">
      <input type="range" id="debug-level" min="1" max="100" step="1">
      <span class="range-value">1</span>
    </div>
    <label for="debug-hp">❤️ HP:</label>
    <div class="range-container">
      <input type="range" id="debug-hp" min="1" max="1000" step="1">
      <span class="range-value">10</span>
    </div>
    <label for="debug-mana">💠 Mana:</label>
    <div class="range-container">
      <input type="range" id="debug-mana" min="0" max="1000" step="1">
      <span class="range-value">10</span>
    </div>
    <label for="debug-energy">⚡ Energy:</label>
    <div class="range-container">
      <input type="range" id="debug-energy" min="0" max="1000" step="1">
      <span class="range-value">10</span>
    </div>
    <label for="debug-coin">🪙 Coin:</label>
    <div class="range-container">
      <input type="range" id="debug-coin" min="0" max="1000" step="1">
      <span class="range-value">10</span>
    </div>
    <label for="debug-moveSpeed">👟 Speed:</label>
    <div class="range-container">
      <input type="range" id="debug-moveSpeed" min="0.5" max="5" step="0.1">
      <span class="range-value">1.0</span>
    </div>
    <label for="debug-damage">💥 Sát thương:</label>
    <div class="range-container">
      <input type="range" id="debug-damage" min="1" max="100" step="0.5">
      <span class="range-value">1.0</span>
    </div>
    <label for="debug-iceArrow">🏹 Ice Arrow:</label>
    <div class="range-container">
      <input type="range" id="debug-iceArrow" min="1" max="21" step="1">
      <span class="range-value">1</span>
    </div>
    <label for="debug-bulletSpeed">💨 Tốc độ đạn:</label>
    <div class="range-container">
      <input type="range" id="debug-bulletSpeed" min="0.5" max="10" step="0.1">
      <span class="range-value">1.0</span>
    </div>
    <label for="debug-lineCount">🧨 Số lượng đạn:</label>
    <div class="range-container">
      <input type="range" id="debug-lineCount" min="1" max="10" step="1">
      <span class="range-value">1</span>
    </div>
    <h4 class="debug-subtitle" colspan="2">Trạng thái Game</h4>

    <label for="debug-exp">Exp:</label>
    <input type="number" id="debug-exp" class="custom-input" min="0" max="999999">

    <label for="debug-wave">Wave:</label>
    <div class="range-container">
      <input type="range" id="debug-wave" min="1" max="100" step="1">
      <span class="range-value">1</span>
    </div>

    <label for="debug-dayTime">Giờ trong ngày:</label>
    <div class="range-container">
      <input type="range" id="debug-dayTime" min="0" max="23.5" step="0.5">
      <span class="range-value">6.0</span>
    </div>

    <h4 class="debug-subtitle" colspan="2">Kỹ năng Active</h4>
    <div id="debug-active-skills-container" class="debug-skill-grid">
        
        <div class="debug-skill-wrapper">
            <h5>🛰️ Vệ tinh laze</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-Vệ-tinh-laze">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-Vệ-tinh-laze" min="1" max="2" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-Vệ-tinh-laze">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Vệ-tinh-laze" min="0" max="100" step="1" value="3"><span class="range-value">3</span></div>
            </div>
        </div>

        <div class="debug-skill-wrapper">
            <h5>🚀 Tên lửa F18</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-Tên-lửa-F18">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-Tên-lửa-F18" min="1" max="5" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-Tên-lửa-F18">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Tên-lửa-F18" min="0" max="100" step="1" value="6"><span class="range-value">6</span></div>
            </div>
        </div>

        <div class="debug-skill-wrapper">
            <h5>🛸 UFO tấn công</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-UFO-tấn-công">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-UFO-tấn-công" min="1" max="3" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-UFO-tấn-công">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-UFO-tấn-công" min="0" max="100" step="1" value="5"><span class="range-value">5</span></div>
            </div>
        </div>
        
        <div class="debug-skill-wrapper">
            <h5>🌩️ Bão sét</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-Bão-sét">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-Bão-sét" min="1" max="5" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-Bão-sét">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Bão-sét" min="0" max="100" step="1" value="8"><span class="range-value">8</span></div>
            </div>
        </div>
        
        <div class="debug-skill-wrapper">
            <h5>💣 Bom B52</h5>
            <div class="debug-skill-controls">
                <label for="debug-damage-Bom-B52">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Bom-B52" min="0" max="100" step="1" value="10"><span class="range-value">10</span></div>
            </div>
        </div>

        <div class="debug-skill-wrapper">
            <h5>🎭 Ảo ảnh phân thân</h5>
            <div class="debug-skill-controls">
                <label for="debug-damage-Ảo-ảnh-phân-thân">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Ảo-ảnh-phân-thân" min="0" max="100" step="1" value="5"><span class="range-value">5</span></div>
            </div>
        </div>

        <div class="debug-skill-wrapper">
            <h5>🕳️ Hố đen</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-Hố-đen">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-Hố-đen" min="1" max="2" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-Hố-đen">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Hố-đen" min="0" max="100" step="1" value="7"><span class="range-value">7</span></div>
            </div>
        </div>

        <div class="debug-skill-wrapper">
            <h5>☢️ Boom hạt nhân</h5>
            <div class="debug-skill-controls">
                <label for="debug-damage-Boom-hạt-nhân">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Boom-hạt-nhân" min="0" max="200" step="5" value="100"><span class="range-value">100</span></div>
            </div>
        </div>
        
        <div class="debug-skill-wrapper">
            <h5>🩸 Quả cầu hấp huyết</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-Quả-cầu-hấp-huyết">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-Quả-cầu-hấp-huyết" min="1" max="2" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-Quả-cầu-hấp-huyết">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Quả-cầu-hấp-huyết" min="0" max="100" step="1" value="2"><span class="range-value">2</span></div>
            </div>
        </div>
        
        <div class="debug-skill-wrapper">
            <h5>🌀 Cổng Không Gian</h5>
            <div class="debug-skill-controls">
                <label for="debug-damage-Cổng-Không-Gian">Sát thương:</label>
                <div class="range-container"><input type="range" id="debug-damage-Cổng-Không-Gian" min="0" max="100" step="1" value="99"><span class="range-value">99</span></div>
            </div>
        </div>
    </div>

    <h4 class="debug-subtitle" colspan="2">Nâng cấp Kỹ năng</h4>

    <label for="debug-bladeCount">🔪 Số lượng đao:</label>
    <div class="range-container">
        <input type="range" id="debug-bladeCount" min="2" max="20" step="1">
        <span class="range-value">2</span>
    </div>
    <label for="debug-bladeDamage">🔪 Dmg đao:</label>
    <div class="range-container">
        <input type="range" id="debug-bladeDamage" min="1" max="50" step="0.5">
        <span class="range-value">1.0</span>
    </div>
    <label for="debug-swordLevel">⚔️ Cấp mưa kiếm:</label>
    <div class="range-container">
        <input type="range" id="debug-swordLevel" min="1" max="10" step="1">
        <span class="range-value">1</span>
    </div>
    <label for="debug-swordDamage">⚔️ Dmg kiếm:</label>
    <div class="range-container">
        <input type="range" id="debug-swordDamage" min="1" max="50" step="0.5">
        <span class="range-value">1.0</span>
    </div>
    <label for="debug-fireCount">🔥 Số lượng lửa:</label>
    <div class="range-container">
        <input type="range" id="debug-fireCount" min="2" max="10" step="1">
        <span class="range-value">2</span>
    </div>
    <label for="debug-fireDamage">🔥 Dmg lửa:</label>
    <div class="range-container">
        <input type="range" id="debug-fireDamage" min="1" max="50" step="0.5">
        <span class="range-value">1.0</span>
    </div>
    <label for="debug-iceCount">❄️ Số lượng băng:</label>
    <div class="range-container">
        <input type="range" id="debug-iceCount" min="2" max="10" step="1">
        <span class="range-value">2</span>
    </div>
    <label for="debug-iceDamage">❄️ Dmg băng:</label>
    <div class="range-container">
        <input type="range" id="debug-iceDamage" min="1" max="50" step="0.5">
        <span class="range-value">1.0</span>
    </div>
    <label for="debug-thunderCount">🔵 Số lượng lôi:</label>
    <div class="range-container">
        <input type="range" id="debug-thunderCount" min="2" max="6" step="1">
        <span class="range-value">2</span>
    </div>
    <label for="debug-thunderDamage">🔵 Dmg lôi:</label>
    <div class="range-container">
        <input type="range" id="debug-thunderDamage" min="1" max="50" step="0.5">
        <span class="range-value">1.0</span>
    </div>
<label for="debug-auraHealLevel">✨ Cấp Heal Aura:</label>
    <div class="range-container">
        <input type="range" id="debug-auraHealLevel" min="0" max="5" step="1">
        <span class="range-value">0</span>
    </div>

    <label for="debug-fairyCount">🦋 Số lượng Fairy:</label>
    <div class="range-container">
        <input type="range" id="debug-fairyCount" min="1" max="3" step="1">
        <span class="range-value">1</span>
    </div>

    <label for="debug-fairyHealLevel">🦋 Cấp Heal Fairy:</label>
    <div class="range-container">
        <input type="range" id="debug-fairyHealLevel" min="0" max="10" step="1">
        <span class="range-value">0</span>
    </div>
    
    <label for="debug-fairyDamageLevel">🦋 Cấp Dmg Fairy:</label>
    <div class="range-container">
        <input type="range" id="debug-fairyDamageLevel" min="0" max="10" step="1">
        <span class="range-value">0</span>
    </div>

  </div>
  <div class="debug-buttons">
    <button id="applyDebugChanges">Áp dụng</button>
    <button id="closeDebugMenu">Đóng</button>
  </div>
</div>

<!--Menu game ESC-->
<div id="pauseMenu" class="infoOverlay hidden">
  <h2>Cài đặt</h2>
  
  <div class="settings-section">
    <h3>Âm thanh</h3>
    <div class="debug-grid">
      <label for="volume-master">Âm lượng Tổng:</label>
      <div class="range-container">
        <input type="range" id="volume-master" min="0" max="1" step="0.05" value="1">
        <span class="range-value">100%</span>
      </div>
      
      <label for="volume-music">Nhạc nền:</label>
      <div class="range-container">
        <input type="range" id="volume-music" min="0" max="1" step="0.05" value="0.5">
        <span class="range-value">50%</span>
      </div>

      <label for="volume-sfx">Hiệu ứng (SFX):</label>
      <div class="range-container">
        <input type="range" id="volume-sfx" min="0" max="1" step="0.05" value="0.8">
        <span class="range-value">80%</span>
      </div>
    </div>
  </div>

  <div class="pause-menu-buttons">
    <button id="resumeBtn">Tiếp tục</button>
    <button id="restartBtnPause">Chơi lại</button>
    <button id="guideBtnPause">Hướng dẫn</button>
    <button id="infoBtnPause">Thông tin</button>
    <button id="exitBtn">Menu</button>
  </div>
</div>
<!-- ℹ️ Overlay Shop -->
<div id="shopOverlay" class="infoOverlay hidden">
  <h2><i class="fas fa-store"></i> Cửa hàng Zombie Survivor </h2>
  <div class="shop-balance">Xu: <span id="shopCoinBalance">0</span> 🪙</div>
  
  <div id="shopItemsContainer" class="shop-grid">
    </div>

  <div class="shop-buttons">
    <button id="closeShopBtn">Đóng</button>
  </div>
</div>
<!-- Hiển thị đạn -->
<div id="ammoDisplay"></div>
<!-- 🎵 Âm thanh nền và hiệu ứng âm thanh -->
<audio id="music-background" src="sounds/background-music.mp3"></audio>
<audio id="music-background-2" src="sounds/background-music-2.mp3"></audio>
<audio id="music-background-3" src="sounds/background-music-3.mp3"></audio>
<audio id="music-boss" src="sounds/boss-music.mp3" loop></audio>

<audio id="sfx-shoot" src="sounds/shoot.mp3"></audio>
<audio id="sfx-zombie-die" src="sounds/zombie-die.mp3"></audio>
<audio id="sfx-pickup" src="sounds/pickup.mp3"></audio>
<audio id="sfx-pickup-coin" src="sounds/pickup-coin.mp3"></audio>
<audio id="sfx-level-up" src="sounds/level-up.mp3"></audio>
<audio id="sfx-laser" src="sounds/laser.mp3"></audio>
<audio id="sfx-bigboss-laser" src="sounds/bigboss-laser.mp3" loop></audio>
<audio id="sfx-nuke-fall" src="sounds/nuke-fall.mp3"></audio>
<audio id="sfx-nuke-explode" src="sounds/nuke-explode.mp3"></audio>
<audio id="sfx-lazer-charging" src="sounds/lazer-charging.mp3" loop></audio>
<audio id="sfx-shield-block" src="sounds/shield-block.mp3"></audio>
<audio id="sfx-game-over" src="sounds/game-over.mp3"></audio>
<audio id="sfx-player-hurt" src="sounds/player-hurt.mp3"></audio>
<audio id="sfx-player-explode" src="sounds/player-explode.mp3"></audio>
<audio id="sfx-powerup" src="sounds/powerup.mp3"></audio>
<audio id="sfx-game-start" src="sounds/game-start.mp3"></audio>
<audio id="sfx-ui-click" src="sounds/ui-click.mp3"></audio>
<audio id="sfx-lucky-loop" src="sounds/lucky-active-loop.mp3" loop></audio>
<audio id="sfx-power-loop" src="sounds/power-active-loop.mp3" loop></audio>
<audio id="sfx-upgrade-select" src="sounds/upgrade-select.mp3"></audio>
<audio id="sfx-wave-up" src="sounds/wave-up.mp3"></audio>
<audio id="sfx-nuke-time" src="sounds/nuke-time.mp3"></audio>
<audio id="sfx-crazy-loop" src="sounds/crazy-active-loop.mp3" loop></audio>
<audio id="sfx-exp-loop" src="sounds/exp-active-loop.mp3" loop></audio>
<audio id="sfx-supply-drop-item" src="sounds/supply-drop-item.mp3"></audio>

<!-- 🌐 Các tệp JavaScript chính -->
<script src="equipment_drop.js"></script>
<script src="character_panel.js"></script>
<script src="news_ticker.js"></script> </body>

</body>
</html>
