<!--üéÆ Zombie Survivor  ‚ú® Version: 1.2  üñãÔ∏è T√°c gi·∫£: Dang -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Zombie Survivor - Dang</title>
<style>
  :root {
  /* üé® M√†u s·∫Øc ch√≠nh */
  --color-bg-dark: #111;
  --color-primary: #00ffff;
  --color-accent: gold;
  --color-danger: #ff4c4c;
  --color-text: #e0f7fa;
  --color-hover-bg: #22404c;
  --color-hover-border: #3d6c78;
  --color-title: #aefeff;
  --glow-title: 0 0 6px #7f7fff, 0 0 12px #4d4dfb;
 
  /* üåà M√†u s·∫Øc giao di·ªán */
  --menu-width: 26rem;
  --menu-min-height: 20rem;
  --menu-radius: 1rem;
  --menu-padding: 2rem 1.5rem;

  /* üîò M√†u button ri√™ng */
  --btn-bg: #1a2b33;
  --btn-border: #294e5a;

  /* üî§ K√≠ch th∆∞·ªõc font ch·ªØ */
  --font-xs: 0.75rem;
  --font-sm: 0.9rem;
  --font-md: 1rem;
  --font-lg: 1.25rem;
  --font-xl: 1.5rem;
  --font-xxl: 2.5rem;

  /* üìè K√≠ch th∆∞·ªõc padding/margin chu·∫©n */
  --space-xs: 0.4rem;
  --space-sm: 0.6rem;
  --space-md: 1rem;
  --space-lg: 1.5rem;
  --space-xl: 2rem;

  /* üåü ƒê·ªô s√°ng b√≥ng / hi·ªáu ·ª©ng */
  --glow-primary: 0 0 8px var(--color-primary);
  --glow-accent: 0 0 8px var(--color-accent);
}

  body { margin: 0; background: #111; overflow: hidden; font-family: sans-serif;
  background-image: url('images/foggy-graveyard.png');
  background-size: cover;
  background-position: center center;
  background-repeat: no-repeat;
  background-attachment: fixed;}
  canvas { display: block; margin: auto; transition: background 1s ease; }
/* üéØ Giao di·ªán ch√≠nh */
#ui {
  position: absolute;
  top: 0vh; /* c√°ch top theo chi·ªÅu cao m√†n h√¨nh */
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 0.2rem; /* kho·∫£ng c√°ch gi·ªØa c√°c n√∫t */
  padding: 0.2rem 0.2rem; 
  background: rgb(0, 0, 0); /* n·ªÅn trong su·ªët */
  width: 90%; /* t·ª∑ l·ªá theo chi·ªÅu ngang */
  max-width: 60rem; /* gi·ªõi h·∫°n t·ªëi ƒëa */
  justify-content: center;
  z-index: 1000;
  flex-wrap: wrap;
  border-radius: 10px;
}
/* Style chung cho c·∫£ hai logo */
.ui-logo {
  position: fixed; /* ƒê·ªãnh v·ªã c·ªë ƒë·ªãnh tr√™n m√†n h√¨nh */
  top: 1.2rem;     /* V·ªã tr√≠ c√°ch ƒë·ªânh */
  color: var(--color-title);
  font-family: 'Segoe UI', sans-serif;
  font-weight: bold;
  text-shadow: 0 0 4px var(--color-primary);
  z-index: 1001;   /* Lu√¥n n·ªïi l√™n tr√™n thanh UI */
  pointer-events: none; /* Cho ph√©p click xuy√™n qua logo */
}

/* Style ri√™ng cho logo b√™n tr√°i */
.left-logo {
  left: 18.1rem; /* V·ªã tr√≠ c√°ch l·ªÅ tr√°i */
  line-height: 1;
  font-size: 0.8rem;
  text-align: center;
}

/* Style ri√™ng cho logo b√™n ph·∫£i */
.right-logo {
  right: 18.1rem; /* V·ªã tr√≠ c√°ch l·ªÅ ph·∫£i */
  line-height: 1;
  font-size: 0.8rem;
  text-align: center;
}
/* üîò N√∫t trong UI (nh·ªè g·ªçn h∆°n n√∫t m·∫∑c ƒë·ªãnh) */
#ui button {
  padding: 0.6rem 0.6rem;
  font-size: 0.75rem;
  min-width: 4.5rem;
  margin-bottom: 0.6rem;
  margin-top: 0.6rem;
}

/* üîò N√∫t m·∫∑c ƒë·ªãnh cho to√†n giao di·ªán */
button {
  font-family: 'Segoe UI', sans-serif;
  padding: 0.65rem 1.25rem;
  font-size: 1rem;
  cursor: pointer;
  min-width: 5rem;
  text-align: center;
  background-color: #1a2b33;
  border: 0.125rem solid #294e5a;
  border-radius: 0.5rem;
  color: #e0f7fa;
  transition: all 0.2s ease;
  box-shadow: 0 0.125rem 0.3rem rgba(0, 0, 0, 0.2);
}

/* üîÅ Hi·ªáu ·ª©ng hover cho n√∫t */
button:hover {
  background-color: #22404c;
  border-color: #3d6c78;
  color: #ffffff;
  transform: translateY(-0.06rem);
}

/* üñ± Hi·ªáu ·ª©ng khi click gi·ªØ */
button:active {
  transform: scale(0.97);
  box-shadow: 0 0.06rem 0.2rem rgba(0, 0, 0, 0.3);
}

/* ‚ú≥Ô∏è N√∫t ƒëang active */
button.active {
  border-color: #00ffff;
  box-shadow: 0 0 0.5rem #00ffffaa;
}

/* Tr·∫°ng th√°i active d√πng cho nhi·ªÅu th√†nh ph·∫ßn */
.active {
  outline: 0rem solid gold;
  border-radius: 2.5rem;
}

/* üìä V√πng hi·ªÉn th·ªã ƒëi·ªÉm s·ªë ho·∫∑c th√¥ng tin */
#score {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-width: 7.5rem;
  text-align: center;
  color: white;
  font-size: 0.8rem;
  padding: 0.2rem 0.2rem;
}

/* üîÑ N√∫t restart ƒë·∫∑c bi·ªát */
#restartBtn {
  padding: 0.75rem 1.75rem;
  font-weight: bold;
  background-color: #1c2e36;
  border: 0.125rem solid #3a6b75;
  border-radius: 0.5rem;
  font-size: 1rem;
  color: #aefeff;
  cursor: pointer;
  transition: 0.25s ease;
}

/* üñ± Hover cho restart */
#restartBtn:hover {
  background-color: #28515f;
  color: white;
  transform: translateY(-0.06rem);
}

/* ‚è≥ Hi·ªÉn th·ªã ƒë·ªìng h·ªì ƒë·∫øm wave */
#waveTimerDisplay {
  position: fixed;
  top: 10vh;
  left: 48.5%;
  transform: translateX(-50%);
  font-size: 1.2rem;
  color: gold;
  z-index: 10;
  text-shadow: 0 0 8px gold;
  font-weight: bold;
  font-family: 'Courier New', monospace;
  letter-spacing: 0.1rem;
  pointer-events: none;
}

/* üåä Popup khi b·∫Øt ƒë·∫ßu Wave */
#wavePopup {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 2.5rem;
  font-weight: bold;
  color: #fff3b0;
  text-shadow:
    0 0 6px #ffd54f,
    0 0 12px #ffb300;
  background: none;
  border: none;
  pointer-events: none;
  z-index: 1000;
  transition: opacity 0.5s ease;
  opacity: 0;
}

/* ‚ú® Animation xu·∫•t hi·ªán m·ªÅm m∆∞·ª£t */
@keyframes waveFade {
  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.7); }
  50% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
  100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
}

/* üìã Menu b·∫Øt ƒë·∫ßu game */
#startMenu {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  width: 90%;
  position: fixed;
  top: 55%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  border-radius: var(--menu-radius);
  padding: var(--menu-padding);
  max-width: var(--menu-width);
  min-height: 26rem;
  text-align: center;
  background: linear-gradient(to bottom, #0e1a26, #0a121a);
  backdrop-filter: blur(6px);
  border: 1px solid #446688;
  box-shadow:
    0 0 8px rgba(102, 170, 255, 0.1),
    inset 0 0 6px rgba(102, 170, 255, 0.05);
  z-index: 999;
}
#startMenu:hover {
  box-shadow:
    0 0 12px rgb(0, 153, 255),
    inset 0 0 8px rgba(0, 187, 255, 0.393);
}
#startMenu .btn-group {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 1rem;
}
#startMenu button {
  min-width: 14rem;
}
#startMenu button:hover {
  border-radius: 2.5rem;
}
/* üåü Popup khi l√™n c·∫•p */
#levelUpPopup {
  position: fixed;
  top: 40%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 2.5rem;
  color: gold;
  font-weight: bold;
  text-shadow: 0 0 15px #ffff00;
  display: none;
  z-index: 10003;
}

/* üíÄ Panel Game Over hi·ªÉn th·ªã khi thua */
.gameOverPanel {
  max-width: var(--menu-width);
  min-height: var(--menu-min-height);
  min-width: 20rem;
  position: fixed;
  top: 50%;
  left: 50%;
  /* B·∫Øt ƒë·∫ßu ·∫©n v√† nh·ªè */
  transform: translate(-50%, -50%) scale(0.7);
  opacity: 0;
  visibility: hidden; /* D√πng visibility ƒë·ªÉ ·∫©n ho√†n to√†n */

  color: white;
  display: flex; /* Gi·ªØ l·∫°i flex ƒë·ªÉ cƒÉn gi·ªØa n·ªôi dung */
  flex-direction: column;
  align-items: center;
  gap: var(--space-md);
  backdrop-filter: blur(6px);
  z-index: 2000;
  padding: var(--menu-padding);
  border: 2px solid #ff5722;
  background: linear-gradient(145deg, #1a0f0f, #300d0d);
  box-shadow: 0 0 1rem #ff572288;
  border-radius: var(--menu-radius);
  text-align: center;
  
  /* Hi·ªáu ·ª©ng chuy·ªÉn ƒë·ªông */
  transition: opacity 0.4s ease-out, transform 0.4s ease-out, visibility 0.4s;
}
.gameOverPanel button {
  width: 14rem; /* Chi·ªÅu r·ªông c·ªë ƒë·ªãnh */
}
.gameOverPanel:hover {
  box-shadow: 0 0 2.5rem #ff5722aa;
}
.gameOverPanel button:hover {
  box-shadow: 0 0 1.5rem #ff5722aa;
  border-radius: 2.5rem;
}
/* Khi c√≥ class 'visible', panel s·∫Ω hi·ªán ra */
.gameOverPanel.visible {
  opacity: 1;
  visibility: visible;
  transform: translate(-50%, -50%) scale(1);
}

/* üéØ Ti√™u ƒë·ªÅ Game Over */
.gameOverTitle {
  color: #ff5722;
  font-size: 3.5rem;
  text-shadow: 0 0 4px #ffff00, 0 0 4px #ffff00;
  margin-bottom: 1rem;
}

/* üîÅ N√∫t Ch∆°i l·∫°i trong Game Over Panel */
.restartButton {
  margin-top: 1rem;
  padding: 0.65rem 1.25rem;
  font-size: 1.2rem;
  font-weight: 300;
  background-color: #330000;
  color: #fff5cc;
  border: 2px solid #ff9800;
  border-radius: 0.75rem;
  cursor: pointer;
  box-shadow: 0 0 0.5rem #ff5722aa;
  transition: all 0.25s ease;
  text-shadow: 0 0 3px #ffaa00;
}

.restartButton:hover {
  background-color: #551100;
  color: #ffffff;
  transform: scale(1.05);
  box-shadow: 0 0 1rem #ff5722cc;
}

/* üïπÔ∏è Ti√™u ƒë·ªÅ game ·ªü menu b·∫Øt ƒë·∫ßu */
.gameTitle {
  font-size: 2.5rem;
  font-weight: 900;
  color: var(--color-title);
  text-shadow: var(--glow-title);
  margin-bottom: 1.5rem;
  font-family: 'Segoe UI', sans-serif;
}

/* ‚ö†Ô∏è Popup c·∫£nh b√°o (d√πng cho showWarning) */
.warningPopup{
  position:fixed;
  top:20%;                /* ‚ë† ƒë·∫∑t t√¢m d·ªçc  */
  left:50%;               /* ‚ë° ƒë·∫∑t t√¢m ngang */
  transform:translate(-50%,-50%); /* ‚ë¢ k√©o ng∆∞·ª£c l·∫°i 50 % k√≠ch th∆∞·ªõc ch√≠nh n√≥ */
  background:rgba(0,32,64,.9);
  color:var(--color-text);
  padding:var(--space-sm) var(--space-lg);
  border-radius:.75rem;
  font:var(--font-md) 'Segoe UI',sans-serif;
  font-weight:500;
  z-index:9999;
  box-shadow:0 0 10px #00bcd4aa;
  pointer-events:none;
  animation:popupFade 1.5s ease-out forwards;
  max-width:70vw;         /* n·∫øu text qu√° d√†i s·∫Ω t·ª± xu·ªëng h√†ng */
  text-align:center;
}

/*  V√¨ transform nay ƒë√£ ch·ª©a translate(-50%,-50%),
    animation ch·ªâ l·∫Øc tr·ª•c Y th√™m m·ªôt ch√∫t  */
@keyframes popupFade{
  0%   {opacity:0; transform:translate(-50%,-30%);}
  10%  {opacity:1; transform:translate(-50%,-50%);}
  90%  {opacity:1; transform:translate(-50%,-50%);}
  100% {opacity:0; transform:translate(-50%,-70%);}
}
#notificationContainer{
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translate(-50%, -50%); /* cƒÉn gi·ªØa khay */
  display: flex;
  flex-direction: column;             /* x·∫øp d·ªçc */
  align-items: center;                /* m·ªói popup v·∫´n gi·ªØa ngang */
  gap: .5rem;                         /* kho·∫£ng c√°ch gi·ªØa c√°c popup */
  pointer-events: none;
  z-index: 10000;
}

/* ‚ú® Popup b√™n trong khay */
#notificationContainer .warningPopup{
  position: relative;                 /* relative ‚Üí theo khay */
  left: auto; top: 0;
  transform: none;                    /* khay ƒë√£ lo cƒÉn gi·ªØa */
  animation: popupFadeStack 1.5s ease-out forwards;
}

@keyframes popupFadeStack{
  0%   {opacity:0;   transform: translateY(20px);}
  10%  {opacity:1;   transform: translateY(0);}
  90%  {opacity:1;}
  100% {opacity:0;   transform: translateY(-20px);}
}

/* üåü Giao di·ªán popup n√¢ng c·∫•p */
#upgradePopup {
  /* display: none; */ /* B·ªè display none ƒë·ªÉ d√πng opacity v√† visibility */
  opacity: 0;
  visibility: hidden;
  transform: translate(-50%, -50%) scale(0.9); /* B·∫Øt ƒë·∫ßu nh·ªè h∆°n m·ªôt ch√∫t */
  transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s; /* Hi·ªáu ·ª©ng chuy·ªÉn ƒë·ªông */
  
  position: fixed;
  top: 50%;
  left: 50%;
  background: rgba(0, 0, 0, 0.85);
  border: 2px solid gold;
  padding: 2rem;
  border-radius: 1rem;
  z-index: 9999;
  max-width: 42rem;
  width: 90%;
  text-align: center;
  box-shadow: 0 0 15px gold;
}

/* Th√™m class .visible ƒë·ªÉ k√≠ch ho·∫°t hi·ªáu ·ª©ng */
#upgradePopup.visible {
    opacity: 1;
    visibility: visible;
    transform: translate(-50%, -50%) scale(1);
}
.upgradeTitle {
  color: gold;
  font-size: 1.8rem;
  font-weight: bold;
  margin-bottom: 1.5rem;
  text-shadow: 0 0 6px gold;
  margin-top: 1rem;
}

.upgradeChoices {
  display: flex;
  justify-content: space-evenly;
  gap: 1rem;
  flex-wrap: wrap;
}

.upgradeChoices button {
  padding: 0.8rem 1.2rem;
  border: 2px solid #ccc;
  border-radius: 0.6rem;
  background: #111;
  color: white;
  font-size: 1rem;
  font-weight: bold;
  min-width: 8rem;
  cursor: pointer;
  transition: 0.2s ease;
}

.upgradeChoices button:hover {
  background: #22404c;
  border-color: gold;
  color: #fff;
  box-shadow: 0 0 10px gold;
  border-radius: 2.5rem;
}

/* üìä Overlay th·ªëng k√™ */
#statsOverlay {
  position: fixed;
  top: 0.2rem;
  right: 0.5rem;
  bottom: 0.5rem;
  background: rgba(0, 0, 0, 0.7);
  border: 2px solid #00ffff;
  border-radius: 1rem;
  padding: 1rem;
  color: #e0f7fa;
  font-size: 0.95rem;
  line-height: 1.5;
  z-index: 9999;
  width: 15rem;
  font-family: 'Segoe UI', sans-serif;
}

#statsOverlay h3 {
  font-size: 1rem;
  margin-top: 0;
  margin-bottom: 0.5rem;
  color: gold;
  text-align: center;
}

#statsOverlay.hidden {
  display: yes;
}
/* üìö Giao di·ªán b·∫£ng k·ªπ nƒÉng active */
#skillsOverlay {
  position: fixed;
  top: 0.2rem;
  left: 0.5rem;
  bottom: 0.5rem;
  background: rgba(0, 0, 0, 0.7);
  border: 2px solid #00ffff;
  border-radius: 1rem;
  padding: 1rem;
  color: #e0f7fa;
  font-size: 0.95rem;
  line-height: 1.5;
  z-index: 9999;
  width: 15rem;
  font-family: 'Segoe UI', sans-serif;
}

#skillsOverlay h3 {
  font-size: 1rem;
  margin-top: 0;
  margin-bottom: 0.5rem;
  color: gold;
  text-align: center;
}

#skillsOverlay.hidden {
  display: yes;
}
/* Safe Zone: kho√° n√∫t k·ªπ nƒÉng */
.skill-item.disabled {
  opacity: 0.8;
  filter: grayscale(0.8);
  z-index: 10001;
}
/* Kh√≥a n√∫t ·ªü thanh tr√™n khi trong Safe Zone */

.safe-ui-btn-disabled {
  opacity: 0.8;
  filter: grayscale(0.8);
  z-index: 10001;
}
.skill-item {
  margin-bottom: 0.5rem;
  padding: 0.4rem;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 0.5rem;
  cursor: pointer;
  transition: background 0.3s;
}

.skill-item:hover {
  background: rgba(0, 255, 255, 0.3);
  border-radius: 2.5rem;
}

.skill-icon {
  font-size: 1.2rem;
  margin-right: 0.5rem;
}
#skillPopup {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 32, 64, 0.9);
  border: 2px solid #00ffff;
  padding: 2rem;
  border-radius: 1rem;
  z-index: 9999;
  max-width: 42rem;
  width: 90%;
  text-align: center;
  box-shadow: 0 0 15px #00ffffaa;
}

#skillPopup h3 {
  color: #00ffff;
  font-size: 1.6rem;
  font-weight: bold;
  margin-bottom: 1.2rem;
  text-shadow: 0 0 6px #00ffff;
}

#skillPopup .upgradeChoices {
  display: flex;
  justify-content: space-evenly;
  gap: 1rem;
  flex-wrap: wrap;
}

#skillPopup .upgradeChoices button {
  padding: 0.8rem 1rem;
  border: 2px solid #0d1aa0; /* m√†u k·ªπ nƒÉng active */
  border-radius: 0.6rem;
  background: #001f2f;
  color: white;
  font-size: 1rem;
  font-weight: bold;
  min-width: 9rem;
  cursor: pointer;
  transition: 0.2s ease;
}
#skillPopup .upgradeChoices button:hover {
  background: #003344;
  border-color: cyan;
  box-shadow: 0 0 10px cyan;
  border-radius: 2.5rem;
}

.skill-item.active {
  border: 0px solid #00ffff;
  background: rgba(0, 255, 255, 0.2);
  box-shadow: 0 0 4px cyan;
  pointer-events: none; /* kh√¥ng cho click v√†o k·ªπ nƒÉng ƒë√£ ch·ªçn */
  border-radius: 2.5rem;
}
.infoOverlay {
  position: fixed;
  top: 55%; left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(10, 25, 40, 0.95); /* xanh ƒëen d·ªãu */
  border: 2px solid #446688;
  border-radius: var(--menu-radius);
  max-width: 26rem;
  min-height: 26rem;
  width: 90%;
  padding: var(--menu-padding);
  box-shadow: 0 0 10px rgba(50, 100, 150, 0.3);
  color: #eef;
  z-index: 9999;
  font-family: 'Segoe UI', sans-serif;
  font-size: 0.95rem;
  line-height: 1.6; /* kho·∫£ng c√°ch d√≤ng */
  text-align: center;
}
.spacer {
  height: 5rem;  /* ho·∫∑c 4rem t√πy ƒë·ªô cao b·∫°n mu·ªën */
}
/* üîß Spacer c√¢n b·∫±ng layout trong overlay h∆∞·ªõng d·∫´n */
.spacerguide {
  height: 4rem; /* kho·∫£ng c√°ch gi·ªØa c√°c m·ª•c */
}

.infoOverlay button {
  min-width: 14rem;
}
.infoOverlay button:hover {
  border-radius: 2.5rem;
}
.custom-input {
  font-family: 'Segoe UI', sans-serif;
  padding: 0.65rem 1.25rem;
  font-size: 0.9rem;
  min-width: 10rem;
  width: 100%;
  max-width: 11.5rem;
  text-align: center;
  background-color: #1a2b33;
  border: 0.125rem solid #294e5a;
  border-radius: 0.5rem;
  color: #e0f7fa;
  transition: all 0.2s ease;
  box-shadow: 0 0.125rem 0.3rem rgba(0, 0, 0, 0.2);
}

.custom-input:focus {
  outline: none;
  background-color: #22404c;
  border-color: #3d6c78;
  color: #ffffff;
  box-shadow: 0 0 0.625rem #00ffffaa;
  border-radius: 2.5rem;
}
#waveNumberDisplay {
  position: fixed;
  top: 14vh; /* gi·ªëng waveTimerDisplay */
  left: 48.5%; /* l·ªách ph·∫£i so v·ªõi th·ªùi gian ·ªü 50% */
  transform: translateX(-50%);
  font-size: 1.1rem;
  color: #aefeff;
  font-weight: bold;
  text-shadow: 0 0 6px #00ffff;
  z-index: 10;
  pointer-events: none;
}
#miniMap {
  position: fixed;
  top: 6.5rem;
  right: 18rem;
  width: 150px;
  height: 150px;
  border: 2px solid #00ffff;
  border-radius: 0.5rem;
  background: rgba(0, 0, 0, 0.4);
  z-index: 9999;
  display: none; /* ·∫©n mini map ban ƒë·∫ßu */
}
/* Tooltip cho item trong b·∫£ng k·ªπ nƒÉng (ph√≠m X) */
.skill-item[data-tooltip] {
  position: relative;
}
.skill-item[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  left: 105%;               /* hi·ªán b√™n ph·∫£i b·∫£ng */
  top: -2rem;
  transform: translateY(var(--tip-shift,0)); /* D·ªäCH theo bi·∫øn */
  margin-left: .6rem;
  min-width: 18rem;
  white-space: pre-line;    /* xu·ªëng d√≤ng theo \n */
  padding: .55rem .7rem;
  font-size: .8rem;
  background: rgba(0,0,0,.85);
  color: #e0f7fa;
  border: 1px solid #00ffff;
  border-radius: .5rem;
  pointer-events: none;
  opacity: 0;
  transition: opacity .25s;
  z-index: 10000;
}
.skill-item:hover::after { opacity: 1; }
#bigBossRespawnDisplay {
    position: fixed;
    top: 10vh;
    left: 29.1vw;
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid violet;
    border-radius: 0.5rem;
    padding: 0.4rem 0.6rem;
    color: violet;
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    text-align: center;
    min-width: 6rem;
    z-index: 10;
    text-shadow: 0 0 5px violet;
}
/* CSS cho b·ªô ƒë·∫øm ng√†y m·ªõi */
#dayCounterDisplay {
    position: fixed;
    top: 10vh; /* C√πng ƒë·ªô cao v·ªõi BigBoss */
    left: 23.2vw; /* ƒê·∫∑t ·ªü v·ªã tr√≠ b√™n ph·∫£i c·ªßa BigBoss */
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid gold;
    border-radius: 0.5rem;
    padding: 0.4rem 0.6rem;
    color: gold;
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    text-align: center;
    min-width: 4rem;
    z-index: 10;
    text-shadow: 0 0 5px gold;
}
#ui button[data-tooltip] {
  position: relative;
}

#ui button[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  left: 110%;
  top: 3.5rem;
  transform: translateX(-40%);
  margin-left: .6rem;
  min-width: 18rem;
  white-space: pre-line;
  padding: .55rem .7rem;
  font-size: .8rem;
  background: rgba(0, 0, 0, 0.85);
  color: #e0f7fa;
  border: 1px solid #00ffff;
  border-radius: .5rem;
  pointer-events: none;
  opacity: 0;
  transition: opacity .25s;
  text-align: left; /* ch·ªØ canh tr√°i */
  z-index: 10000;
}

#ui button:hover::after {
  opacity: 1;
}
#ui button:hover {
  border-radius: 2.5rem; /* bo tr√≤n khi hover */
}
/* --- CSS cho Debug Menu --- */
#debugMenu {
  max-width: 26rem;
  width: 90%;
  padding-bottom: 1rem;
  
  /* Gi·ªõi h·∫°n chi·ªÅu cao v√† d√πng Flexbox */
  display: flex;
  flex-direction: column;
  max-height: 80vh; /* Chi·ªÅu cao */
  z-index: 10009;
}
.debug-buttons {
  display: flex;
  justify-content: center; /* CƒÉn gi·ªØa theo chi·ªÅu ngang */
  align-items: center; /* CƒÉn gi·ªØa theo chi·ªÅu d·ªçc */
  gap: 10px;
  margin-top: 15px; /* T·∫°o kho·∫£ng c√°ch v·ªõi c√°c ph·∫ßn t·ª≠ ph√≠a tr√™n */
}

#applyDebugChanges,
#closeDebugMenu {
  padding: 8px 16px;
  font-size: 1rem;
  cursor: pointer;
  border: 1px solid transparent;
  transition: all 0.3s ease;
}
.debug-grid {
  display: grid;
  grid-template-columns: auto 1fr; 
  gap: 0.8rem 1rem;
  align-items: center;
  margin-bottom: 1rem;
  text-align: left;

  /* Cho ph√©p cu·ªôn d·ªçc khi n·ªôi dung d√†i h∆°n */
  overflow-y: auto;
  padding-right: 1rem; /* Th√™m kho·∫£ng ƒë·ªám nh·ªè tr√°nh n·ªôi dung s√°t vi·ªÅn */

  /* --- C√°c thu·ªôc t√≠nh ƒë·ªÉ ·∫©n thanh cu·ªôn --- */
  /* Cho Firefox */
  scrollbar-width: none;
  /* Cho Internet Explorer v√† Edge */
  -ms-overflow-style: none;
}

/* Cho c√°c tr√¨nh duy·ªát Webkit (Chrome, Safari, Edge m·ªõi) */
.debug-grid::-webkit-scrollbar {
    display: none;
}

/* Th√™m ƒë·ªãnh nghƒ©a ƒë·ªÉ ·∫©n Debug Menu khi c√≥ class 'hidden' */
#debugMenu.hidden {
    display: none;
}
.debug-subtitle {
  grid-column: 1 / -1; /* Ti√™u ƒë·ªÅ chi·∫øm tr·ªçn chi·ªÅu r·ªông c·ªßa grid */
  text-align: center;
  color: gold;
  margin-top: 1rem;
  margin-bottom: 0.5rem;
  border-top: 1px solid #446688;
  padding-top: 1rem;
}
/* Ch·ªânh l·∫°i chi·ªÅu r·ªông cho √¥ nh·∫≠p s·ªë Kill */
#debug-kill.debug-input {
    width: 10em; /* Gi·ªõi h·∫°n chi·ªÅu r·ªông */
    justify-self: start; /* CƒÉn l·ªÅ tr√°i trong √¥ layout */
}

/* --- CSS cho khu v·ª±c debug k·ªπ nƒÉng active --- */
.debug-skill-grid {
  grid-column: 1 / -1; /* Chi·∫øm tr·ªçn chi·ªÅu r·ªông c·ªßa grid cha */
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.debug-skill-wrapper {
  background: rgba(0,0,0,0.2);
  padding: 0.75rem;
  border-radius: 0.5rem;
  border: 1px solid #294e5a;
}

.debug-skill-wrapper h5 {
  margin: 0 0 0.75rem 0;
  color: white;
  font-weight: 600;
  font-size: 1.1rem;
}

.debug-skill-controls {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 0.8rem 1rem;
    align-items: center;
    font-size: 0.9rem;
}
/* CSS cho b·ªô ƒë·∫øm Xu (Coin) */
#coinCounterDisplay {
  position: fixed;
  top: 10vh; /* C√πng ƒë·ªô cao v·ªõi Wave */
  left: 41%; /* V·ªã tr√≠ b√™n ph·∫£i c·ªßa Wave */
  border: 2px solid gold;
  border-radius: 0.5rem;
  padding: 0.3rem 0.6rem;
  transform: translateX(-50%);
  font-size: 0.8rem;
  color: gold; /* M√†u v√†ng cho h·ª£p v·ªõi coin */
  font-weight: normal;
  text-shadow: 0 0 2px gold;
  z-index: 10;
  pointer-events: none;
}
/* Style chung cho hi·ªÉn th·ªã buff */
.buff-display {
  position: fixed;
  top: 10vh;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.6);
  border-radius: 0.5rem;
  padding: 0.4rem 0.4rem;
  font-family: 'Segoe UI', sans-serif;
  font-size: 0.8rem;
  font-weight: normal;
  color: white;
  border: 2px solid;
  z-index: 10;
  pointer-events: auto;
}
/* Tooltip cho c√°c √¥ hi·ªÉn th·ªã buff (reuse data-tooltip) */
.buff-display[data-tooltip] { position: fixed; z-index: 10000;}
.buff-display[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  left: 50%;
  top: 115%;               /* hi·ªán ngay d∆∞·ªõi √¥ buff */
  transform: translateX(-50%);
  min-width: 14rem;
  white-space: pre-line;
  padding: .55rem .7rem;
  font-size: .8rem;
  background: rgba(0,0,0,.85);
  color: #e0f7fa;
  border: 1px solid var(--btn-border,#294e5a);
  border-radius: .5rem;
  pointer-events: none;
  opacity: 0;
  transition: opacity .2s;
  z-index: 10000;
}
.buff-display:hover::after { opacity: 1; }

.buff-display.inactive {
  opacity: 0.4; /* L√†m m·ªù ƒëi */
}
/* V·ªã tr√≠ ri√™ng cho t·ª´ng buff */
#luckyBuffDisplay { 
  left: 56.9%; /* V·ªã tr√≠ b√™n tr√°i c·ªßa Wave 68% */
  border-color: #22c55e; 
}
#powerBuffDisplay { 
  left: 64.1%; /* V·ªã tr√≠ b√™n tr√°i c·ªßa Lucky */
  border-color: #ef4444; 
}
#crazyBuffDisplay { 
  left: 71.2%; /* V·ªã tr√≠ b√™n tr√°i c·ªßa Power */
  border-color: #f59e0b; 
}
#expBuffDisplay { 
  left: 77.9%; /* V·ªã tr√≠ b√™n tr√°i c·ªßa Power */
  border-color: #ffeb3b; /* M√†u v√†ng cho buff EXP */
}
#magnetBuffDisplay { 
  top: 15vh; /* C√πng ƒë·ªô cao v·ªõi Wave */
  left: 56.7%; 
  border-color: #8b5cf6; /* M√†u t√≠m */
}

@keyframes pulsing-glow-magnet {
  0% { box-shadow: 0 0 4px #8b5cf6, inset 0 0 4px #8b5cf6; }
  50% { box-shadow: 0 0 14px #a78bfa, inset 0 0 14px #a78bfa; }
  100% { box-shadow: 0 0 4px #8b5cf6, inset 0 0 4px #8b5cf6; }
}

#magnetBuffDisplay.active-glow {
    animation: pulsing-glow-magnet 2s infinite;
}
#crazymadnesstimeBuffDisplay { 
  top: 15vh; /* C√πng ƒë·ªô cao v·ªõi Wave */
  left: 65.7%; 
  border-color: #0613c5; /* M√†u xanh d∆∞∆°ng */
}
@keyframes pulsing-glow-crazymadness {
  0%   { box-shadow: 0 0 4px #3b82f6, inset 0 0 4px #3b82f6; }
  50%  { box-shadow: 0 0 14px #60a5fa, inset 0 0 14px #60a5fa; }
  100% { box-shadow: 0 0 4px #3b82f6, inset 0 0 4px #3b82f6; }
}

/* √Åp d·ª•ng animation khi c√≥ class active-glow */
#crazymadnesstimeBuffDisplay.active-glow {
    animation: pulsing-glow-crazymadness 1.5s infinite;
}
/* --- B·∫ÆT ƒê·∫¶U: CSS cho hi·ªáu ·ª©ng vi·ªÅn s√°ng --- */

/* ƒê·ªãnh nghƒ©a animation cho buff Lucky (m√†u xanh l√°) */
@keyframes pulsing-glow-lucky {
  0% { box-shadow: 0 0 4px #22c55e, inset 0 0 4px #22c55e; }
  50% { box-shadow: 0 0 14px #34d399, inset 0 0 14px #34d399; }
  100% { box-shadow: 0 0 4px #22c55e, inset 0 0 4px #22c55e; }
}

/* ƒê·ªãnh nghƒ©a animation cho buff Power (m√†u ƒë·ªè) */
@keyframes pulsing-glow-power {
  0% { box-shadow: 0 0 4px #ef4444, inset 0 0 4px #ef4444; }
  50% { box-shadow: 0 0 14px #f87171, inset 0 0 14px #f87171; }
  100% { box-shadow: 0 0 4px #ef4444, inset 0 0 4px #ef4444; }
}
/* ƒê·ªãnh nghƒ©a animation cho buff Crazy (m√†u v√†ng cam) */
@keyframes pulsing-glow-crazy {
  0% { box-shadow: 0 0 4px #f59e0b, inset 0 0 4px #f59e0b; }
  50% { box-shadow: 0 0 14px #fbbf24, inset 0 0 14px #fbbf24; }
  100% { box-shadow: 0 0 4px #f59e0b, inset 0 0 4px #f59e0b; }
}
@keyframes pulsing-glow-exp {
  0% { box-shadow: 0 0 4px #ffeb3b, inset 0 0 4px #ffeb3b; }
  50% { box-shadow: 0 0 14px #fff176, inset 0 0 14px #fff176; }
  100% { box-shadow: 0 0 4px #ffeb3b, inset 0 0 4px #ffeb3b; }
}

/* √Åp d·ª•ng animation khi c√≥ class 'active-glow' */
#expBuffDisplay.active-glow {
    animation: pulsing-glow-exp 2s infinite;
}

/* √Åp d·ª•ng animation khi c√≥ class 'active-glow' */
#crazyBuffDisplay.active-glow {
    animation: pulsing-glow-crazy 2s infinite;
}

/* √Åp d·ª•ng animation khi c√≥ class 'active-glow' */
#luckyBuffDisplay.active-glow {
    /* T√™n animation, th·ªùi gian 2 gi√¢y, l·∫∑p l·∫°i v√¥ h·∫°n */
    animation: pulsing-glow-lucky 2s infinite;
}

#powerBuffDisplay.active-glow {
    animation: pulsing-glow-power 2s infinite;
}

/* --- K·∫æT TH√öC: CSS cho hi·ªáu ·ª©ng vi·ªÅn s√°ng --- */

/* --- CSS cho Pause Menu (G·ªçn h∆°n) --- */
#pauseMenu {
  top: 55%;
  max-width: 24rem; /* Gi·∫£m chi·ªÅu r·ªông t·ªëi ƒëa */
  padding: 1.5rem; /* Gi·∫£m padding t·ªïng th·ªÉ */
  border-radius: 0.75rem; /* Bo tr√≤n nh·∫π h∆°n */
}

#pauseMenu h2 {
  font-size: 2rem; /* Gi·∫£m k√≠ch th∆∞·ªõc ti√™u ƒë·ªÅ */
  margin-bottom: 1rem;
  margin-top: -1rem;
}

.settings-section {
  margin-bottom: 0.5rem; /* Gi·∫£m margin */
  padding-bottom: 0.5rem; /* Gi·∫£m padding */
  border-bottom: 1px solid #446688;
}

.settings-section h3 {
  font-size: 1rem; /* Gi·∫£m k√≠ch th∆∞·ªõc ti√™u ƒë·ªÅ ph·ª• */
  margin-bottom: 0.5rem;
}

.debug-grid label {
  font-size: 0.9rem; /* Gi·∫£m k√≠ch th∆∞·ªõc label */
}

.range-container input {
  width: 70%; /* ƒêi·ªÅu ch·ªânh chi·ªÅu r·ªông thanh tr∆∞·ª£t */
}

.range-container .range-value {
  font-size: 0.9rem; /* Gi·∫£m k√≠ch th∆∞·ªõc gi√° tr·ªã */
}

.pause-menu-buttons {
  display: grid;
  grid-template-columns: 1fr; /* <-- S·ª≠a th√†nh 1fr ƒë·ªÉ ch·ªâ c√≥ 1 c·ªôt d·ªçc */
  gap: 0.75rem;
  margin-top: 0.5rem;
  justify-items: center;
}

.pause-menu-buttons button {
  width: 14rem; /* Chi·ªÅu r·ªông c·ªë ƒë·ªãnh */
  max-width: 90%; /* ƒê·∫£m b·∫£o kh√¥ng qu√° to tr√™n m√†n h√¨nh h·∫πp */
  font-size: 0.9rem; /* Gi·∫£m k√≠ch th∆∞·ªõc ch·ªØ n√∫t */
  padding: 0.6rem 1rem; /* Gi·∫£m padding n√∫t */
}

#resumeBtn {
  grid-column: 1 / -1;
  padding: 0.75rem 1.2rem; /* TƒÉng padding n√∫t Ti·∫øp t·ª•c m·ªôt ch√∫t */
}
#pauseMenu.hidden {
    display: none;
}
#guideOverlay, #infoOverlay {
    z-index: 10001;
}

/* --- CSS cho C·ª≠a h√†ng (Shop) --- */
#shopOverlay {
  max-width: 40rem;
  min-height: auto;
}

#shopOverlay.hidden {
  display: none;
}

.shop-balance {
  font-size: 1.2rem;
  color: gold;
  margin-bottom: 1rem;
  text-shadow: 0 0 5px gold;
}

.shop-grid {
  display: grid;
  /* Gi·ªõi h·∫°n chi·ªÅu r·ªông t·ªëi thi·ªÉu v√† t·ªëi ƒëa c·ªßa m·ªói √¥ */
  grid-template-columns: repeat(auto-fill, minmax(6rem, 1fr)); 
  gap: 0.75rem;
  margin-bottom: 1.5rem;
  max-height: 50vh;
  overflow-y: auto;
  padding: 0.5rem;
}

/* ·∫®n thanh cu·ªôn cho shop grid */
.shop-grid::-webkit-scrollbar { display: none; }
.shop-grid { -ms-overflow-style: none; scrollbar-width: none; }

.shop-item {
  background: #1a2b33;
  border: 1px solid #294e5a;
  border-radius: 0.5rem;
  /* Gi·∫£m padding ƒë·ªÉ thu nh·ªè √¥ v·∫≠t ph·∫©m */
  padding: 0.5rem; 
  text-align: center;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  transition: all 0.2s ease;
}

.shop-item:hover {
    transform: translateY(-3px);
    border-color: var(--color-primary);
}

.shop-item .icon {
  font-size: 1.8rem;
}

.shop-item .name {
  font-weight: 500;
  margin: 0.4rem 0;
  font-size: 0.8rem;
  min-height: 2.2em;
}

.shop-item button {
  min-width: 6rem; /* ƒê·∫£m b·∫£o n√∫t kh√¥ng qu√° nh·ªè */
  padding: 0.5rem 1rem;
  /* Gi·∫£m padding ƒë·ªÉ thu nh·ªè n√∫t b·∫•m */
  margin: 0 auto; 
  font-size: 0.8rem;
  font-weight: bold;
  width: fit-content;
}
/* CSS ƒë·ªÉ hi·ªÉn th·ªã tooltip cho thanh EXP/HP */
#score-top[data-tooltip] {
  position: relative;
}
#score-top[data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  left: 50%;
  top: 110%; /* Hi·ªÉn th·ªã ngay b√™n d∆∞·ªõi thanh tr·∫°ng th√°i */
  transform: translateX(-50%);
  
  /* C√°c style kh√°c cho tooltip */
  min-width: 10rem;
  white-space: pre-line;
  padding: .55rem .7rem;
  font-size: .8rem;
  background: rgba(0,0,0,.85);
  color: #e0f7fa;
  border: 1px solid #00ffff;
  border-radius: .5rem;
  pointer-events: none;
  opacity: 0;
  transition: opacity .25s;
  z-index: 10000;
}
#score-top:hover::after {
  opacity: 1;
}
/* ‚ú® CSS cho m√†n h√¨nh loading */
#loadingOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--color-bg-dark);
  background-color: var(--color-bg-dark); 
  background-image: url('images/neon-night.png');
  background-size: cover;
  background-position: center;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10002; /* Lu√¥n n·ªïi l√™n tr√™n c√πng */
  transition: opacity 0.5s ease-out; /* Hi·ªáu ·ª©ng m·ªù d·∫ßn khi ·∫©n */
}

#loadingOverlay.hidden {
    opacity: 0;
    pointer-events: none; /* V√¥ hi·ªáu h√≥a click khi ƒëang ·∫©n */
}

.loading-content {
  text-align: center;
}

#loadingText {
  color: var(--color-primary);
  font-size: var(--font-lg);
  margin-top: 1.5rem;
  animation: pulse 1.5s infinite ease-in-out;
}

/* Hi·ªáu ·ª©ng nh·∫•p nh√°y cho ch·ªØ loading */
@keyframes pulse {
  0% { opacity: 0.6; }
  50% { opacity: 1; }
  100% { opacity: 0.6; }
}

/* CSS cho hi·ªÉn th·ªã s·ªë l∆∞·ª£ng ƒë·∫°n */
#ammoDisplay {
  position: fixed;
  bottom: 0.1rem;
  left: 18.8rem;
  background: rgba(0, 0, 0, 0.7);
  border: 2px solid var(--color-primary);
  border-radius: 0.25rem;
  padding: 0.1rem 0.1rem;
  color: var(--color-text);
  font-family: 'Segoe UI', sans-serif;
  font-size: 0.8rem;
  font-weight: bold;
  z-index: 9998;
  pointer-events: none;
  transition: opacity 0.3s ease;
  opacity: 0; /* M·∫∑c ƒë·ªãnh ·∫©n ƒëi */
}
/* CSS cho thanh loading bar */
.loading-bar-container {
    width: 100%; /* ƒê·ªô r·ªông c·ªßa khung ch·ª©a thanh loading */
    height: 20px;
    background-color: #333;
    border-radius: 10px;
    overflow: hidden; /* Quan tr·ªçng ƒë·ªÉ thanh b√™n trong kh√¥ng tr√†n ra ngo√†i */
    margin-top: 20px;
}

.loading-bar {
    height: 100%;
    width: 0%; /* B·∫Øt ƒë·∫ßu v·ªõi chi·ªÅu r·ªông 0% */
    background-color: #4CAF50; /* M√†u c·ªßa thanh loading */
    transition: width 0.3s ease; /* T·∫°o hi·ªáu ·ª©ng chuy·ªÉn ƒë·ªông m∆∞·ª£t m√† */
}
/* --- CSS cho b·∫£n tin ch·∫°y ch·ªØ --- */
#newsTickerContainer {
    position: fixed;
    top: 15vh;
    left: 22.5%;
    transform: translateX(-50%);
    width: 90%;
    max-width: 25rem;
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid var(--color-hover-border);
    border-radius: 6px;
    color: gold;
    font-size: 0.85rem;
    height: 1.5rem;
    line-height: 1.5rem;
    overflow: hidden;
    white-space: nowrap;
    z-index: 999;
    font-family: 'Segoe UI', sans-serif;
    text-shadow: 0 0 4px gold;
    transition: opacity 0.3s ease; /* Th√™m hi·ªáu ·ª©ng m·ªù */
}

/* M·ªöI: CSS ƒë·ªÉ ·∫©n thanh th√¥ng b√°o */
#newsTickerContainer.hidden {
    opacity: 0;
    pointer-events: none; /* V√¥ hi·ªáu h√≥a t∆∞∆°ng t√°c khi b·ªã ·∫©n */
}

#newsTickerText {
    position: absolute;
    display: inline-block;
    /* Animation s·∫Ω ƒë∆∞·ª£c ƒëi·ªÅu khi·ªÉn b·ªüi t·ªáp news_ticker.js */
}

/* ƒê·ªãnh nghƒ©a animation ch·∫°y ch·ªØ t·ª´ ph·∫£i qua tr√°i */
@keyframes scrollTicker {
  from { transform: translateX(var(--scroll-start, 100%)); }
  to   { transform: translateX(var(--scroll-end, -100%)); }
}

/* k·∫øt th√∫c style */
</style>
</head>
<body>
  <div id="loadingOverlay">
  <div class="loading-content">
    <h2 class="gameTitle">Zombie Survivor</h2>
    <p id="loadingText">ƒêang kh·ªüi t·∫°o...</p>
      <div class="loading-bar-container">
         <div class="loading-bar"></div>
      </div>
  </div>
</div>
<div class="ui-logo left-logo">Zombie<br>Survivor</div>
<div class="ui-logo right-logo">Bubble<br>Ver: 1.2</div>
<div id="ui">
  <button id="autoBtn" data-tooltip="‚öôÔ∏è Auto:
- T·ª± ƒë·ªông t·∫•n c√¥ng zombie g·∫ßn nh·∫•t
- C√≥ th·ªÉ t·∫Øt b·∫≠t k√≠ch ho·∫°t m·ªçi l√∫c
- N√¢ng c·∫•p ƒë·ªÉ tƒÉng t·ªëc ƒë·ªô t·∫•n c√¥ng
- TƒÉng c·∫•p ƒë·ªÉ tƒÉng s√°t th∆∞∆°ng
- Y√™u c·∫ßu level 1
- S√°t th∆∞∆°ng: 1
- Ti√™u hao: 0 ‚ö°">‚öôÔ∏è Auto</button>

  <button id="bladeBtn" data-tooltip="üî™ K·ªπ nƒÉng ƒêao:
- T·∫°o 2~20 thanh ƒëao xoay quanh player
- T·ªëi ƒëa t·∫°o ƒë∆∞·ª£c 20 ƒëao
- Bay v√†o zombie g·∫ßn nh·∫•t
- Y√™u c·∫ßu level 1
- S√°t th∆∞∆°ng: 1
- Hi·ªáu l·ª±c: 60s ‚è±
- Ti√™u hao: 5 ‚ö°">üî™ ƒêao</button>

  <button id="swordBtn" data-tooltip="‚öîÔ∏è K·ªπ nƒÉng Ki·∫øm:
- T·∫°o m∆∞a ki·∫øm r∆°i t·ª´ng ƒë·ª£t
- S·ªë l∆∞·ª£ng ki·∫øm tƒÉng theo level
- Bay v√†o zombie g·∫ßn nh·∫•t
- Y√™u c·∫ßu level 2
- S√°t th∆∞∆°ng: 1
- Hi·ªáu l·ª±c: 60s ‚è±
- Ti√™u hao: 6 ‚ö°">‚öîÔ∏è Ki·∫øm</button>

  <button id="fireBtn" data-tooltip="üî• K·ªπ nƒÉng L·ª≠a:
- T·∫°o 2 qu·∫£ c·∫ßu l·ª≠a quay quanh
- T·∫°o ƒë∆∞·ª£c t·ªëi ƒëa 10 qu·∫£ c·∫ßu l·ª≠a
- Ti√™u di·ªát zombie ch·∫°m v√†o
- Y√™u c·∫ßu level 3
- S√°t th∆∞∆°ng: 1
- Hi·ªáu l·ª±c: 60s ‚è±
- Ti√™u hao: 8 ‚ö°">üî• L·ª≠a</button>

  <button id="iceBtn" data-tooltip="‚ùÑÔ∏è K·ªπ nƒÉng BƒÉng:
- T·∫°o 2 qu·∫£ c·∫ßu bƒÉng l·ªõn xoay quanh
- T·∫°o ƒë∆∞·ª£c t·ªëi ƒëa 10 qu·∫£ c·∫ßu bƒÉng
- G√¢y s√°t th∆∞∆°ng di·ªán r·ªông
- Y√™u c·∫ßu level 3
- S√°t th∆∞∆°ng: 1
- Hi·ªáu l·ª±c: 60s ‚è±
- Ti√™u hao: 12 ‚ö°">‚ùÑÔ∏è BƒÉng</button>

  <button id="thunderBtn" data-tooltip="üîµ K·ªπ nƒÉng thunder:
- T·∫°o 2 qu·∫£ c·∫ßu l√¥i xoay quanh
- T·∫°o ƒë∆∞·ª£c t·ªëi ƒëa 6 qu·∫£ c·∫ßu
- G√¢y s√°t th∆∞∆°ng v√† l√†m cho√°ng
- Y√™u c·∫ßu level 5
- S√°t th∆∞∆°ng: 1
- Hi·ªáu l·ª±c: 60s ‚è±
- Ti√™u hao: 18 ‚ö°">üîµ L√¥i</button>

<button id="supportAuraBtn" data-tooltip="‚ú® K·ªπ nƒÉng h√†o quang:
- T·∫°o m·ªôt v√πng ph√©p thu·∫≠t d∆∞·ªõi ch√¢n.
- TƒÉng 20% t·ªëc ƒë·ªô ch·∫°y v√† t·ªëc ƒë·ªô b·∫Øn.
- Gi·∫£m 50% s√°t th∆∞∆°ng t·ª´ m·ªçi ngu·ªìn.
- H·ªìi 1 HP m·ªói gi√¢y.
- Y√™u c·∫ßu level 6
- Hi·ªáu l·ª±c: 60s ‚è±
- Ti√™u hao: 15 ‚ö°">‚ú® Heal</button>

<button id="fairyBtn" data-tooltip="ü¶ã K·ªπ nƒÉng Fairy:
- Tri·ªáu h·ªìi Fairy h·ªó tr·ª£.
- H·ªìi m√°u m·ªói 2s. Gi√∫p h·ªìi sinh player.
- TƒÉng s√°t th∆∞∆°ng player.
- Gi·∫£m s√°t th∆∞∆°ng zombie.
- Y√™u c·∫ßu level 7
- Hi·ªáu l·ª±c: 60s ‚è±
- Ti√™u hao: 25 ‚ö°">ü¶ã Fairy</button>

  <button id="PetBtn" data-tooltip="üê∞ K·ªπ nƒÉng Pet:
- Tri·ªáu h·ªìi 1 rabbit cute ƒëi theo player
- H·ªó tr·ª£: nh·∫∑t v·∫≠t ph·∫©m
- H·ªó tr·ª£: tƒÉng s√°t th∆∞∆°ng
- B·∫Øn carrot l√†m cho√°ng zombie.
- H·ªó tr·ª£: H·ªìi 1 HP m·ªói 3s
- Hi·ªáu l·ª±c: 60s ‚è±
- Ti√™u hao: 5 ‚ö°">üê∞ Pet</button>

  <div id="score">
    <div id="score-top" data-tooltip="Exp c·∫•p ti·∫øp theo: --">Exp: 0000 |‚ù§Ô∏è: 0010</div>
    <div id="score-bottom">Level: 0001 |‚ö°: 0000</div>
  </div>
<div id="newsTickerContainer" class="hidden">
  <span id="newsTickerText"></span>
</div>
</div>
<canvas id="game" width="960" height="720"></canvas>

<!-- üìã Menu b·∫Øt ƒë·∫ßu game -->
<div id="startMenu">
  <h2 class="gameTitle">Zombie Survivor</h2>
<input type="text" id="playerNameInput" placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n" class="custom-input" />
  <button id="continueBtn" style="display: none;" onclick="continueGame()">Ch∆°i ti·∫øp</button>
  <button onclick="startGame()">Ch∆°i m·ªõi</button>
  <button onclick="showGuide()">üìò H∆∞·ªõng d·∫´n</button>
  <button onclick="showInfo()">‚ÑπÔ∏è Th√¥ng tin</button>
</div>
<div id="guideOverlay" class="infoOverlay" style="display: none;">
<h3 style="margin-top: 0; color: #66aaff;">üìò H∆∞·ªõng d·∫´n ch∆°i</h3>
  <ul style="text-align: left;">
    <li>Ti√™u di·ªát zombie ƒë·ªÉ l√™n c·∫•p</li>
    <li>M·ªói wave, level s·∫Ω ƒë∆∞·ª£c n√¢ng c·∫•p k·ªπ nƒÉng</li>
    <li>Tr√πm cu·ªëi si√™u kh√≥ n√™n tr√°nh xa khi c√≤n y·∫øu</li>
    <li>Nh·∫∑t v·∫≠t ph·∫©m ƒë·ªÉ tƒÉng m√°u, mana, nƒÉng l∆∞·ª£ng</li>
    <li>Nh·∫•n ph√≠m Space ƒë·ªÉ s·ª≠ d·ª•ng k·ªπ nƒÉng ƒë·∫∑c bi·ªát</li>
    <li>B·∫•m X: m·ªü danh s√°ch k·ªπ nƒÉng</li>
    <li>B·∫•m Z: m·ªü b·∫£ng th·ªëng k√™</li>
    <li>B·∫•m M: m·ªü b·∫£ng b·∫£n ƒë·ªì</li>
    <li>B·∫•m O: m·ªü Shop. ESC: m·ªü Menu</li>
    <li>V·∫≠t ph·∫©m trong game: Energy, Mana, HP, Box</li>
  </ul>
  <div class="spacerguide"></div> <!-- üëà d√≤ng ƒë·ªám -->
  <button onclick="hideGuide()">ƒê√≥ng</button>
</div>
<div id="infoOverlay" class="infoOverlay" style="display: none;">
  <h3 style="margin-top: 0; color: #66aaff;">‚ÑπÔ∏è Th√¥ng tin</h3>
  <div class="infoContent">
    <p>Phi√™n b·∫£n: 1.2<br>
       T√°c gi·∫£: Dang<br>
       C·∫≠p nh·∫≠t: 2025-08-27</p>
    <p style="margin: 0; text-align: left;"><strong style="color: #00cc66;">üÜï New</strong></p>
    <!-- Ph·∫ßn c√≥ th·ªÉ cu·ªôn v√† canh tr√°i -->
    <div style="max-height: 128px;overflow-y: auto;scrollbar-width: none;
    -ms-overflow-style: none;text-align: left;">
      <ul style="padding-left: 20px;margin-top: 2px;list-style-type: disc;">
        <li>Th√™m minimap</li>
        <li>TƒÉng gi·ªõi h·∫°n b·∫£n ƒë·ªì</li>
        <li>TƒÉng gi·ªõi h·∫°n s·ªë l∆∞·ª£ng Zombie</li>
        <li>Th√™m Boss to h∆°n</li>
        <li>C·∫£i ti·∫øn m·ªôt s·ªë k·ªπ nƒÉng</li>
        <li>Th√™m h·ªá th·ªëng ng√†y ƒë√™m</li>
        <li>Th√™m k·ªπ nƒÉng h·ªó tr·ª£</li>
        <li>Th√™m Shop v√† Menu c√†i ƒë·∫∑t</li>
        <li>Th√™m v·∫≠t ph·∫©m m·ªõi: Coin, lucky, power, crazy</li>
        <!-- C√°c m·ª•c m·ªõi c√≥ th·ªÉ th√™m ·ªü ƒë√¢y -->
      </ul>
    </div>
    <!-- ·∫®n scrollbar tr√™n Chrome/Safari -->
    <style>
      .infoContent div::-webkit-scrollbar {
        display: none;
      }
    </style>
  </div>
  <div class="spacer"></div>
  <button onclick="hideInfo()">ƒê√≥ng</button>
</div>

<!-- üíÄ Game Over Panel -->
<div id="gameOverPanel" class="gameOverPanel">
    <h2 class="gameOverTitle">Game Over</h2>
    <button onclick="revivePlayer()" class="restartButton">H·ªìi sinh</button>
    <button onclick="resetGame()" class="restartButton">Ch∆°i l·∫°i</button>
    <button onclick="window.location.reload()" class="restartButton">Menu</button>
</div>

<!-- üåä Popup khi b·∫Øt ƒë·∫ßu m·ªói Wave -->
<div id="wavePopup">Wave 1</div>

<!-- ‚è≥ ƒê·ªìng h·ªì ƒë·∫øm th·ªùi gian wave -->
<div id="dayCounterDisplay">Ng√†y: 1</div>
<div id="bigBossRespawnDisplay">BigBoss: zZzz..</div>
<div id="waveTimerDisplay">01:30:00</div>
<div id="waveNumberDisplay">Wave: 1</div>
<div id="coinCounterDisplay">ü™ô: 00000</div>
<div id="luckyBuffDisplay" class="buff-display">üçÄ LuckyUp: <span>--</span>-</div>
<div id="powerBuffDisplay" class="buff-display">üçÅ PowerUp: <span>--</span>-</div>
<div id="crazyBuffDisplay" class="buff-display">üçÇ CarzyUp: <span>--</span>-</div>
<div id="expBuffDisplay" class="buff-display">üåø ExpUp: <span>--</span>-</div>
<div id="magnetBuffDisplay" class="buff-display">üß≤ Magnet: <span>---</span></div>
<div id="crazymadnesstimeBuffDisplay" class="buff-display">üí¢ CrazyMadnessTime: <span>---</span></div>

<!-- Mini map -->
<canvas id="miniMap" width="150" height="150"></canvas>
<script>
// --- B·∫ÆT ƒê·∫¶U: H·ªÜ TH·ªêNG √ÇM THANH & NH·∫†C N·ªÄN HO√ÄN CH·ªàNH ---

// Danh s√°ch ID v√† file nh·∫°c
const normalMusicTracks = ['music-background', 'music-background-2', 'music-background-3'];
const bossMusicId = 'music-boss';
const luckyMusicId = 'sfx-lucky-loop';
const powerMusicId = 'sfx-power-loop';
const crazyMusicId = 'sfx-crazy-loop';
const expMusicId = 'sfx-exp-loop';
const crazyMadnessMusicId = 'sfx-power-loop'; // D√πng chung v·ªõi Power
// Bi·∫øn tr·∫°ng th√°i
let currentMusicState = '';
let currentNormalTrackId = '';

// C·∫≠p nh·∫≠t √¢m l∆∞·ª£ng cho t·∫•t c·∫£ c√°c track nh·∫°c
function updateAllMusicVolume() {
    // T√≠nh to√°n √¢m l∆∞·ª£ng cu·ªëi c√πng d·ª±a tr√™n thanh tr∆∞·ª£t T·ªïng v√† Nh·∫°c n·ªÅn
    const finalMusicVol = musicVolume * masterVolume;
    // √Åp d·ª•ng √¢m l∆∞·ª£ng cho t·∫•t c·∫£ c√°c th·∫ª audio d√πng cho nh·∫°c
    document.querySelectorAll('audio[id^="music-"], audio[id^="sfx-"][loop]').forEach(audio => {
        if (audio) audio.volume = finalMusicVol;
    });
}

// H√†m ph√°t hi·ªáu ·ª©ng √¢m thanh (SFX)
function playSound(id, baseVolume = 1.0) {
    const soundData = sfxPool[id];
    
    // N·∫øu kh√¥ng t√¨m th·∫•y √¢m thanh trong kho, kh√¥ng l√†m g√¨ c·∫£
    if (!soundData || soundData.pool.length === 0) {
        return;
    }

    // L·∫•y ƒë·ªëi t∆∞·ª£ng Audio ti·∫øp theo trong kho theo ki·ªÉu xoay v√≤ng (Round-robin)
    let audio = soundData.pool[soundData.currentIndex];

    // C·∫≠p nh·∫≠t con tr·ªè cho l·∫ßn g·ªçi ti·∫øp theo
    soundData.currentIndex = (soundData.currentIndex + 1) % soundData.pool.length;
    
    // ƒê·∫∑t l·∫°i th·ªùi gian v√† √¢m l∆∞·ª£ng, sau ƒë√≥ ph√°t
    audio.currentTime = 0;
    audio.volume = baseVolume * sfxVolume * masterVolume;
    audio.play().catch(e => {
        // L·ªói n√†y th∆∞·ªùng x·∫£y ra khi ng∆∞·ªùi d√πng ch∆∞a t∆∞∆°ng t√°c v·ªõi trang, c√≥ th·ªÉ b·ªè qua
    });
}

// H√†m d·ª´ng t·∫•t c·∫£ nh·∫°c n·ªÅn
function stopAllMusic() {
    document.querySelectorAll('audio[id^="music-"], audio[id^="sfx-"][loop]').forEach(audio => {
        if(audio) { audio.pause(); audio.currentTime = 0; }
    });
}

// H√†m ph√°t nh·∫°c n·ªÅn ng·∫´u nhi√™n
function playRandomNormalMusic() {
    const list = normalMusicTracks;
    const n = list.length;

    // 0 b√†i: tho√°t ngay
    if (n === 0) return;

    // 1 b√†i: ch·ªâ ph√°t n·∫øu kh√°c b√†i hi·ªán t·∫°i
    if (n === 1) {
        const id = list[0];
        if (id !== currentNormalTrackId) {
            const el = document.getElementById(id);
            if (el) {
                updateAllMusicVolume();
                // Ch·ªâ d·ª´ng nh·∫°c khi ch·∫Øc ch·∫Øn c√≥ b√†i m·ªõi ƒë·ªÉ ph√°t
                stopAllMusic();
                // ‚õî TH√äM DELAY ·ªû ƒê√ÇY
                setTimeout(() => {
                    el.play().catch(e => console.error("L·ªói ph√°t nh·∫°c:", e));
                }, 50); // Kho·∫£ng ch·ªù nh·ªè (v√≠ d·ª•: 50ms)
                currentNormalTrackId = id;
                currentMusicState = 'normal';
            }
        }
        return;
    }

    // n >= 2
    const cur = list.indexOf(currentNormalTrackId);

    let idx;
    if (cur === -1) {
        // l·∫ßn ƒë·∫ßu/ch∆∞a kh·ªõp danh s√°ch: b·ªëc t·ª± do 0..n-1 (ƒë·ªÅu x√°c su·∫•t)
        idx = (Math.random() * n) | 0;
    } else {
        // b·ªëc ƒë·ªÅu trong (n-1) b√†i kh√°c: 0..n-2 r·ªìi nh·∫£y qua cur
        const r = (Math.random() * (n - 1)) | 0; // 0..n-2
        idx = (r >= cur) ? r + 1 : r;
    }

    const id = list[idx];
    if (id === currentNormalTrackId) return; // ph√≤ng h·ªù

    const el = document.getElementById(id);
    if (!el) {
        console.warn("Kh√¥ng t√¨m th·∫•y ph·∫ßn t·ª≠ audio:", id);
        return;
    }

    updateAllMusicVolume();
    stopAllMusic();
    // ‚õî TH√äM DELAY ·ªû ƒê√ÇY
    setTimeout(() => {
        el.play().catch(e => console.error("L·ªói ph√°t nh·∫°c:", e));
    }, 50); // Kho·∫£ng ch·ªù nh·ªè (v√≠ d·ª•: 50ms)
    currentNormalTrackId = id;
    currentMusicState = 'normal';
}

// H√†m c·∫≠p nh·∫≠t nh·∫°c n·ªÅn ch√≠nh
function updateMusic() {
    const now = Date.now();
    const bigBoss = zombies.find(z => z.active && z.isBigBoss);
    
    // T√¨m buff c√≥ th·ªùi gian k·∫øt th√∫c xa nh·∫•t (ƒë∆∞·ª£c nh·∫∑t sau c√πng)
    let latestBuffEndTime = 0;
    let highestPriorityState = null;

    // L·∫•y th·ªùi gian k·∫øt th√∫c c·ªßa c√°c buff
    if (now < expBuffEndTime && expBuffEndTime > latestBuffEndTime) {
        latestBuffEndTime = expBuffEndTime;
        highestPriorityState = 'exp';
    }
    if (now < crazyBuffEndTime && crazyBuffEndTime > latestBuffEndTime) {
        latestBuffEndTime = crazyBuffEndTime;
        highestPriorityState = 'crazy';
    }
    if (now < powerBuffEndTime && powerBuffEndTime > latestBuffEndTime) {
        latestBuffEndTime = powerBuffEndTime;
        highestPriorityState = 'power';
    }
    if (now < luckyBuffEndTime && luckyBuffEndTime > latestBuffEndTime) {
        latestBuffEndTime = luckyBuffEndTime;
        highestPriorityState = 'lucky';
    }

    //  B∆Ø·ªöC 1: TH√äM CRAZYMADNESSTIME V√ÄO DANH S√ÅCH KI·ªÇM TRA
    if (now < crazyMadnessTimeEndTime && crazyMadnessTimeEndTime > latestBuffEndTime) {
        latestBuffEndTime = crazyMadnessTimeEndTime;
        highestPriorityState = 'crazymadness';
    }

    // X√°c ƒë·ªãnh tr·∫°ng th√°i nh·∫°c cu·ªëi c√πng
    let desiredState = 'normal';
    // N·∫øu c√≥ buff n√†o ƒëang ho·∫°t ƒë·ªông, ∆∞u ti√™n buff ƒë√≥
    if (highestPriorityState) {
        desiredState = highestPriorityState;
    } else if (bigBoss) {
        desiredState = 'boss';
    }

    // Ch·ªâ ƒë·ªïi nh·∫°c khi tr·∫°ng th√°i thay ƒë·ªïi
if (desiredState !== currentMusicState) {
        stopAllMusic();
        let trackToPlayId = null;

        // B∆Ø·ªöC 2: C·∫¨P NH·∫¨T ID PH√ÅT NH·∫†C D·ª∞A TR√äN TR·∫†NG TH√ÅI
        if (desiredState === 'crazymadness') trackToPlayId = crazyMadnessMusicId; 
        else if (desiredState === 'exp') trackToPlayId = expMusicId;
        else if (desiredState === 'crazy') trackToPlayId = crazyMusicId;
        else if (desiredState === 'lucky') trackToPlayId = luckyMusicId;
        else if (desiredState === 'power') trackToPlayId = powerMusicId;
        else if (desiredState === 'boss') trackToPlayId = bossMusicId;
        else { 
            playRandomNormalMusic(); 
            return; 
        }
        
        const trackElement = document.getElementById(trackToPlayId);
        if (trackElement) {
            updateAllMusicVolume();
            trackElement.play().catch(e => console.error(`L·ªói ph√°t nh·∫°c cho tr·∫°ng th√°i '${desiredState}':`, e));
        }
        currentMusicState = desiredState;
    }
}
// --- K·∫æT TH√öC: H·ªÜ TH·ªêNG √ÇM THANH & NH·∫†C N·ªÄN ---
// üß± 1. Bi·∫øn to√†n c·ª•c ‚Äì C·∫•u h√¨nh & Kh·ªüi t·∫°o
const safeZones = [
    { id: 1, name: "Safe Zone 1", x: 1500, y: 1000, radius: 150, active: false, tempActiveUntil: 0 },
    { id: 2, name: "Safe Zone 2", x: 400, y: 400, radius: 120, active: false, tempActiveUntil: 0 },
    { id: 3, name: "Safe Zone 3", x: 2600, y: 400, radius: 120, active: false, tempActiveUntil: 0 },
    { id: 4, name: "Safe Zone 4", x: 400, y: 1600, radius: 120, active: false, tempActiveUntil: 0 },
    { id: 5, name: "Safe Zone 5", x: 2600, y: 1600, radius: 120, active: false, tempActiveUntil: 0 }
];
// M·∫∑c ƒë·ªãnh b·∫≠t Zone ID=2 khi v√†o game
for (const z of safeZones) { 
  const on = z.id === 2;
  z.active = on;          // c√≥ hi·ªáu l·ª±c gameplay
  z.visible = on;         // c√≥ v·∫Ω v√≤ng tr√≤n hay kh√¥ng
  z.expireAt = on ? Infinity : 0;  // n·∫øu b·∫°n c√≥ d√πng expireAt
}
let safeZoneSchedule = {};
let SHOP_NPCS = [];
let currentActiveSafeZoneId = null;
let lastSafeZoneChangeHour = -1;

function initializeSafeZoneSystem() {
    // Create an NPC for each safe zone
    SHOP_NPCS = safeZones.map(zone => ({
        parentZoneId: zone.id,
        x: zone.x + Math.min(60, Math.max(36, Math.round(zone.radius * 0.40))),
        y: zone.y - Math.min(80, Math.max(24, Math.round(zone.radius * 0.45))),
        r: 22,
        icon: 'üõí',
        name: 'Shop',
    }));
}

function updateSafeZoneStatus() {
    const now = Date.now();
    const hour = Math.floor(dayTime * 24) % 24;

    // Logic thay ƒë·ªïi zone m·ªói 2 gi·ªù ch·∫µn
    const currentHourBlock = Math.floor(hour / 2);
    const lastHourBlock = Math.floor(lastSafeZoneChangeHour / 2);

    if (currentHourBlock !== lastHourBlock && lastSafeZoneChangeHour !== -1) {
        lastSafeZoneChangeHour = hour;

        // T·∫°o danh s√°ch c√°c zone c√≥ th·ªÉ ch·ªçn (lo·∫°i tr·ª´ zone hi·ªán t·∫°i)
        const possibleNextZones = safeZones.filter(z => z.id !== currentActiveSafeZoneId);
        
        // Ch·ªçn ng·∫´u nhi√™n m·ªôt zone m·ªõi t·ª´ danh s√°ch
        const newZone = possibleNextZones[Math.floor(Math.random() * possibleNextZones.length)];
        
        if (newZone) {
            currentActiveSafeZoneId = newZone.id;
            
            // G·ª≠i th√¥ng b√°o l√™n b·∫£n tin
            if (window.NewsTicker && typeof window.NewsTicker.pushMessage === 'function') {
                window.NewsTicker.pushMessage(`‚ö†Ô∏è V√πng an to√†n ƒë√£ di chuy·ªÉn ƒë·∫øn ${newZone.name}!`, true);
            }
        }
    }
    
    // C·∫≠p nh·∫≠t tr·∫°ng th√°i active cho t·∫•t c·∫£ c√°c zone
    safeZones.forEach(zone => {
        // ∆Øu ti√™n k√≠ch ho·∫°t t·∫°m th·ªùi khi h·ªìi sinh
        if (zone.tempActiveUntil > 0) {
            if (now < zone.tempActiveUntil) {
                zone.active = true;
                return;
            } else {
                zone.tempActiveUntil = 0;
            }
        }
        
        // K√≠ch ho·∫°t theo zone ng·∫´u nhi√™n ƒë√£ ƒë∆∞·ª£c ch·ªçn
        zone.active = (zone.id === currentActiveSafeZoneId);
    });
}
let __npcHover = null; // Bi·∫øn l∆∞u NPC ƒëang ƒë∆∞·ª£c tr·ªè chu·ªôt v√†o

function drawShopNPC(ctx) {
    safeZones.forEach(zone => {
        if (zone.active) {
            const n = SHOP_NPCS.find(npc => npc.parentZoneId === zone.id);
            if (!n) return;

            const isHovered = __npcHover && __npcHover.parentZoneId === zone.id;

            ctx.save();
            ctx.beginPath();
            ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
            ctx.fillStyle = '#1f2633';
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = isHovered ? '#ffd54f' : 'rgba(255,255,255,0.5)';
            ctx.stroke();
            ctx.font = '18px Segoe UI Emoji';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';
            ctx.fillText(n.icon, n.x, n.y);
            ctx.font = 'bold 12px Segoe UI';
            ctx.textBaseline = 'top';
            ctx.fillStyle = '#ffd54f';
            ctx.fillText('Shop', n.x, n.y + n.r + 4);
            ctx.restore();
        }
    });
}

function npcHitTestWorld(x, y) {
    for (const zone of safeZones) {
        if (zone.active) {
            const n = SHOP_NPCS.find(npc => npc.parentZoneId === zone.id);
            if (n) {
                const dx = x - n.x;
                const dy = y - n.y;
                const R = n.r + 10;
                if ((dx * dx + dy * dy) <= R * R) {
                    return n; // Tr·∫£ v·ªÅ ƒë·ªëi t∆∞·ª£ng NPC n·∫øu tr√∫ng
                }
            }
        }
    }
    return null; // Tr·∫£ v·ªÅ null n·∫øu kh√¥ng tr√∫ng
}
// --- END: Safe Zone System ---

// ƒê·∫∑t ngay sau kh·ªëi m√£ tr√™n
initializeSafeZoneSystem();

// chuy·ªÉn click -> to·∫° ƒë·ªô th·∫ø gi·ªõi (kh√¥ng c·∫•p ph√°t r√°c)
function getMouseWorld(ev){
  const rect = canvas.getBoundingClientRect();
  const sx = canvas.width / rect.width;
  const sy = canvas.height / rect.height;
  const cx = (ev.clientX - rect.left) * sx;
  const cy = (ev.clientY - rect.top) * sy;
  return { x: cx + camera.x, y: cy + camera.y };
}

// m·ªü shop (kh√¥ng "toggle" khi ƒë√£ m·ªü)
function openShopFromNPC(){
  const el = document.getElementById('shopOverlay');
  try { if (typeof populateShop === 'function') populateShop(); } catch {}
  if (el && (getComputedStyle(el).display === 'none' || el.classList.contains('hidden'))) {
    if (typeof toggleShop === 'function') toggleShop();
  } else if (el) {
    el.classList.remove('hidden');
  }
}

let lastStamina = 0;
let lastStaminaRegenTime = 0;
const STAMINA_REGEN_INTERVAL = 5000; // 5 gi√¢y
const STAMINA_REGEN_VALUE = 1;
let lastHpRegenTime = 0;       // L∆∞u m·ªëc th·ªùi gian h·ªìi m√°u l·∫ßn cu·ªëi.
const HP_REGEN = 5000;          // Th·ªùi gian ch·ªù gi·ªØa 2 l·∫ßn h·ªìi m√°u (10000ms = 10 gi√¢y).
const HP_REGEN_VALUE = 1;        // L∆∞·ª£ng m√°u ƒë∆∞·ª£c h·ªìi m·ªói l·∫ßn.
// ==== PATCH: helper t√≠nh gi√° tr·ªã h·ªìi d·ª±a v√†o trang b·ªã ====
function getEffectiveSpRegen() {
  // +SP m·ªói tick: base + trang b·ªã
  return STAMINA_REGEN_VALUE + (window.player?.equipSpRegen || 0);
}
function getEffectiveHpRegen() {
  // +HP m·ªói tick: base + trang b·ªã
  return HP_REGEN_VALUE + (window.player?.equipHpRegen || 0);
}
function getEffectiveStaminaMax() {
  // Tr·∫ßn SP: base + bonus t·ª´ trang b·ªã (n·∫øu b·∫°n ƒëang d√πng staminaMax)
  const base = (window.player?.staminaMax ?? 10);
  return base + (window.player?.equipStaminaMaxBonus || 0);
}

let camera = { x: 0, y: 0 }; // üì∑ V·ªã tr√≠ camera
let backgroundStars = [];
let backgroundBirds = [];
let backgroundTrees = [];
let backgroundClouds = [];
let backgroundPlanes = [];
let backgroundMushrooms = [];
let backgroundRocks = [];
let backgroundBalloons = [];
let backgroundSeeds = [];
let dayTime = 0.25; // 0.25 = 6h Th·ªùi gian ban ƒë·∫ßu
let dayDirection = 1; 
const dayDuration = 600; // 600 gi√¢y = 10 ph√∫t cho 1 chu k·ª≥ ng√†y ƒë√™m
let lastUpdateTime = Date.now();
let prevIsNight = isNight();
let backgroundBigStars = [];
let globalDeltaTime = 0;
let currentDay = 1; // ‚ú® bi·∫øn ƒë·∫øm s·ªë ng√†y tr√¥i qua
// ü¶ã Tr·∫°ng th√°i k·ªπ nƒÉng Fairy
let fairyActive = false;
let fairyEndTime = 0;
let fairies = []; // M·∫£ng ch·ª©a c√°c Fairy
let lastFairyHealTime = 0;
let fairyDamageBonus = 0; // L∆∞u l·∫°i m·ª©c s√°t th∆∞∆°ng c·ªông th√™m
let fairyDeathDefyAvailable = false; // C·ªù cho c∆° ch·∫ø h·ªìi sinh
let lastShieldBlockSoundTime = 0;
let luckyBuffEndTime = 0;
let powerBuffEndTime = 0;
let isPowerBuffActive = false; // Bi·∫øn c·ªù ƒë·ªÉ tr√°nh nh√¢n/chia s√°t th∆∞∆°ng nhi·ªÅu l·∫ßn
let crazyBuffEndTime = 0;
let isCrazyBuffActive = false;
let expBuffEndTime = 0;
let magnetBuffEndTime = 0;
let crazyMadnessTimeEndTime = 0;
let isCrazyMadnessTimeActive = false;
let crazyMadnessTimeBuffStats = {};
let supplyDrops = []; // M·∫£ng ch·ª©a c√°c ki·ªán h√†ng ü™Ç
let morningDropTriggered = false; // C·ªù ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ r∆°i 1 l·∫ßn m·ªói 9h s√°ng
let morningDropTriggered12h = false;    // Cho 12h
let morningDropTriggered15h = false;    // Cho 15h
// D·ªØ li·ªáu qu·∫£n l√Ω hi·ªáu ·ª©ng ƒë√≥m s√°ng cho c√°c buff
const buffEffects = {
    power:  { color: "#ef4444", active: false, angle: 0 }, // ƒê·ªè (Power)
    crazy:  { color: "#f59e0b", active: false, angle: 0 }, // V√†ng cam (Crazy)
    lucky:  { color: "#22c55e", active: false, angle: 0 }, // Xanh l√° (Lucky)
    exp:    { color: "#ffeb3b", active: false, angle: 0 }, // V√†ng (Exp)
    magnet: { color: "#8b5cf6", active: false, angle: 0 }, // T√≠m (Magnet)
    crazymadness: { color: "#3b82f6", active: false, angle: 0 }, // Xanh d∆∞∆°ng (CrazyMadnessTime)
    critRate: { color: "orange", active: false, angle: 0 }, // Cam (Crit Rate)
    critDmg:  { color: "#c084fc", active: false, angle: 0 }, // T√≠m nh·∫°t (Crit Dmg)
// Th√™m c√°c buff kh√°c n·∫øu c·∫ßn
};
// --- T·ªâ l·ªá r∆°i v·∫≠t ph·∫©m trong game ---
const itemDropTable = [
  // --- V·∫≠t ph·∫©m Si√™u hi·∫øm ---
  { type: 'crazymadnesstime', chance: 0.002 }, // 0.2%

  // --- V·∫≠t ph·∫©m Hi·∫øm ---
  { type: 'box',              chance: 0.006 }, // 0.6%
  { type: 'magnet',           chance: 0.003 }, // 0.3%
  { type: 'secret',           chance: 0.196 }, // 19.6%
  { type: 'potion',           chance: 0.015 }, // 1.5%

  // --- Buff (ƒë√£ gi·∫£m) ---
  { type: 'lucky',            chance: 0.003 }, // 0.3%
  { type: 'power',            chance: 0.003 }, // 0.3%
  { type: 'crazy',            chance: 0.003 }, // 0.3%
  { type: 'exp',              chance: 0.003 }, // 0.3%
  { type: 'critRateBuff',     chance: 0.003 }, // 0.3%
  { type: 'critDmgBuff',      chance: 0.003 }, // 0.3%
  // --- Th∆∞·ªùng ---
  { type: 'expBonus',         chance: 0.010 }, // 1.0%
  { type: 'hp',               chance: 0.050 }, // 5.0%

  // ‚≠ê ƒêi·ªÅu ch·ªânh t·∫°i ƒë√¢y
  { type: 'coin',             chance: 0.200 }, // 20%
  { type: 'mana',             chance: 0.250 }, // 25%
  { type: 'energy',           chance: 0.250 } // 25%

];
// T·∫°o m·ªôt b·∫£ng r∆°i ƒë·ªì t·∫°m th·ªùi cho vi·ªác test
/*const testDropTable = [
  { type: 'secret', chance: 1.0 } // 100% r∆°i v·∫≠t ph·∫©m n√†y
];*/

// Bi·∫øn ƒë·ªÉ l∆∞u tr·ªØ l∆∞·ª£ng ch·ªâ s·ªë c·ªông th√™m t·ª´ buff, gi√∫p g·ª° b·ªè ch√≠nh x√°c
let powerBuffDamageBonus = 0;
let crazyBuffStats = { speed: 0, bulletSpeed: 0, damage: 0 };

let debugKeyTimer = null; // Bi·∫øn ƒë·ªÉ l∆∞u timer c·ªßa ph√≠m Debug
// Menu ESC
let masterVolume = 1.0;
let musicVolume = 0.5;
let sfxVolume = 0.8;
// --- C·∫•u h√¨nh v·∫≠t ph·∫©m trong Shop ---
const shopItems = [
    { id: 'buy_10_mana',   name: '10 Mana',   icon: 'üí†', cost: 1, type: 'resource', value: 10 },
    { id: 'buy_10_energy', name: '10 Energy', icon: '‚ö°', cost: 1, type: 'resource', value: 10 },
    { id: 'buy_5_hp',      name: '5 HP',      icon: '‚ù§Ô∏è', cost: 1, type: 'resource', value: 5 },
    { id: 'buy_12_hp',      name: '12 HP',      icon: '‚ù§Ô∏è', cost: 2, type: 'resource', value: 12 },
    { id: 'buy_damage',    name: 'Dmg +0.2', icon: 'üí•', cost: 3, type: 'permanent_upgrade', value: 0.2 },
    // --- Mua ƒë·∫°n ---
    { id:'crit_rate_30s', name:'Crit Rate +15%', icon:'üí•', type:'crit', sub:'rate', value:0.15, durationMs:60000, cost:4 },
    { id:'crit_dmg_30s',  name:'Crit Dmg +25%',  icon:'üí•', type:'crit', sub:'dmg',  value:0.25, durationMs:60000, cost:4 },
    { id: 'buy_ice_arrow_speed', name: '+0.5 speed', icon: 'üèπ', cost: 3, type: 'permanent_upgrade' },
    { id: 'buy_ice_rate',   name: '+0.5 att.speed', icon: 'üèπ', cost: 10, type: 'ice', value: 0.5 },
    { id: 'buy_ice_damage', name: '+1 dmg',           icon: 'üèπ', cost: 5, type: 'ice', value: 1   },
    { id: 'buy_ammo_spiral', name: '+50 Xo·∫Øn ·ªëc', icon: 'üîÑ', cost: 10, type: 'ammo', value: 50, targetAmmoIndex: 0 },
    { id: 'buy_ammo_zigzag', name: '+75 Zigzag', icon: '‚ÜîÔ∏è', cost: 10, type: 'ammo', value: 75, targetAmmoIndex: 1 },
    { id: 'buy_ammo_spiral_fwd', name: '+50 Xo·∫Øn', icon: 'üéØ', cost: 15, type: 'ammo', value: 50, targetAmmoIndex: 2 },
    { id: 'buy_ammo_piercing', name: '+25 Xuy√™n', icon: 'üéØ', cost: 20, type: 'ammo', value: 25, targetAmmoIndex: 3 },
    { id: 'buy_ammo_laser', name: '+10 Laze', icon: 'üí•', cost: 25, type: 'ammo', value: 10, targetAmmoIndex: 4 },
    // th√™m c√°c v·∫≠t ph·∫©m kh√°c v√†o ƒë√¢y
    { id: 'buy_lucky',   name: 'Lucky',   icon: 'üçÄ', cost: 15, type: 'buff' },
    { id: 'buy_power',   name: 'Power',   icon: 'üçÅ', cost: 15, type: 'buff' },
    { id: 'buy_crazy',   name: 'Crazy',   icon: 'üçÇ', cost: 15, type: 'buff' },
    { id: 'buy_exp',     name: 'EXP',     icon: 'üåø', cost: 15, type: 'buff' },
    { id: 'buy_magnet',  name: 'Magnet',  icon: 'üß≤', cost: 10, type: 'buff' },
    { id: 'buy_madness', name: 'Madness', icon: 'üí¢', cost: 25, type: 'buff' },
    // --- N√¢ng c·∫•p ƒêao ---
{ id: 'buy_blade_dmg_1', name: 'Dmg +0.2', icon: 'üî™', cost: 5, type: 'skill_damage_upgrade', value: 0.2, skillTarget: 'bladeDamage' },
{ id: 'buy_blade_dmg_2', name: 'Dmg +0.5', icon: 'üî™', cost: 10, type: 'skill_damage_upgrade', value: 0.5, skillTarget: 'bladeDamage' },
{ id: 'buy_blade_dmg_3', name: 'Dmg +1',   icon: 'üî™', cost: 18, type: 'skill_damage_upgrade', value: 1,   skillTarget: 'bladeDamage' },

// --- N√¢ng c·∫•p Ki·∫øm ---
{ id: 'buy_sword_dmg_1', name: 'Dmg +0.2', icon: '‚öîÔ∏è', cost: 5, type: 'skill_damage_upgrade', value: 0.2, skillTarget: 'swordDamage' },
{ id: 'buy_sword_dmg_2', name: 'Dmg +0.5', icon: '‚öîÔ∏è', cost: 10, type: 'skill_damage_upgrade', value: 0.5, skillTarget: 'swordDamage' },
{ id: 'buy_sword_dmg_3', name: 'Dmg +1',   icon: '‚öîÔ∏è', cost: 18, type: 'skill_damage_upgrade', value: 1,   skillTarget: 'swordDamage' },

// --- N√¢ng c·∫•p L·ª≠a ---
{ id: 'buy_fire_dmg_1', name: 'Dmg +0.2', icon: 'üî•', cost: 5, type: 'skill_damage_upgrade', value: 0.2, skillTarget: 'fireDamage' },
{ id: 'buy_fire_dmg_2', name: 'Dmg +0.5', icon: 'üî•', cost: 10, type: 'skill_damage_upgrade', value: 0.5, skillTarget: 'fireDamage' },
{ id: 'buy_fire_dmg_3', name: 'Dmg +1',   icon: 'üî•', cost: 18, type: 'skill_damage_upgrade', value: 1,   skillTarget: 'fireDamage' },

// --- N√¢ng c·∫•p BƒÉng ---
{ id: 'buy_ice_dmg_1', name: 'Dmg +0.2', icon: '‚ùÑÔ∏è', cost: 5, type: 'skill_damage_upgrade', value: 0.2, skillTarget: 'iceDamage' },
{ id: 'buy_ice_dmg_2', name: 'Dmg +0.5', icon: '‚ùÑÔ∏è', cost: 10, type: 'skill_damage_upgrade', value: 0.5, skillTarget: 'iceDamage' },
{ id: 'buy_ice_dmg_3', name: 'Dmg +1',   icon: '‚ùÑÔ∏è', cost: 18, type: 'skill_damage_upgrade', value: 1,   skillTarget: 'iceDamage' },

// --- N√¢ng c·∫•p L√¥i ---
{ id: 'buy_thunder_dmg_1', name: 'Dmg +0.2', icon: 'üîµ', cost: 5, type: 'skill_damage_upgrade', value: 0.2, skillTarget: 'thunderDamage' },
{ id: 'buy_thunder_dmg_2', name: 'Dmg +0.5', icon: 'üîµ', cost: 10, type: 'skill_damage_upgrade', value: 0.5, skillTarget: 'thunderDamage' },
{ id: 'buy_thunder_dmg_3', name: 'Dmg +1',   icon: 'üîµ', cost: 18, type: 'skill_damage_upgrade', value: 1,   skillTarget: 'thunderDamage' },
// --- N√¢ng c·∫•p V·ªá tinh laze ---
{ id: 'buy_satellite_dmg_1', name: 'Dmg +0.2', icon: 'üõ∞Ô∏è', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'V·ªá tinh laze' },
{ id: 'buy_satellite_dmg_2', name: 'Dmg +0.5', icon: 'üõ∞Ô∏è', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'V·ªá tinh laze' },
{ id: 'buy_satellite_dmg_3', name: 'Dmg +1',   icon: 'üõ∞Ô∏è', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'V·ªá tinh laze' },

// --- N√¢ng c·∫•p T√™n l·ª≠a F18 ---
{ id: 'buy_missile_dmg_1', name: 'Dmg +0.2', icon: 'üöÄ', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'T√™n l·ª≠a F18' },
{ id: 'buy_missile_dmg_2', name: 'Dmg +0.5', icon: 'üöÄ', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'T√™n l·ª≠a F18' },
{ id: 'buy_missile_dmg_3', name: 'Dmg +1',   icon: 'üöÄ', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'T√™n l·ª≠a F18' },

// --- N√¢ng c·∫•p UFO t·∫•n c√¥ng ---
{ id: 'buy_ufo_dmg_1', name: 'Dmg +0.2', icon: 'üõ∏', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'UFO t·∫•n c√¥ng' },
{ id: 'buy_ufo_dmg_2', name: 'Dmg +0.5', icon: 'üõ∏', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'UFO t·∫•n c√¥ng' },
{ id: 'buy_ufo_dmg_3', name: 'Dmg +1',   icon: 'üõ∏', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'UFO t·∫•n c√¥ng' },

// --- N√¢ng c·∫•p B√£o s√©t ---
{ id: 'buy_lightning_dmg_1', name: 'Dmg +0.2', icon: 'üå©Ô∏è', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'B√£o s√©t' },
{ id: 'buy_lightning_dmg_2', name: 'Dmg +0.5', icon: 'üå©Ô∏è', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'B√£o s√©t' },
{ id: 'buy_lightning_dmg_3', name: 'Dmg +1',   icon: 'üå©Ô∏è', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'B√£o s√©t' },

// --- N√¢ng c·∫•p Bom B52 ---
{ id: 'buy_b52_dmg_1', name: 'Dmg +0.2', icon: 'üí£', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'Bom B52' },
{ id: 'buy_b52_dmg_2', name: 'Dmg +0.5', icon: 'üí£', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'Bom B52' },
{ id: 'buy_b52_dmg_3', name: 'Dmg +1',   icon: 'üí£', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'Bom B52' },

// --- N√¢ng c·∫•p ·∫¢o ·∫£nh ph√¢n th√¢n ---
{ id: 'buy_clone_dmg_1', name: 'Dmg +0.2', icon: 'üé≠', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: '·∫¢o ·∫£nh ph√¢n th√¢n' },
{ id: 'buy_clone_dmg_2', name: 'Dmg +0.5', icon: 'üé≠', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: '·∫¢o ·∫£nh ph√¢n th√¢n' },
{ id: 'buy_clone_dmg_3', name: 'Dmg +1',   icon: 'üé≠', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: '·∫¢o ·∫£nh ph√¢n th√¢n' },

// --- N√¢ng c·∫•p H·ªë ƒëen ---
{ id: 'buy_blackhole_dmg_1', name: 'Dmg +0.2', icon: 'üï≥Ô∏è', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'H·ªë ƒëen' },
{ id: 'buy_blackhole_dmg_2', name: 'Dmg +0.5', icon: 'üï≥Ô∏è', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'H·ªë ƒëen' },
{ id: 'buy_blackhole_dmg_3', name: 'Dmg +1',   icon: 'üï≥Ô∏è', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'H·ªë ƒëen' },

// --- N√¢ng c·∫•p Boom h·∫°t nh√¢n ---
{ id: 'buy_nuke_dmg_1', name: 'Dmg +10', icon: '‚ò¢Ô∏è', cost: 10, type: 'active_skill_damage_upgrade', value: 10, skillName: 'Boom h·∫°t nh√¢n' },
{ id: 'buy_nuke_dmg_2', name: 'Dmg +25', icon: '‚ò¢Ô∏è', cost: 20, type: 'active_skill_damage_upgrade', value: 25, skillName: 'Boom h·∫°t nh√¢n' },
{ id: 'buy_nuke_dmg_3', name: 'Dmg +50', icon: '‚ò¢Ô∏è', cost: 35, type: 'active_skill_damage_upgrade', value: 50, skillName: 'Boom h·∫°t nh√¢n' },

// --- N√¢ng c·∫•p Qu·∫£ c·∫ßu h·∫•p huy·∫øt ---
{ id: 'buy_bloodorb_dmg_1', name: 'Dmg +0.2', icon: 'ü©∏', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'Qu·∫£ c·∫ßu h·∫•p huy·∫øt' },
{ id: 'buy_bloodorb_dmg_2', name: 'Dmg +0.5', icon: 'ü©∏', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'Qu·∫£ c·∫ßu h·∫•p huy·∫øt' },
{ id: 'buy_bloodorb_dmg_3', name: 'Dmg +1',   icon: 'ü©∏', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'Qu·∫£ c·∫ßu h·∫•p huy·∫øt' },

// --- N√¢ng c·∫•p C·ªïng Kh√¥ng Gian ---
{ id: 'buy_spacegate_dmg_1', name: 'Dmg +0.2', icon: 'üåÄ', cost: 7, type: 'active_skill_damage_upgrade', value: 0.2, skillName: 'C·ªïng Kh√¥ng Gian' },
{ id: 'buy_spacegate_dmg_2', name: 'Dmg +0.5', icon: 'üåÄ', cost: 14, type: 'active_skill_damage_upgrade', value: 0.5, skillName: 'C·ªïng Kh√¥ng Gian' },
{ id: 'buy_spacegate_dmg_3', name: 'Dmg +1',   icon: 'üåÄ', cost: 25, type: 'active_skill_damage_upgrade', value: 1,   skillName: 'C·ªïng Kh√¥ng Gian' },

];
// ‚ú® DANH S√ÅCH C√ÅC LO·∫†I ZOMBIE ‚ú®
const zombieTypes = [ // 52 lo·∫°i zombie
    "Walker", "Brute", "Spitter", "Mutant",
    "Cyber", "Hunter", "Shadow", "Arcanist", "Soldier", "Robot",
    "Knight", "Rogue", "Wraith", "Astronaut", "Beast", "Spectre",
    "Ninja", "Samurai", "Alien", "Skeleton", "Mage", "Ghost",
    "Monk", "Cyborg", "Shaman", "Demon", "Angel", "Guardian",
    "Pilot", "Engineer", "Android", "Starfighter", "Commander", "Medic",
    "Barbarian", "Paladin", "Druid", "Necromancer", "Archer", "Sorcerer",
    "Bard", "Cleric", "Vampire", "Werewolf", "Goblin", "Elf",
    "Dwarf", "Orc", "Detective", "Swat", "Firefighter", "Doctor",
    "Wastelander", "Scavenger", "Hunter", "Plaguebearer", "Gravekeeper", "Revenant", "Stalker", "Abomination", "Wraith", "Butcher",
];
let lastBigBossTimerUpdate = performance.now();
let bigBossRespawnTimer = 0;
const bigBossRespawnInterval = 3; // Th·ªùi gian h·ªìi sinh bigboss - gi√¢y
// T·∫†O BI·∫æN CH·ª®A KHO √ÇM THANH
const sfxPool = {}; // M·ªói key l√† m·ªôt ID √¢m thanh, value l√† m·ªôt m·∫£ng c√°c ƒë·ªëi t∆∞·ª£ng Audio

/**
 * T·∫†O H√ÄM KH·ªûI T·∫†O KHO √ÇM THANH
 * H√†m n√†y s·∫Ω ch·∫°y m·ªôt l·∫ßn duy nh·∫•t khi game b·∫Øt ƒë·∫ßu.
 * N√≥ s·∫Ω t·∫°o s·∫µn m·ªôt s·ªë l∆∞·ª£ng ƒë·ªëi t∆∞·ª£ng Audio cho m·ªói hi·ªáu ·ª©ng √¢m thanh.
 * @param {number} poolSize - S·ªë l∆∞·ª£ng ƒë·ªëi t∆∞·ª£ng Audio t·∫°o s·∫µn cho m·ªói √¢m thanh.
 */
function initAudioPool(poolSize = 5, onProgress, onComplete) {
    console.log("Initializing audio resources...");
    
    // T√¨m t·∫•t c·∫£ c√°c th·∫ª audio c·∫ßn t·∫£i tr∆∞·ªõc
    const sfxElements = document.querySelectorAll('audio[id^="sfx-"]');
    const musicElements = document.querySelectorAll('audio[id^="music-"]');
    
    let totalToLoad = (sfxElements.length * poolSize) + musicElements.length;
    let loadedCount = 0;

    // H√†m n√†y ƒë∆∞·ª£c g·ªçi m·ªói khi m·ªôt file audio t·∫£i xong
    const handleLoad = () => {
        loadedCount++;
        if (onProgress) {
            onProgress(loadedCount, totalToLoad); // G·ª≠i ti·∫øn tr√¨nh ra ngo√†i
        }
        if (loadedCount >= totalToLoad && onComplete) {
            onComplete(); // G·ªçi callback khi ho√†n t·∫•t
        }
    };

    // X·ª≠ l√Ω c√°c file hi·ªáu ·ª©ng SFX (t·∫°o th√†nh kho)
    sfxElements.forEach(audioElement => {
        const id = audioElement.id;
        sfxPool[id] = {
            pool: [],
            currentIndex: 0
        };
        for (let i = 0; i < poolSize; i++) {
            const audio = new Audio(audioElement.src);
            // L·∫Øng nghe s·ª± ki·ªán canplaythrough ƒë·ªÉ bi·∫øt khi n√†o c√≥ th·ªÉ ph√°t
            audio.addEventListener('canplaythrough', handleLoad, { once: true });
            audio.load();
            sfxPool[id].pool.push(audio);
        }
    });

    // X·ª≠ l√Ω c√°c file nh·∫°c n·ªÅn (ch·ªâ c·∫ßn t·∫£i 1 l·∫ßn)
    musicElements.forEach(audioElement => {
        audioElement.addEventListener('canplaythrough', handleLoad, { once: true });
        audioElement.load();
    });

    // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p kh√¥ng c√≥ audio n√†o ƒë·ªÉ t·∫£i
    if (totalToLoad === 0 && onComplete) {
        onComplete();
    }
}

// üî´ C·∫•u h√¨nh b·∫Øn
let autoBurstIndex = 0;
let autoLastBurstTime = 0;
let clickShotMode = 5; // 0: xo·∫Øn ·ªëc, 1: zigzag, 2: spiral, 3: xuy√™n th·∫≥ng, 4: m·∫∑c ƒë·ªãnh

const autoBurstDelay = 100; // ms delay gi·ªØa t·ª´ng vi√™n trong auto

// üßü Th·ªëng k√™ ‚Äì K·ªπ nƒÉng & zombie
let zombieKillCount = 0;
let zombieSpawnedCount = 0;
let zombieByLevel = {};
for (let i = 1; i <= 10; i++) zombieByLevel[i] = 0;
zombieByLevel.boss = 0;
zombieByLevel.miniBoss = 0;
let skillStats = {};             // üìä Th·ªëng k√™ k·ªπ nƒÉng
// üéØ EXP l√™n c·∫•p
const INITIAL_REQUIRED_EXP = 100; // EXP c·∫ßn ƒë·ªÉ l√™n c·∫•p
// üßç Tr·∫°ng th√°i ng∆∞·ªùi ch∆°i
const player = {
  x: 480, y: 360, size: 20, speed: 1,
  hearts: 10, energy: 0, mana: 0,
  staminaMax: 10,
  stamina: 10,
  coins: 0,
  level: 1, score: 0,
  statPoints: 3, // ƒêi·ªÉm n√¢ng c·∫•p
  maxHearts: 10,
  armor: 0, // Gi√°p
  exp: 0,
  currentLevelExp: 0, // EXP hi·ªán t·∫°i c·ªßa level
  requiredExp: INITIAL_REQUIRED_EXP,  // EXP c·∫ßn ƒë·ªÉ l√™n c·∫•p
  hitTimer: 0,
  name: "Player",
  isDying: false,
  isTeleporting: false,      // C·ªù b√°o hi·ªáu ƒëang trong qu√° tr√¨nh d·ªãch chuy·ªÉn
  isGrowingAfterTeleport: false, // C·ªù b√°o hi·ªáu ƒëang l·ªõn d·∫ßn ra sau khi d·ªãch chuy·ªÉn
  originalSize: 20,          // D√πng ƒë·ªÉ l∆∞u l·∫°i k√≠ch th∆∞·ªõc g·ªëc
  // L∆∞u tr·ªØ s·ªë l∆∞·ª£ng ƒë·∫°n cho t·ª´ng lo·∫°i
  // C√°c key (0-4) t∆∞∆°ng ·ª©ng v·ªõi clickShotMode
  ammo: {
    0: 100, // ƒê·∫°n Xo·∫Øn ·ªëc
    1: 150, // ƒê·∫°n Zigzag
    2: 100, // ƒê·∫°n Xo·∫Øn bay th·∫≥ng
    3: 50,  // ƒê·∫°n Xuy√™n th·∫≥ng
    4: 20   // ƒê·∫°n Laze
  }
};

// üåü Tr·∫°ng th√°i n√¢ng c·∫•p
const playerUpgrades = {
  iceArrow: 1,          // üèπ Ice Arrow
  damageBoost: 1,       // üí• S√°t th∆∞∆°ng c∆° b·∫£n c·ªông th√™m
  hpBoost: 0,           // ‚ù§Ô∏è S·ªë l·∫ßn ƒë√£ tƒÉng m√°u
  bulletSpeed: 1,       // üí® T·ªëc ƒë·ªô ƒë·∫°n
  lineBulletCount: 1    // üß® S·ªë l∆∞·ª£ng ƒë·∫°n
};
// üõí Shop-only
const shopUpgrades = {
  iceArrowSpeedLevel: 0, // 0..3
};
// üåü Bi·∫øn n√¢ng c·∫•p k·ªπ nƒÉng m·∫∑c ƒë·ªãnh (üî™ ƒêao, ‚öîÔ∏è Ki·∫øm, üî• L·ª≠a, ‚ùÑÔ∏è BƒÉng)
const skillUpgrades = {
  // üî™ ƒêao: s·ªë l∆∞·ª£ng ƒëao v√† s√°t th∆∞∆°ng t·ª´ng ƒëao
  bladeCount: 2,           // b·∫Øt ƒë·∫ßu 2 ƒëao, t·ªëi ƒëa 20
  bladeDamage: 1,          // s√°t th∆∞∆°ng t·ª´ng ƒëao

  // ‚öîÔ∏è Ki·∫øm: c·∫•p ƒë·ªô m∆∞a ki·∫øm (s·ªë l∆∞·ª£ng + s√°t th∆∞∆°ng)
  swordLevel: 1,           // c·∫•p ƒë·ªô m∆∞a ki·∫øm, t·ªëi ƒëa 10
  swordDamage: 3,          // s√°t th∆∞∆°ng m·ªói ki·∫øm

  // üî• L·ª≠a: s·ªë l∆∞·ª£ng c·∫ßu l·ª≠a v√† s√°t th∆∞∆°ng
  fireCount: 2,            // b·∫Øt ƒë·∫ßu 2 qu·∫£ c·∫ßu, t·ªëi ƒëa 10
  fireDamage: 1,           // s√°t th∆∞∆°ng m·ªói qu·∫£

  // ‚ùÑÔ∏è BƒÉng: s·ªë l∆∞·ª£ng c·∫ßu bƒÉng v√† s√°t th∆∞∆°ng
  iceCount: 2,             // b·∫Øt ƒë·∫ßu 2 qu·∫£ c·∫ßu, t·ªëi ƒëa 10
  iceDamage: 2,             // s√°t th∆∞∆°ng m·ªói qu·∫£
  // L√¥i
  thunderCount: 2,         // b·∫Øt ƒë·∫ßu 2 qu·∫£ c·∫ßu l√¥i, t·ªëi ƒëa 6
  thunderDamage: 3,        // s√°t th∆∞∆°ng m·ªói qu·∫£ c·∫ßu l√¥i
  // ü¶ã N√¢ng c·∫•p k·ªπ nƒÉng Fairy
  fairyCount: 1,      // S·ªë l∆∞·ª£ng Fairy, t·ªëi ƒëa 3
  fairyHealLevel: 0,  // C·∫•p ƒë·ªô h·ªìi m√°u
  fairyDamageLevel: 0, // C·∫•p ƒë·ªô tƒÉng s√°t th∆∞∆°ng
  
  auraHealLevel: 0, // C·∫•p ƒë·ªô h·ªìi m√°u c·ªßa H√†o quang, b·∫Øt ƒë·∫ßu t·ª´ 0

};
let petActive = false;
let petEndTime = 0;
let petRabbit = null;
let petLastHealTime = 0;
/* ‚îÄ‚îÄ ch·ªëng ch·ªçn l·∫°i m√≥n ƒë·ªì v·ª´a b·ªè ‚îÄ‚îÄ */
let lastGiveUpId   = null;   // id m√≥n ƒë·ªì v·ª´a b·ªã b·ªè
let lastGiveUpTime = 0;      // m·ªëc th·ªùi gian b·ªè
const RESELECT_CD  = 2000;   // 2 000 ms ‚Üí c·∫•m ch·ªçn l·∫°i 2 s
let auraCrackLines = []; // M·∫£ng ch·ª©a c√°c ƒë∆∞·ªùng n·ª©t ph√°t s√°ng d∆∞·ªõi ƒë·∫•t
let auraLightBeams = []; // M·∫£ng ch·ª©a c√°c c·ªôt s√°ng bay l√™n
let supportAuraActive = false;
let supportAuraEndTime = 0;
let lastAuraHealTime = 0;
// ‚öôÔ∏è Tr·∫°ng th√°i ƒëi·ªÅu khi·ªÉn & k·ªπ nƒÉng
let lastManualShootTime = 0;
const manualShootCooldown = 500; // T·ªëc ƒë·ªô b·∫Øn th·ªß c√¥ng (click chu·ªôt)
let lastAutoShootTime = 0;
const autoShootCooldown = 500;
let playerLasers = []; // M·∫£ng ch·ª©a c√°c tia laze c·ªßa ng∆∞·ªùi ch∆°i

let keys = {};
let autoShoot = false;
let fireActive = false;
let iceActive = false;
let swordActive = false;
let bladeActive = false;
let frame = 0;
let gameOver = false;
let isPaused = false;
let pendingWave = null;
let uiVisible = true; // Tr·∫°ng th√°i hi·ªÉn th·ªã UI
let swordRainClouds = [];
let nextFireIndex = 0; // K·ªπ nƒÉng ƒëao xoay

// K·ªπ nƒÉng active
let satelliteActive = false;
let satelliteEndTime = 0;
let satellites = [];

let ufoActive = false; // K·ªπ nƒÉng UFO
let ufoEndTime = 0;
let ufoCooldown = 0;
let ufoCount = 1;
let ufos = [];
// ========================= ‚ö° Lightning ‚Äì tr·∫°ng th√°i & d·ªØ li·ªáu =========================
let lightningActive = false; // K·ªπ nƒÉng s√©t - tr·∫°ng th√°i & d·ªØ li·ªáu
let lightningEndTime = 0;
let lightningBolts = [];
let activeLightningStrikes = [];
let nextLightningStrikeTime = 0;
let disguiseActive = false;
let disguiseEndTime = 0;

let clones = []; // üé≠ Global ‚Äì l∆∞u c√°c b·∫£n sao hi·ªán t·∫°i
let clonesActive = false;
let clonesEndTime = 0;
let activeCloneLasers = []; // M·∫£ng ch·ª©a c√°c tia lazer c·ªßa clone

let blackHoles = []; // Danh s√°ch h·ªë ƒëen
let extraShockwaves = []; // üåä c√°c v√≤ng n·ªï ph·ª• lan ra

let bloodOrbActive = false;
let bloodOrbEndTime = 0;
let bloodOrbs = []; // [{ angle, radius, x, y }]
let bloodOrbCount = 1; // v·ªÅ sau n√¢ng c·∫•p +1 qu·∫£ c·∫ßu
let bloodOrbLastDrain = 0;
let particles = [];
let healEffects = []; // T·∫°o "Kho" Ch·ª©a Hi·ªáu ·ª©ng

// üö™ Tr·∫°ng th√°i C·ªïng Kh√¥ng Gian
let spaceGate = null; // Bi·∫øn ch·ª©a ƒë·ªëi t∆∞·ª£ng c·ªïng
let spaceGateActive = false;
let spaceGateEndTime = 0;
let lastTeleportTime = 0; // L∆∞u th·ªùi ƒëi·ªÉm d·ªãch chuy·ªÉn cu·ªëi
const GATE_COOLDOWN = 2000; // 1000ms = 1 gi√¢y ch·ªù
// Qu·∫£n l√Ω tr·∫°ng th√°i animation khi d·ªãch chuy·ªÉn
let playerTeleportState = {
    phase: null, // c√°c giai ƒëo·∫°n: 'shrinking', 'growing'
    progress: 0, // ti·∫øn tr√¨nh c·ªßa hi·ªáu ·ª©ng (t·ª´ 1.0 xu·ªëng 0.0 v√† ng∆∞·ª£c l·∫°i)
    originalPlayerSize: 0,
    originalGateRadius: 0,
};

// üåä Qu·∫£n l√Ω wave
let wave = 1;
let waveTime = 90; // Th·ªùi gian m·ªói wave
let waveTimer = waveTime;
let lastWaveTime = null;
let gameStarted = false;

// ‚è± Th·ªùi gian k·ªπ nƒÉng
let fireEndTime = 0;
let iceEndTime = 0;
let swordEndTime = 0;
let bladeEndTime = 0;
let levelUpGlowTime = 0;
let nextBladeToAttack = 0; // Theo d√µi th·ª© t·ª± c·ªßa ƒëao s·∫Øp t·∫•n c√¥ng
let lastBladeLaunchTime = 0; // M·ªëc th·ªùi gian c·ªßa l·∫ßn ph√≥ng ƒëao cu·ªëi

// üì± ƒêi·ªÅu khi·ªÉn c·∫£m ·ª©ng
let touchStartX = null, touchStartY = null;
let touchMoveX = null, touchMoveY = null;

// üéÆ Danh s√°ch c√°c ƒë·ªëi t∆∞·ª£ng trong game
let enemyBullets = []; // Zombie b·∫Øn tr·∫£
let zombies = [];
let bullets = [];
let swords = [];
let downwardSwords = [];
let fireballs = [];
let iceballs = [];
let thunderActive = false;
let thunderEndTime = 0;
let thunderBalls = [];
let items = [];
let explosions = [];
let missiles = []; // üöÄ Danh s√°ch t√™n l·ª≠a ƒëang bay
let expandingExplosions = []; // ‚ò¢Ô∏è C√°c v√≤ng n·ªï lan r·ªông (d√πng cho bom h·∫°t nh√¢n)
let nuclearBombs = []; // M·∫£ng l∆∞u tr·ªØ ri√™ng bom h·∫°t nh√¢n
let bombsB52 = []; // üí£ Danh s√°ch bom B52
let activePlanes = [];   // üõ¨ Danh s√°ch m√°y bay ƒëang ho·∫°t ƒë·ªông

// üîß V·∫Ω Canvas
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
// === SHOP NPC input (capture ƒë·ªÉ ch·∫∑n b·∫Øn) ================================
canvas.addEventListener('mousemove', function(e){
  const p = getMouseWorld(e);
  const over = npcHitTestWorld(p.x, p.y);
  if (over !== __npcHover){ __npcHover = over; }
  if (over) canvas.style.cursor = 'pointer';
}, true);

canvas.addEventListener('mousedown', function(e){
  const p = getMouseWorld(e);
  if (npcHitTestWorld(p.x, p.y)) {
    e.preventDefault();
    e.stopImmediatePropagation(); // ch·∫∑n handler b·∫Øn ƒë·∫°n ph√≠a sau
    openShopFromNPC();
  }
}, true);

// ========= Zombie Inspector ‚Äî Hover to show popup (no Ctrl+Click) =========
(function ZombieInspectorHover() {
  const canvas = document.getElementById('game')
             || document.getElementById('gameCanvas')
             || document.getElementById('canvas')
             || document.querySelector('canvas');
  if (!canvas) { console.warn('[Inspector] Kh√¥ng t√¨m th·∫•y canvas'); return; }

  // ====== C·∫•u h√¨nh k·ªπ nƒÉng m·∫∑c ƒë·ªãnh ======
  // K·ªπ nƒÉng m·∫∑c ƒë·ªãnh theo LO·∫†I (c√≥ th·ªÉ s·ª≠a/ m·ªü r·ªông tu·ª≥ √Ω)
  const SKILL_BY_TYPE = {
    normal:   ['C·∫Øn'],
    elite:    ['C·∫Øn m·∫°nh'],
    miniBoss: ['C·∫Øn r√°t'],
    boss:     ['C·∫Øn s√¢u'],
    bigBoss:  ['Laze Cu·ªìng n·ªô']
  };
  // Ghi ƒë√® theo T√äN c·ª• th·ªÉ (∆∞u ti√™n cao h∆°n type). V√≠ d·ª•:
  // 'Zombie BƒÉng': ['ƒê√≥ng bƒÉng', 'B·∫Øn m·∫£nh bƒÉng']
  const SKILL_BY_NAME = {
    // Th√™m: 'T√™nZombie': ['Skill A', 'Skill B']
    Ninja: ['Phi ti√™u'],
  };

  const ZLIST = () => (typeof zombies !== 'undefined' ? zombies :
                      (window.zombies || window.enemyList || window.enemies || []));
  const CAMX  = () => (typeof camera  !== 'undefined' ? (camera.x||0) :
                      (window.camera?.x ?? window.camX ?? window.cameraX ?? 0));
  const CAMY  = () => (typeof camera  !== 'undefined' ? (camera.y||0) :
                      (window.camera?.y ?? window.camY ?? window.cameraY ?? 0));

  function fmtAbbr(n){ n=Math.max(0,Math.floor(n||0)); const t=v=>String(v.toFixed(1)).replace(/\.0$/,'');
    if(n>=1e9)return t(n/1e9)+'B'; if(n>=1e6)return t(n/1e6)+'M'; if(n>=1e3)return t(n/1e3)+'k'; return String(n); }

  function toCanvasSpace(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const sx = canvas.width  / rect.width;
    const sy = canvas.height / rect.height;
    return { x: (clientX-rect.left)*sx, y: (clientY-rect.top)*sy };
  }
  function worldToScreen(x, y){ return { x: x - CAMX(), y: y - CAMY() }; }

  function pickZombieAt(sx, sy){
    const list = ZLIST();
    let best=null, bestD=1e9;
    for (let i=0;i<list.length;i++){
      const z = list[i];
      if (!z || z.hp<=0 || z.active===false || z.dead) continue;
      const p = worldToScreen(z.x, z.y);
      const r = (z.radius || 16) + 12;
      const d = Math.hypot(p.x - sx, p.y - sy);
      if (d < r && d < bestD) { best = z; bestD = d; }
    }
    return best;
  }

  function ensurePopup(){
    let el = document.getElementById('zombieInfoPopup');
    if (!el){
      el = document.createElement('div');
      el.id='zombieInfoPopup';
      el.style.cssText = `
        position:fixed;z-index:9999;max-width:280px;padding:10px 12px;border-radius:10px;
        background:rgba(20,16,24,.92);border:1px solid #a855f7;box-shadow:0 8px 24px rgba(168,85,247,.25);
        color:#eee;font:12px/1.35 system-ui,Arial,sans-serif;backdrop-filter:blur(4px);
        display:none; pointer-events:none
      `;
      document.body.appendChild(el);
    }
    return el;
  }
  function hidePopup(){ const el = document.getElementById('zombieInfoPopup'); if (el) el.style.display='none'; }
  function placePopup(clientX, clientY){
    const el = document.getElementById('zombieInfoPopup');
    if (!el || el.style.display==='none') return;
    const r = el.getBoundingClientRect(), vw=innerWidth, vh=innerHeight;
    let L = clientX + 12, T = clientY + 12;
    if (L + r.width  > vw - 8) L = vw - r.width  - 8;
    if (T + r.height > vh - 8) T = vh - r.height - 8;
    el.style.left = L + 'px'; el.style.top = T + 'px';
  }

  // L·∫•y Max HP an to√†n
  function getMaxHP(z) {
    const cur = Number(z.hp ?? z.health ?? 0);
    const cand = [ z.hpMax, z.maxHp, z.maxHP, z.baseHp, z.baseHP, z.maxHealth, z.healthMax, z.hp_cap, z.hp_max ]
      .map(v => Number(v ?? 0)).filter(v => v > 0);
    const best = cand.length ? Math.max(...cand) : 0;
    return Math.max(1, cur, best);
  }

  // Nh·∫≠n di·ªán LO·∫†I (tr·∫£ v·ªÅ key & label; c√≥ c·∫£ 'normal')
  function getType(z) {
    const isBigBoss = !!(z.isBigBoss || z.bigBoss || z.rank === 'bigBoss' || z.type === 'bigBoss');
    const isBoss    = !isBigBoss && !!(z.isBoss || z.boss || z.rank === 'boss' || z.type === 'boss');
    const isMini    = !isBigBoss && !isBoss && !!(
      z.isMiniBoss || z.miniBoss || z.isMini || z.mini ||
      z.rank === 'miniBoss' || z.rank === 'mini_boss' ||
      z.type === 'miniBoss' || z.type === 'mini_boss' || z.level === 99
    );
    const isElite   = !!(z.isElite || z.elite || z.rank === 'elite' || z.tier === 'elite');

    /** Ch·ªçn duy nh·∫•t 1 lo·∫°i ch√≠nh ƒë·ªÉ hi·ªÉn th·ªã & map skill */
    let typeKey = 'normal', typeLabel = 'Th∆∞·ªùng';
    if (isBigBoss) { typeKey = 'bigBoss'; typeLabel = 'Big Boss'; }
    else if (isBoss) { typeKey = 'boss'; typeLabel = 'Boss'; }
    else if (isMini) { typeKey = 'miniBoss'; typeLabel = 'Mini Boss'; }
    else if (isElite){ typeKey = 'elite'; typeLabel = 'Tinh anh'; }

    return { typeKey, typeLabel };
  }

  // L·∫•y danh s√°ch k·ªπ nƒÉng theo ∆∞u ti√™n:
  // 1) z.skills (n·∫øu c√≥)  >  2) override theo t√™n  >  3) theo lo·∫°i  >  4) z.skillNames  >  []
  function getSkillsFor(z, typeKey) {
    const explicit = Array.isArray(z.skills) ? z.skills : (Array.isArray(z.skillNames) ? z.skillNames : null);
    if (explicit && explicit.length) return explicit;

    const nameKey = String(z.displayName || z.name || z.style || '').trim();
    if (nameKey && Array.isArray(SKILL_BY_NAME[nameKey])) return SKILL_BY_NAME[nameKey];

    const byType = SKILL_BY_TYPE[typeKey];
    return Array.isArray(byType) ? byType : [];
  }

  function tagHTML(t){
    return `<span style="display:inline-block;padding:1px 6px;border-radius:999px;border:1px solid rgba(255,255,255,.15);font-size:11px;margin-right:6px">${t}</span>`;
  }
// EXP c∆° b·∫£n (tr∆∞·ªõc ¬±10% v√† buff), b√°m ƒë√∫ng 3.1 b·∫°n g·ª≠i
function calcExpBase(z){
  const w = (typeof wave !== 'undefined' ? wave : (globalThis.wave|0)) || 1;

  if (z.isBigBoss) return calculateScaledBossExp(1000, w);
  if (z.isBoss)    return calculateScaledBossExp(100,  w);
  if (z.type === 'miniBoss' || z.isMiniBoss) return calculateScaledBossExp(10, w);

  const base = z.isElite ? 5 : 1;
  const levelBonus = (z.level || 1) - 1;
  const waveBonus  = w - 1;
  return base + levelBonus + waveBonus;
}
  function showZombieInfo(z, clientX, clientY){
    const el = ensurePopup();
    const name = z.style || z.name || 'Zombie';
    const lv   = z.level ?? 1;

    const hp    = Number(z.hp ?? z.health ?? 0);
    const maxHp = getMaxHP(z);
    const pct   = maxHp > 0 ? Math.round(Math.min(1, hp / maxHp) * 100) : 0;

    // Lo·∫°i + k·ªπ nƒÉng
    const { typeKey, typeLabel } = getType(z);
    const skills = getSkillsFor(z, typeKey);

    // ‚úÖ EXP ƒë√∫ng s·ªë s·∫Ω nh·∫≠n n·∫øu gi·∫øt hi·ªán t·∫°i
    const baseExp = calcExpBase(z);
// Hi·ªÉn th·ªã s√°t th∆∞∆°ng c∆° b·∫£n c·ªßa zombie (tr∆∞·ªõc gi√°p & buff c·ªßa player)
const atk = (typeof calculateZombieDamage === 'function')
  ? calculateZombieDamage(z)
  : Math.max(1, z.damage || z.baseDamage || 1);
  const armor = Math.max(0, Number(z.armor || 0));
    // üèÉ Speed: l·∫•y speed hi·ªán t·∫°i, k√®m baseSpeed ƒë·ªÉ so nhanh/ch·∫≠m
    const spd  = Number(z.speed ?? z.baseSpeed ?? 0);
    const bspd = Number(z.baseSpeed ?? spd);
    el.innerHTML = `
      <h4 style="margin:0 0 6px;font-size:14px;color:#d9b8ff">${name} <span style="opacity:.8">Lv${lv}</span></h4>
      <div style="margin-top:2px">HP: ${fmtAbbr(hp)} / ${fmtAbbr(maxHp)} (${pct}%)</div>
      <div style="margin-top:2px">Gi√°p: ${fmtAbbr(armor)}</div>
      <div style="margin-top:2px">EXP: ${fmtAbbr(baseExp)} <span style="opacity:.8">(¬±10%)</span></div>
      <div style="margin-top:2px">ATK: ${fmtAbbr(atk)} <span style="opacity:.8">(+${z._atkRnd ?? 0} rng)</span></div>
      <div style="margin-top:2px">SPD: ${spd.toFixed(2)} <span style="opacity:.8">(chase ${bspd.toFixed(2)})</span></div>
      <div style="margin-top:6px">Zombie: ${tagHTML(typeLabel)}</div>
      <div style="margin-top:6px">K·ªπ nƒÉng: ${
        (skills && skills.length) ? skills.map(s=>tagHTML(s)).join(' ') : '<span style="opacity:.8">‚Äî</span>'
      }</div>
      ${z.desc || z.description ? `<div style="margin-top:6px;opacity:.8">${z.desc || z.description}</div>` : ''}
    `;
    el.style.display='block';
    placePopup(clientX, clientY);
  }

  // Hover logic (re-render khi ƒë·ªïi wave)
  let lastShown=null, lastShowTs=0, lastShownWave = (typeof wave !== 'undefined' ? wave : (globalThis.wave|0)) || 1;

  canvas.addEventListener('mousemove', (e)=>{
    const {x,y} = toCanvasSpace(e.clientX, e.clientY);
    const cur = pickZombieAt(x, y);
    canvas.style.cursor = cur ? 'pointer' : 'default';
    if (!cur){ hidePopup(); lastShown=null; return; }

    const ts = performance.now();
    const wNow = (typeof wave !== 'undefined' ? wave : (globalThis.wave|0)) || 1;

    if (cur === lastShown && wNow === lastShownWave) { placePopup(e.clientX, e.clientY); return; }
    if (ts - lastShowTs < 50) { placePopup(e.clientX, e.clientY); return; }
    lastShown = cur; lastShowTs = ts; lastShownWave = wNow;
    showZombieInfo(cur, e.clientX, e.clientY);
  }, true);

  canvas.addEventListener('mouseleave', ()=>{ lastShown=null; hidePopup(); canvas.style.cursor='default'; }, true);
  console.info('[Inspector] Hover popup ƒë√£ g·∫Øn v√†o', canvas);
})();
// ========= Equip Drop Hover ‚Äî centralized in index =========
(function EquipDropHover(){
  const canvas = document.getElementById('game')
             || document.getElementById('gameCanvas')
             || document.querySelector('canvas');
  if (!canvas) return;

  // --- DOM: one-time popup for equip
  function ensureEquipPopup() {
    let el = document.getElementById('equipInfoPopup');
    if (!el) {
      el = document.createElement('div');
      el.id = 'equipInfoPopup';
      el.style.cssText = `
        position:fixed; z-index:10060; max-width:320px;
        padding:8px 10px; border-radius:10px;
        background:rgba(15,18,26,.96);
        border:1px solid rgba(255,255,255,.12);
        box-shadow:0 6px 24px rgba(0,0,0,.35);
        color:#fff; font:12px/1.35 system-ui,Segoe UI,Roboto;
        white-space:normal; pointer-events:none; display:none;
      `;
      document.body.appendChild(el);
    }
    return el;
  }
  function hideEquipPopup(){ const el = document.getElementById('equipInfoPopup'); if (el) el.style.display='none'; }
  function placeEquipPopup(clientX, clientY){
    const el = document.getElementById('equipInfoPopup');
    if (!el || el.style.display==='none') return;
    const r = el.getBoundingClientRect(), vw=innerWidth, vh=innerHeight;
    let L = clientX + 12, T = clientY + 12;
    if (L + r.width  > vw - 8) L = vw - r.width  - 8;
    if (T + r.height > vh - 8) T = vh - r.height - 8;
    el.style.left = L + 'px'; el.style.top = T + 'px';
  }

  // --- Helpers: d√πng c√πng camera/canvas v·ªõi zombie tooltip
  const CAMX  = () => (typeof camera !== 'undefined' ? (camera.x||0) : (window.camera?.x ?? 0));
  const CAMY  = () => (typeof camera !== 'undefined' ? (camera.y||0) : (window.camera?.y ?? 0));
  function worldToScreen(x, y){ return { x: x - CAMX(), y: y - CAMY() }; }
  function toCanvasSpace(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const sx = canvas.width  / rect.width;
    const sy = canvas.height / rect.height;
    return { x: (clientX-rect.left)*sx, y: (clientY-rect.top)*sy };
  }

// --- Builder cho tooltip trang b·ªã (string HTML) ‚Äî d√πng chung v·ªõi Kho ƒë·ªì
function buildEquipTooltipHTML(entry){
  // ∆Øu ti√™n d√πng builder c·ªßa Kho ƒë·ªì ƒë·ªÉ ƒë·ªìng b·ªô ho√†n to√†n
  if (typeof window.buildEquipTooltipHTML === 'function') {
    return window.buildEquipTooltipHTML(entry); // <- d√πng chung
  }
  // Fallback r·∫•t g·ªçn ƒë·ªÅ ph√≤ng character_panel ch∆∞a load
  const name   = entry?.name || 'Trang b·ªã';
  const icon   = entry?.icon || '‚¨ö';
  const tier   = Number(entry?.tier || 1);
  const rarity = String(entry?.rarity || 'common').toUpperCase();
  return `
    <div style="font-weight:700">${icon} ${name}</div>
    <div style="opacity:.8;margin-top:2px">B·∫≠c ${tier} ‚Ä¢ ${rarity}</div>
  `;
}

  // --- Hover state (hysteresis)
  let lastClientX=-1, lastClientY=-1;
  let lastCamX=CAMX(), lastCamY=CAMY();
  let hovered = null; // {dropRef, enterR, leaveR}
  let nextScanAt = 0;

  canvas.addEventListener('mousemove', (ev)=>{
    lastClientX = ev.clientX;
    lastClientY = ev.clientY;
    nextScanAt = 0; // scan ngay
  }, {passive:true});
  canvas.addEventListener('mouseleave', ()=>{ hovered=null; hideEquipPopup(); }, {passive:true});

  function scan(){
    const api = window.EquipmentDropAPI;
    if (!api || (!api.getActiveDropsRef && !api.forEachActiveDrop)) return;

    const camx = CAMX(), camy = CAMY();
    const camMoved = (camx!==lastCamX) || (camy!==lastCamY);
    lastCamX=camx; lastCamY=camy;

    if (lastClientX<0 || lastClientY<0) { if (hovered) { hovered=null; hideEquipPopup(); } return; }

    const cvsPt = toCanvasSpace(lastClientX, lastClientY);
    const sx = cvsPt.x, sy = cvsPt.y;

    let best=null, bestD=1e9;
    const enterR = hovered? hovered.enterR : 24;
    const leaveR = hovered? hovered.leaveR : 32;

    // iterate drops ‚Äî kh√¥ng t·∫°o m·∫£ng m·ªõi
    if (api.forEachActiveDrop){
      api.forEachActiveDrop((d)=>{
        const p = worldToScreen(d.x, d.y);
        const dx=p.x - sx, dy=p.y - sy;
        const dist = Math.hypot(dx,dy);
        const r = (hovered && hovered.dropRef===d) ? leaveR : enterR;
        if (dist < r && dist < bestD){ best=d; bestD=dist; }
      });
    } else {
      const arr = api.getActiveDropsRef();
      for (let i=0;i<arr.length;i++){
        const d = arr[i];
        if (!d || !d.active) continue;
        const p = worldToScreen(d.x, d.y);
        const dx=p.x - sx, dy=p.y - sy;
        const dist = Math.hypot(dx,dy);
        const r = (hovered && hovered.dropRef===d) ? leaveR : enterR;
        if (dist < r && dist < bestD){ best=d; bestD=dist; }
      }
    }

    if (best){
      if (!hovered || hovered.dropRef!==best){
        const html = buildEquipTooltipHTML(best.entry || {});
        const el = ensureEquipPopup();
        el.innerHTML = html;
        // t√¥ m√†u vi·ªÅn theo rarity
        const cfg = window.EquipmentDropAPI?.CONFIG || {};
        const rColor = (cfg.RARITY_COLOR && best.entry && cfg.RARITY_COLOR[best.entry.rarity]) || '#60a5fa';
        el.style.borderColor = rColor;
        el.style.boxShadow = `0 8px 24px ${rColor}40`;
        el.style.display='block';
        hovered = { dropRef:best, enterR:24, leaveR:32 };
      }
      placeEquipPopup(lastClientX, lastClientY);
    } else if (hovered){
      hovered=null;
      hideEquipPopup();
    }
  }

  // rAF loop ‚Äî ch·ªâ scan khi c·∫ßn (50ms)
  (function loop(){
    requestAnimationFrame(loop);
    const now = performance.now();
    if (now < nextScanAt) return;
    nextScanAt = now + 50;
    scan();
  })();
})();
/* SunTimeTooltip ‚Äî phi√™n b·∫£n t·ªëi ∆∞u: kh√¥ng ch·∫°y khi ·∫©n, kh√¥ng update th·ª´a */
(function(){
  const canvas = document.getElementById('game')
              || document.getElementById('gameCanvas')
              || document.querySelector('canvas');
  if (!canvas) return;

  let tip, visible = false, rafId = 0, lastText = "";

  function ensureTip(){
    if (tip) return tip;
    tip = document.createElement('div');
    tip.id = 'sunTimeTooltip';
    tip.style.cssText = `
      position:fixed; z-index:10040; padding:6px 8px; border-radius:8px;
      background:rgba(10,12,18,.92); border:1px solid rgba(255,255,255,.12);
      box-shadow:0 8px 24px rgba(0,0,0,.35);
      color:#fff; font:12px/1.35 system-ui,Segoe UI,Roboto;
      pointer-events:none; display:none; white-space:nowrap;`;
    document.body.appendChild(tip);
    return tip;
  }

  function toCanvasSpace(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const sx = canvas.width  / rect.width;
    const sy = canvas.height / rect.height;
    return { x: (clientX - rect.left) * sx, y: (clientY - rect.top) * sy };
  }

  // V·ªã tr√≠ icon m·∫∑t tr·ªùi tr√™n canvas
  const ICON_X = 28, ICON_Y = 82, HIT_R = 18;

  function fmtTime(){
    const total = Math.floor((dayTime * 24 * 3600) % 86400);
    const h = Math.floor(total / 3600);
    const m = Math.floor((total % 3600) / 60);
    const s = total % 60;
    const pad = n => String(n).padStart(2, '0');
    return `${pad(h)}:${pad(m)}:${pad(s)}`;
  }

  function startRAF(){
    if (rafId) return;
    const loop = () => {
      if (!visible) { rafId = 0; return; }
      const t = `Gi·ªù: ${fmtTime()}`;
      if (t !== lastText) { lastText = t; tip.textContent = t; }
      rafId = requestAnimationFrame(loop);
    };
    rafId = requestAnimationFrame(loop);
  }

  function show(clientX, clientY){
    const el = ensureTip();
    lastText = ""; // bu·ªôc vi·∫øt l·∫°i l·∫ßn ƒë·∫ßu
    el.style.display = 'block';
    // ƒë·∫∑t v·ªã tr√≠ c·∫°nh tr·ªè & tr√°nh tr√†n
    const r = el.getBoundingClientRect(), vw = innerWidth, vh = innerHeight;
    let L = clientX + 12, T = clientY + 12;
    if (L + r.width  > vw - 8) L = vw - r.width  - 8;
    if (T + r.height > vh - 8) T = vh - r.height - 8;
    el.style.left = L + 'px';
    el.style.top  = T + 'px';
    visible = true;
    startRAF();
  }

  function hide(){
    if (tip) tip.style.display = 'none';
    visible = false;
  }

  canvas.addEventListener('mousemove', (ev) => {
    const { x, y } = toCanvasSpace(ev.clientX, ev.clientY);
    const dx = x - ICON_X, dy = y - ICON_Y;
    if (dx*dx + dy*dy <= HIT_R*HIT_R) show(ev.clientX, ev.clientY);
    else hide();
  }, { passive: true });

  canvas.addEventListener('mouseleave', hide, { passive: true });
})();

// üåÄ Object Pooling
const bulletPool = [];
const explosionPool = [];
const zombiePool = [];
const swordPool = [];
const fireballPool = [];
const iceballPool = [];

//üì≤ 2. S·ª± ki·ªán ƒëi·ªÅu khi·ªÉn b√†n ph√≠m, chu·ªôt, c·∫£m ·ª©ng
// ‚å®Ô∏è B√†n ph√≠m di chuy·ªÉn
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

// üñ± Click chu·ªôt ƒë·ªÉ b·∫Øn
canvas.addEventListener("click", () => {
    if (window.isPlayerInSafeZone) { e.preventDefault(); return; } // ‚õ≥ ch·∫∑n b·∫Øn trong Safe Zone
  const now = Date.now();
  if (now - lastManualShootTime < manualShootCooldown) return;

  if (zombies.length === 0) return;

  // ‚ú® B∆Ø·ªöC KI·ªÇM TRA ƒê·∫†N M·ªöI ‚ú®
  // N·∫øu l√† lo·∫°i ƒë·∫°n ƒë·∫∑c bi·ªát (kh√¥ng ph·∫£i M·∫∑c ƒë·ªãnh)
  if (clickShotMode !== 5) { 
      if (player.ammo[clickShotMode] <= 0) {
          const modeNames = ["Xo·∫Øn ·ªëc", "Zigzag", "Xo·∫Øn bay th·∫≥ng", "Xuy√™n th·∫≥ng", "Laze"];
          showWarning(`H·∫øt ƒë·∫°n ${modeNames[clickShotMode]}!`);
          return; // D·ª´ng, kh√¥ng cho b·∫Øn
      }
      // N·∫øu c√≤n ƒë·∫°n, tr·ª´ ƒëi 1 vi√™n v√† c·∫≠p nh·∫≠t hi·ªÉn th·ªã
      player.ammo[clickShotMode]--;
      updateAmmoDisplay();
  }

  // N·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô laze, g·ªçi h√†m b·∫Øn laze v√† k·∫øt th√∫c
  if (clickShotMode === 4) {
      firePlayerLaser();
      return;
  }

  // Logic b·∫Øn ƒë·∫°n th∆∞·ªùng (gi·ªØ nguy√™n)
  lastManualShootTime = now; // ƒê·∫∑t l·∫°i cooldown cho ƒë·∫°n th∆∞·ªùng
  const target = zombies.reduce((a, b) =>
    distance(a, player) < distance(b, player) ? a : b
  );

  const angle = Math.atan2(target.y - player.y, target.x - player.x);
  const bullet = getBullet();
  bullet.x = player.x;
  bullet.y = player.y;
  bullet.speed = playerUpgrades.bulletSpeed;
  bullet.active = true;
  bullet.color = "cyan";
  bullet.piercing = true;
  bullet.rotation = 0;

  // ======= Ki·ªÉu b·∫Øn t√πy theo clickShotMode =======
  if (clickShotMode === 0) {
    // üîÑ Xo·∫Øn ·ªëc quanh player
    bullet.curveMode = true;
    bullet.angle = angle;
    bullet.curveRadius = 0;
    bullet.curveSpeed = 0.1 + Math.random() * 0.05;

  } else if (clickShotMode === 1) {
    // ‚ÜîÔ∏è Zigzag
    bullet.zigzagMode = true;
    bullet.baseAngle = angle;
    bullet.oscillatePhase = Math.random() * Math.PI * 2;
    bullet.oscillateSpeed = 0.2;
    bullet.oscillateAmplitude = 20;
    bullet.travel = 0;
    bullet.startX = player.x;
    bullet.startY = player.y;

  } else if (clickShotMode === 2) {
    // üéØ Xo·∫Øn ·ªëc bay th·∫≥ng
    bullet.spiralForwardMode = true;
    bullet.baseAngle = angle;
    bullet.travel = 0;
    bullet.spiralRadius = 15;
    bullet.spiralSpeed = 0.3;
    bullet.spiralPhase = Math.random() * Math.PI * 2;
    bullet.startX = player.x;
    bullet.startY = player.y;

  } else if (clickShotMode === 3) {
    // üéØ Ki·ªÉu 3 ‚Äì Xuy√™n th·∫≥ng
    bullet.dx = Math.cos(angle);
    bullet.dy = Math.sin(angle);
    bullet.piercing = true;

  } else if (clickShotMode === 5) { // Chuy·ªÉn ki·ªÉu m·∫∑c ƒë·ªãnh sang s·ªë 5
    // üîµ Ki·ªÉu 5 ‚Äì Gi·ªëng auto shoot
    bullet.dx = Math.cos(angle);
    bullet.dy = Math.sin(angle);
    bullet.piercing = false; // ‚ùó kh√¥ng xuy√™n
  }
  // ================================================

  bullets.push(bullet);
});
// G√°n s·ª± ki·ªán middle click (chu·ªôt gi·ªØa) ƒë·ªÉ chuy·ªÉn ki·ªÉu b·∫Øn
canvas.addEventListener("mousedown", (e) => {
    if (window.isPlayerInSafeZone) { e.preventDefault(); return; } // ‚õ≥ ch·∫∑n b·∫Øn trong Safe Zone
  if (e.button === 1) {
    clickShotMode = (clickShotMode + 1) % 6;
    const modeNames = [ "üîÑ Xo·∫Øn ·ªëc", "‚ÜîÔ∏è Zigzag", "üéØ Xo·∫Øn bay th·∫≥ng", "üéØ Xuy√™n th·∫≥ng", "üí• Laze", "üîµ M·∫∑c ƒë·ªãnh"];
    
    // L·∫•y s·ªë ƒë·∫°n ƒë·ªÉ hi·ªÉn th·ªã trong th√¥ng b√°o
    let ammoInfo = '';
    if (clickShotMode !== 5) { // N·∫øu kh√¥ng ph·∫£i lo·∫°i M·∫∑c ƒë·ªãnh
        ammoInfo = ` (${player.ammo[clickShotMode]} )`;
    }

    showWarning(`Ki·ªÉu ƒë·∫°n: ${modeNames[clickShotMode]}`);
    
    // C·∫≠p nh·∫≠t hi·ªÉn th·ªã c·ªë ƒë·ªãnh ·ªü g√≥c tr√°i
    updateAmmoDisplay(); 
    
    e.preventDefault();
  }
});

// S·ª≠ d·ª•ng ph√≠m Space ƒë·ªÉ b·∫Øn
document.addEventListener("keydown", e => {
  if (e.code === 'Space') {
  if (window.isPlayerInSafeZone) { e.preventDefault(); return; } // ‚õ≥ ch·∫∑n b·∫Øn trong Safe Zone
  shoot();
  }
});

// üì± ƒêi·ªÅu khi·ªÉn c·∫£m ·ª©ng
canvas.addEventListener("touchstart", e => {
  const touch = e.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
});
canvas.addEventListener("touchmove", e => {
  const touch = e.touches[0];
  touchMoveX = touch.clientX;
  touchMoveY = touch.clientY;
  e.preventDefault(); // ngƒÉn cu·ªôn trang
});
canvas.addEventListener("touchend", () => {
  touchStartX = null;
  touchStartY = null;
  touchMoveX = null;
  touchMoveY = null;
});

// H√†m ti·ªán √≠ch ƒë·ªÉ l·∫•y m·ªôt s·ªë nguy√™n ng·∫´u nhi√™n trong m·ªôt kho·∫£ng
function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
// H√†m d·ªçn d·∫πp c√°c ƒë·ªëi t∆∞·ª£ng kh√¥ng c√≤n ho·∫°t ƒë·ªông
function cleanupInactiveObjects() {
  // D·ªçn d·∫πp zombies
  for (let i = zombies.length - 1; i >= 0; i--) {
    if (!zombies[i].active) {
      zombies.splice(i, 1);
    }
  }

  // D·ªçn d·∫πp ƒë·∫°n ng∆∞·ªùi ch∆°i
  for (let i = bullets.length - 1; i >= 0; i--) {
    if (!bullets[i].active) {
      bullets.splice(i, 1);
    }
  }

  // D·ªçn d·∫πp ƒë·∫°n c·ªßa ƒë·ªãch
  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    if (!enemyBullets[i].active) {
      enemyBullets.splice(i, 1);
    }
  }

  // D·ªçn d·∫πp v·∫≠t ph·∫©m
  for (let i = items.length - 1; i >= 0; i--) {
    if (!items[i].active) {
      items.splice(i, 1);
    }
  }

  // D·ªçn d·∫πp hi·ªáu ·ª©ng n·ªï
  for (let i = explosions.length - 1; i >= 0; i--) {
    if (!explosions[i].active) {
      explosions.splice(i, 1);
    }
  }
}
function updateAmmoDisplay() {
    const display = document.getElementById('ammoDisplay');
    const modeNames = ["üîÑ Xo·∫Øn ·ªëc", "‚ÜîÔ∏è Zigzag", "üéØ Xo·∫Øn bay th·∫≥ng", "üéØ Xuy√™n th·∫≥ng", "üí• Laze", "üîµ M·∫∑c ƒë·ªãnh"];
    
    // N·∫øu l√† ch·∫ø ƒë·ªô m·∫∑c ƒë·ªãnh (v√¥ h·∫°n) ho·∫∑c kh√¥ng c√≥ display th√¨ ·∫©n ƒëi
    if (clickShotMode === 5 || !display) {
        display.style.opacity = '0';
        return;
    }

    const currentAmmo = player.ammo[clickShotMode];
    const ammoText = currentAmmo > 0 ? currentAmmo.toString() : 'H·∫øt ƒë·∫°n!';
    
    display.innerText = `${modeNames[clickShotMode]}: ${ammoText}`;
    display.style.opacity = '1'; // Hi·ªán l√™n
}
/* ===== üèπ ICE ARROW: state & helpers ===== */
let iceArrowRateShopSteps = 0;   // m·ªói l·∫ßn mua +1 step = +0.5x
let iceArrowDamageShop    = 0;   // dmg ri√™ng mua th√™m trong shop
const ICE_ARROW_RATE_STEP = 0.5; // m·ªói l·∫ßn mua +0.5x
const ICE_ARROW_RATE_MAX  = 3;   // max 3x
const ICE_ARROW_DMG_PER_LEVEL = 1; // m·ªói c·∫•p m≈©i t√™n +1 dmg ri√™ng (c√≥ th·ªÉ ch·ªânh)
window.manualShootCooldownBase ??= manualShootCooldown; // l∆∞u cooldown g·ªëc 1x

// T·ªëc ƒë·ªô b·∫Øn ri√™ng c·ªßa Ice Arrow (kh√¥ng ph·ª• thu·ªôc player n·ªØa)
function getIceArrowRate() {
  // t·ªëc ƒë·ªô ch·ªâ tƒÉng t·ª´ shop, base = 1.0
  return Math.min(ICE_ARROW_RATE_MAX, 1 + iceArrowRateShopSteps * ICE_ARROW_RATE_STEP);
}

// Cooldown ri√™ng c·ªßa ph√≠m Space (Ice Arrow)
function getIceArrowCooldown() {
  const r = getIceArrowRate();
  return Math.max(1, Math.round(manualShootCooldownBase / r));
}

// S√°t th∆∞∆°ng c·ªông th√™m ri√™ng cho Ice Arrow (level + shop)
function getIceArrowBonusDamage() {
  // L·∫•y level m≈©i t√™n = iceArrow hi·ªán t·∫°i (c·∫•p 1 coi nh∆∞ bonus 0)
  const lvl = Math.max(0, (playerUpgrades.iceArrow || 1) - 1);
  const fromLevel = lvl * ICE_ARROW_DMG_PER_LEVEL;
  return fromLevel + iceArrowDamageShop;
}
// =================================================================
// --- B·∫ÆT ƒê·∫¶U: H·ªÜ TH·ªêNG L∆ØU GAME, T·∫¢I GAME V√Ä H·ªíI SINH ---
// =================================================================

const SAVE_KEY = 'zombieSurvivorSave';

/**
 * L∆∞u tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa game v√†o localStorage.
 */
function saveGame() {
    if (!gameStarted || player.isDying) return; // Kh√¥ng l∆∞u khi ch∆∞a b·∫Øt ƒë·∫ßu ho·∫∑c ƒëang ch·∫øt
    try {
        const gameState = {
            player: player,
            playerUpgrades: playerUpgrades,
            skillUpgrades: skillUpgrades,
            activeSkills: activeSkills,
            wave: wave,
            currentDay: currentDay,
            dayTime: dayTime,
            shopUpgrades: shopUpgrades,
            iceArrowRateShopSteps: iceArrowRateShopSteps,
            iceArrowDamageShop: iceArrowDamageShop,
            // L∆∞u tr·∫°ng th√°i t·ª´ c√°c module ngo√†i
            Equip: window.Equip,
            CharacterPanelState: window.CharacterPanelState,
        };
        localStorage.setItem(SAVE_KEY, JSON.stringify(gameState));
        console.log("Game Saved!");
    } catch (error) {
        console.error("L·ªói khi l∆∞u game:", error);
    }
}

/**
 * T·∫£i tr·∫°ng th√°i game t·ª´ localStorage.
 * @returns {boolean} Tr·∫£ v·ªÅ true n·∫øu t·∫£i th√†nh c√¥ng, ng∆∞·ª£c l·∫°i l√† false.
 */
function loadGame() {
    try {
        const savedData = localStorage.getItem(SAVE_KEY);
        if (!savedData) return false;

        const gameState = JSON.parse(savedData);

        // Kh√¥i ph·ª•c c√°c ƒë·ªëi t∆∞·ª£ng ch√≠nh
        Object.assign(player, gameState.player);
        Object.assign(playerUpgrades, gameState.playerUpgrades);
        Object.assign(skillUpgrades, gameState.skillUpgrades);
        Object.assign(shopUpgrades, gameState.shopUpgrades);

        // Kh√¥i ph·ª•c c√°c bi·∫øn
        activeSkills.length = 0; // X√≥a m·∫£ng c≈© tr∆∞·ªõc khi push
        gameState.activeSkills.forEach(skill => activeSkills.push(skill));
        wave = gameState.wave;
        currentDay = gameState.currentDay;
        dayTime = gameState.dayTime;
        iceArrowRateShopSteps = gameState.iceArrowRateShopSteps || 0;
        iceArrowDamageShop = gameState.iceArrowDamageShop || 0;
        
// Kh√¥i ph·ª•c module (gi·ªØ reference g·ªëc ƒë·ªÉ m·ªçi n∆°i v·∫´n th·∫•y c√πng m·ªôt object)
if (window.Equip && gameState.Equip) {
  Object.assign(window.Equip, gameState.Equip);
} else {
  // merge saved Equip ƒë·ªÉ gi·ªØ nguy√™n reference & binding
Object.assign(window.Equip, gameState.Equip || {});
window.recalcEquipStats?.();
window.CharacterPanel?.refresh?.();
}

Object.assign(window.CharacterPanelState.spent, (gameState.CharacterPanelState?.spent || {}));
window.CharacterPanelState.baseline = gameState.CharacterPanelState?.baseline ?? null;

        // C·∫≠p nh·∫≠t l·∫°i to√†n b·ªô UI ƒë·ªÉ hi·ªÉn th·ªã ƒë√∫ng d·ªØ li·ªáu ƒë√£ t·∫£i
        updateUI();
        updateStatsOverlay();
        updateSkillsList();
        if (window.CharacterPanel) {
            window.CharacterPanel.refresh();
        }
        recalcEquipStats(); // T√≠nh l·∫°i ch·ªâ s·ªë t·ª´ trang b·ªã
        console.log("Game Loaded!");
        return true;
    } catch (error) {
        console.error("L·ªói khi t·∫£i game:", error);
        localStorage.removeItem(SAVE_KEY); // X√≥a save b·ªã l·ªói
        return false;
    }
}

/**
 * X·ª≠ l√Ω logic khi ng∆∞·ªùi ch∆°i ch·ªçn h·ªìi sinh.
 */
function revivePlayer() {
// 1. Tr·ª´ chi ph√≠
// Tr·ª´ 50% EXP hi·ªán c√≥ v√† th√™m 100 ƒëi·ªÉm c·ªë ƒë·ªãnh
const totalExpLoss = Math.round(player.exp * 0.5) + 100;
player.exp = Math.max(0, player.exp - totalExpLoss);
// Tr·ª´ ƒëi l∆∞·ª£ng EXP ƒë√£ m·∫•t kh·ªèi EXP c·ªßa c·∫•p hi·ªán t·∫°i
player.currentLevelExp = Math.max(0, player.currentLevelExp - totalExpLoss);
// Tr·ª´ 10 xu v√† th√™m 10% c·ªßa s·ªë d∆∞ hi·ªán c√≥
    const fixedCoinLoss = 10;
    const percentCoinLoss = Math.round(player.coins * 0.1);
    const totalCoinLoss = fixedCoinLoss + percentCoinLoss;
    player.coins = player.coins - totalCoinLoss; // Kh√¥ng d√πng Math.max ƒë·ªÉ c√≥ th·ªÉ tr·ª´ √¢m
// Tr·ª´ 10 mana v√† th√™m 10% c·ªßa s·ªë d∆∞ hi·ªán c√≥
player.mana -= 10;
const manaLoss = Math.round(player.mana * 0.1);
player.mana = Math.max(0, player.mana - manaLoss);
// Tr·ª´ 10 energy v√† th√™m 10% c·ªßa s·ªë d∆∞ hi·ªán c√≥
player.energy -= 10;
const energyLoss = Math.round(player.energy * 0.1);
player.energy = Math.max(0, player.energy - energyLoss);
    // 2. ·∫®n panel v√† reset tr·∫°ng th√°i
    document.getElementById('gameOverPanel').classList.remove('visible');
    gameOver = false;
    player.isDying = false;

    // 3. H·ªìi ƒë·∫ßy m√°u v√† t√†i nguy√™n
    player.hearts = player.maxHearts;
    player.stamina = player.staminaMax;

    // 4. D·ªãch chuy·ªÉn ƒë·∫øn 1 trong 5 safe zone ng·∫´u nhi√™n
    const respawnZone = safeZones[Math.floor(Math.random() * safeZones.length)];
    player.x = respawnZone.x;
    player.y = respawnZone.y;
    camera.x = Math.max(0, Math.min(worldWidth - canvas.width, player.x - canvas.width / 2));
    camera.y = Math.max(0, Math.min(worldHeight - canvas.height, player.y - canvas.height / 2));
    // B·ªî SUNG ƒêO·∫†N N√ÄY: K√≠ch ho·∫°t t·∫°m th·ªùi safe zone trong 15s
    respawnZone.tempActiveUntil = Date.now() + 15000;
    respawnZone.active = true; // K√≠ch ho·∫°t ngay l·∫≠p t·ª©c cho frame hi·ªán t·∫°i

    // 5. D·ªçn d·∫πp m√†n ch∆°i ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i wave
    zombies.length = 0;
    bullets.length = 0;
    enemyBullets.length = 0;
    items.length = 0;
    explosions.length = 0;
    // ... th√™m c√°c m·∫£ng object kh√°c n·∫øu c√≥ ...

    // 6. Reset l·∫°i wave timer v√† b·∫Øt ƒë·∫ßu l·∫°i wave
    lastWaveTime = Date.now();
    waveTimer = waveTime;
    
    playRandomNormalMusic(); // B·∫≠t l·∫°i nh·∫°c n·ªÅn
    saveGame(); // L∆∞u l·∫°i tr·∫°ng th√°i ngay sau khi h·ªìi sinh
    showWarning("ƒê√£ h·ªìi sinh! Ti·∫øp t·ª•c chi·∫øn ƒë·∫•u.");
}

/**
 * B·∫Øt ƒë·∫ßu game t·ª´ d·ªØ li·ªáu ƒë√£ l∆∞u.
 */
function continueGame() {
    if (loadGame()) {
        document.getElementById('startMenu').style.display = 'none';
        gameStarted = true;
        isPaused = false;
        lastWaveTime = Date.now(); // B·∫Øt ƒë·∫ßu ƒë·∫øm gi·ªù cho wave
        playRandomNormalMusic();
    } else {
        showWarning("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ƒë√£ l∆∞u ho·∫∑c d·ªØ li·ªáu b·ªã l·ªói.");
    }
}

// =================================================================
// --- K·∫æT TH√öC: H·ªÜ TH·ªêNG L∆ØU GAME, T·∫¢I GAME V√Ä H·ªíI SINH ---
// =================================================================
//üí• 3. H√†m h·ªó tr·ª£ ti·ªán √≠ch
/**
 * TH√äM M·ªöI: H√†m c·∫≠p nh·∫≠t logic h·ªìi m√°u t·ª± ƒë·ªông cho player.
 * H√†m n√†y ƒë∆∞·ª£c g·ªçi m·ªói frame t·ª´ v√≤ng l·∫∑p ch√≠nh (update).
 * @param {number} now - Th·ªùi gian hi·ªán t·∫°i (timestamp) t·ª´ Date.now().
 */
/**
 * C·∫≠p nh·∫≠t logic h·ªìi m√°u t·ª± ƒë·ªông cho player, ƒë√£ bao g·ªìm bonus t·ª´ trang b·ªã.
 * @param {number} now - Th·ªùi gian hi·ªán t·∫°i (timestamp).
 */
function updatePlayerRegen(now) {
    // Ch·ªâ th·ª±c hi·ªán khi game ƒë√£ b·∫Øt ƒë·∫ßu v√† m·ªëc th·ªùi gian ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o
    if (!gameStarted || !lastHpRegenTime) {
        lastHpRegenTime = now; // Kh·ªüi t·∫°o m·ªëc th·ªùi gian l·∫ßn ƒë·∫ßu
        return;
    }

    // Ki·ªÉm tra xem ƒë√£ ƒë·ªß th·ªùi gian ch·ªù hay ch∆∞a
    if (now - lastHpRegenTime >= HP_REGEN) {
        // T√≠nh t·ªïng l∆∞·ª£ng m√°u s·∫Ω h·ªìi = G·ªëc + Trang b·ªã
        // (player.equipHpRegen || 0) ƒë·∫£m b·∫£o code kh√¥ng b·ªã l·ªói n·∫øu ch∆∞a c√≥ trang b·ªã
        let totalHealAmount = HP_REGEN_VALUE + (player.equipHpRegen || 0);

        // L√†m tr√≤n t·ªïng l∆∞·ª£ng m√°u h·ªìi v·ªÅ 2 ch·ªØ s·ªë th·∫≠p ph√¢n
        totalHealAmount = parseFloat(totalHealAmount.toFixed(2));

        // Ch·ªâ h·ªìi m√°u n·∫øu HP ch∆∞a ƒë·∫ßy v√† c√≥ l∆∞·ª£ng m√°u ƒë·ªÉ h·ªìi
        if (player.hearts < player.maxHearts && totalHealAmount > 0) {
            // H·ªìi m√°u v√† ƒë·∫£m b·∫£o kh√¥ng v∆∞·ª£t qu√° gi·ªõi h·∫°n
            player.hearts = Math.min(player.maxHearts, Math.round(player.hearts + totalHealAmount));
            createHealImpactEffect(player, totalHealAmount); // Hi·ªÉn th·ªã hi·ªáu ·ª©ng
        }
        // ƒê·∫∑t l·∫°i m·ªëc th·ªùi gian cho l·∫ßn h·ªìi m√°u ti·∫øp theo
        lastHpRegenTime = now;
    }
}
/**
 * C·∫≠p nh·∫≠t logic h·ªìi stamina t·ª± ƒë·ªông cho player, ƒë√£ bao g·ªìm bonus t·ª´ trang b·ªã.
 * @param {number} now - Th·ªùi gian hi·ªán t·∫°i (timestamp).
 */
function updatePlayerStaminaRegen(now) {
    if (!gameStarted || !lastStaminaRegenTime) {
        lastStaminaRegenTime = now; // Kh·ªüi t·∫°o m·ªëc th·ªùi gian
        return;
    }
    // Ki·ªÉm tra xem ƒë√£ ƒë·ªß th·ªùi gian ch·ªù hay ch∆∞a
    if (now - lastStaminaRegenTime >= STAMINA_REGEN_INTERVAL) {
        // T√≠nh t·ªïng l∆∞·ª£ng stamina s·∫Ω h·ªìi = G·ªëc + Trang b·ªã
        const totalStaminaAmount = STAMINA_REGEN_VALUE + (player.equipSpRegen || 0);
        // Ch·ªâ h·ªìi n·∫øu stamina ch∆∞a ƒë·∫ßy v√† c√≥ l∆∞·ª£ng stamina ƒë·ªÉ h·ªìi
        if (player.stamina < player.staminaMax && totalStaminaAmount > 0) {
            player.stamina = Math.min(player.staminaMax, player.stamina + totalStaminaAmount);
        }
        // ƒê·∫∑t l·∫°i m·ªëc th·ªùi gian cho l·∫ßn h·ªìi ti·∫øp theo
        lastStaminaRegenTime = now; 
    }
}
// H√†m t√≠nh kho·∫£ng c√°ch gi·ªØa hai ƒëi·ªÉm
function distance(a, b) {
return Math.hypot(a.x - b.x, a.y - b.y);}

function distanceSq(a, b) {
    return (a.x - b.x)**2 + (a.y - b.y)**2;
}
function createFairyHitParticle(targetZombie) {
    particles.push({
        type: 'fairy_status_effect', // Lo·∫°i h·∫°t m·ªõi
        target: targetZombie,       // "D√≠nh" v√†o m·ª•c ti√™u n√†y
        life: 180,                   // T·ªìn t·∫°i trong 1.5 gi√¢y (60fps * 1.5)
        maxLife: 180,
        angle: Math.random() * Math.PI * 2, // G√≥c xoay ban ƒë·∫ßu
        orbitRadius: targetZombie.radius + 5 + Math.random() * 5, // Kho·∫£ng c√°ch xoay
        size: 0.5 + Math.random() * 1,                 // K√≠ch th∆∞·ªõc h·∫°t
        color: 'rgba(100, 255, 150, 0.8)'   // M√†u xanh l√° c√¢y b·∫°c h√†

    });
}
// H√†m n√†y s·∫Ω quy·∫øt ƒë·ªãnh v·∫≠t ph·∫©m n√†o s·∫Ω r∆°i d·ª±a tr√™n t·ªâ l·ªá
function determineItemDrop() {
    const itemRand = Math.random(); // T·∫°o s·ªë ng·∫´u nhi√™n t·ª´ 0 ƒë·∫øn 1
    let cumulativeChance = 0;

    // Duy·ªát qua t·ª´ng v·∫≠t ph·∫©m trong b·∫£ng t·ªâ l·ªá r∆°i - itemDropTable, thay testDropTable n·∫øu test
    for (const item of itemDropTable) {
        cumulativeChance += item.chance;
        // N·∫øu s·ªë ng·∫´u nhi√™n nh·ªè h∆°n t·ªâ l·ªá c·ªông d·ªìn, ch√∫ng ta ch·ªçn v·∫≠t ph·∫©m n√†y
        if (itemRand < cumulativeChance) {
            return item.type;
        }
    }
    // N·∫øu kh√¥ng tr√∫ng v·∫≠t ph·∫©m n√†o trong b·∫£ng, m·∫∑c ƒë·ªãnh s·∫Ω l√† 'energy'
    return 'energy';
}
// T·∫°o hi·ªáu ·ª©ng c·ªïng d·ªãch chuy·ªÉn
function createSpawnEffect(x, y) {
    playSound('sfx-nuke-fall', 0.5); // T·∫°m d√πng √¢m thanh bom r∆°i ƒë·ªÉ c·∫£nh b√°o
    // T·∫°o 30 h·∫°t bay ra t·ª´ t√¢m theo h√¨nh tr√≤n
    for (let i = 0; i < 30; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 2;
        particles.push({
            x: x, y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 2 + 1,
            color: 'rgba(139, 0, 139, 0.8)', // M√†u t√≠m ƒë·∫≠m
            alpha: 1,
            fastFade: true
        });
    }
}
/**
 * T·∫°o m·ªôt v·ª• n·ªï b·∫±ng c√°c h·∫°t (particle) t·∫°i m·ªôt v·ªã tr√≠.
 * @param {number} x T·ªça ƒë·ªô X c·ªßa v·ª• n·ªï.
 * @param {number} y T·ªça ƒë·ªô Y c·ªßa v·ª• n·ªï.
 * @param {number} count S·ªë l∆∞·ª£ng h·∫°t.
 * @param {string} baseColor M√†u c∆° b·∫£n c·ªßa v·ª• n·ªï (v√≠ d·ª•: 'orange', 'cyan').
 */
function createParticleExplosion(x, y, count, colorScheme = 'fire') {
    let colors;
    let maxDist = 60; // B√°n k√≠nh m·∫∑c ƒë·ªãnh

    // Ch·ªçn b·ªô m√†u v√† b√°n k√≠nh d·ª±a tr√™n y√™u c·∫ßu
    if (colorScheme === 'fire') {
        colors = [
            'rgba(255, 255, 255, 0.9)', // Tr·∫Øng
            'rgba(255, 220, 0, 0.8)',   // V√†ng
            'rgba(255, 150, 0, 0.8)',   // Cam
            'rgba(255, 50, 0, 0.7)'     // ƒê·ªè
        ];
        maxDist = 60; // B√°n k√≠nh n·ªï c·ªßa t√™n l·ª≠a
    } else if (colorScheme === 'smoke') {
        colors = [
            'rgba(200, 200, 200, 0.7)', // X√°m s√°ng
            'rgba(150, 150, 150, 0.6)', // X√°m v·ª´a
            'rgba(100, 100, 100, 0.5)'  // X√°m t·ªëi
        ];
        maxDist = 80; // B√°n k√≠nh c·ªßa bom kh√≥i
    }

    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 2;

        const color = colors[Math.floor(Math.random() * colors.length)];

        particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 1 + 2,
            color: color,
            alpha: 1,
            fastFade: true,
            originX: x,
            originY: y,
            maxDistance: maxDist
        });
    }
}

/**
 * T·∫°o m·ªôt ƒë·ªëi t∆∞·ª£ng hi·ªáu ·ª©ng dying v√† th√™m v√†o m·∫£ng healEffects.
 */
function spawnDyingEffect(z) {
    healEffects.push({
        x: z.x,
        y: z.y - z.radius,
        life: 60,
        maxLife: 60,
        text: '‚ò†Ô∏è',
        delay: 0  // No delay for death effect
    });
}
// V·∫Ω c√°c hi·ªáu ·ª©ng h·ªìi m√°u
function updateAndDrawHealEffects() {
    ctx.font = "0.8rem sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    for (let i = healEffects.length - 1; i >= 0; i--) {
        const effect = healEffects[i];

        // Lu√¥n gi·∫£m life m·ªói frame ƒë·ªÉ hi·ªáu ·ª©ng bi·∫øt khi n√†o c·∫ßn bi·∫øn m·∫•t
        effect.life--;

        // N·∫øu c√≤n delay, ch·ªâ ƒë·ª©ng y√™n t·∫°i ch·ªó
        if (effect.delay > 0) {
            effect.delay--;
        } else {
            // H·∫øt delay th√¨ m·ªõi b·∫Øt ƒë·∫ßu bay l√™n
            effect.y -= 0.5;
        }

        // S·ª≠ d·ª•ng m√†u t·ª´ hi·ªáu ·ª©ng, n·∫øu kh√¥ng c√≥ th√¨ m·∫∑c ƒë·ªãnh l√† m√†u tr·∫Øng
        ctx.fillStyle = effect.color || "white";
        ctx.globalAlpha = effect.life / effect.maxLife;
        
        // V·∫Ω ƒë√∫ng icon (text) c·ªßa hi·ªáu ·ª©ng
        ctx.fillText(effect.text, effect.x, effect.y);

        // X√≥a hi·ªáu ·ª©ng khi life <= 0
        if (effect.life <= 0) {
            healEffects.splice(i, 1);
        }
    }
    
    ctx.globalAlpha = 1; // Reset ƒë·ªô m·ªù
}

// üéÅ Qu·∫£n l√Ω vi·ªác r∆°i v·∫≠t ph·∫©m khi m·ªôt zombie b·ªã ti√™u di·ªát.
function dropItem(x, y, isBoss = false, isBigBoss = false, isMiniBoss = false, isElite = false) {
  
    let finalDropCount = 0;
    const isLuckyActive = Date.now() < luckyBuffEndTime;

    // 1. X√°c ƒë·ªãnh S·ªê L∆Ø·ª¢NG v·∫≠t ph·∫©m s·∫Ω r∆°i (logic g·ªëc c·ªßa b·∫°n, gi·ªØ nguy√™n)
    if (isBigBoss) {
        // BigBoss r∆°i ng·∫´u nhi√™n t·ª´ 5 ƒë·∫øn 10 v·∫≠t ph·∫©m
        finalDropCount = getRandomInt(5, 10);
    } else if (isBoss) {
        // Boss r∆°i ng·∫´u nhi√™n t·ª´ 3 ƒë·∫øn 5 v·∫≠t ph·∫©m
        finalDropCount = getRandomInt(3, 5);
    } else if (isMiniBoss) {
        // MiniBoss r∆°i ng·∫´u nhi√™n t·ª´ 2 ƒë·∫øn 3 v·∫≠t ph·∫©m
        finalDropCount = getRandomInt(2, 3);
    } else if (isElite) {
        // Elite r∆°i ng·∫´u nhi√™n t·ª´ 1 ƒë·∫øn 2 v·∫≠t ph·∫©m
        finalDropCount = getRandomInt(1, 2);
    } else {
        let dropChance = 0.1; // T·ªâ l·ªá r∆°i v·∫≠t ph·∫©m c∆° b·∫£n 10%
        if (isLuckyActive) {
            dropChance = 0.2; // TƒÉng t·ªâ l·ªá r∆°i v·∫≠t ph·∫©m khi c√≥ buff Lucky
        }
        if (Math.random() < dropChance) {
            finalDropCount = 1;
        }
    }

    // N·∫øu c√≥ buff Lucky, nh√¢n ƒë√¥i s·ªë l∆∞·ª£ng v·∫≠t ph·∫©m r∆°i ra
    if (isLuckyActive) {
        finalDropCount *= 2;
    }
    // N·∫øu kh√¥ng c√≥ v·∫≠t ph·∫©m n√†o r∆°i ra, k·∫øt th√∫c h√†m
    if (finalDropCount === 0) {
        return;
    }

    // 2. V√≤ng l·∫∑p ƒë·ªÉ t·∫°o ra t·ª´ng v·∫≠t ph·∫©m
    for (let i = 0; i < finalDropCount; i++) {
        const offsetX = (Math.random() - 0.5) * 30;
        const offsetY = (Math.random() - 0.5) * 30;
        const safeX = Math.min(worldWidth - wallThickness - 20, Math.max(wallThickness + 20, x + offsetX));
        const safeY = Math.min(worldHeight - wallThickness - 20, Math.max(wallThickness + 20, y + offsetY));
        // 3. G·ªçi h√†m m·ªõi ƒë·ªÉ quy·∫øt ƒë·ªãnh LO·∫†I v·∫≠t ph·∫©m s·∫Ω r∆°i ra.
        const type = determineItemDrop();
        // 4. Th√™m v·∫≠t ph·∫©m v√†o game
        if (type) {
            items.push({ 
                x: safeX, 
                y: safeY, 
                type: type, 
                active: true, 
                bornAt: Date.now() // S·ª≠ d·ª•ng 'bornAt' ƒë·ªÉ t∆∞∆°ng th√≠ch logic t·ª± x√≥a
            });
        }
    }
}

// üì¶ Khi ng∆∞·ªùi ch∆°i nh·∫∑t h·ªôp v·∫≠t ph·∫©m ƒë·∫∑c bi·ªát
function openItemBox() {
  const rewardCount = Math.floor(Math.random() * 3) + 1; // Nh·∫≠n 1‚Äì3 lo·∫°i ng·∫´u nhi√™n
  const rewards = [
    { type: 'energy', label: '‚ö° Energy', icon: '‚ö°' },
    { type: 'mana', label: 'üí† Mana', icon: 'üí†' },
    { type: 'hp', label: '‚ù§Ô∏è HP', icon: '‚ù§Ô∏è' }
  ];

  const shuffled = rewards.sort(() => Math.random() - 0.5);
  const selected = shuffled.slice(0, rewardCount);
  const summary = [];

  selected.forEach(r => {
    const amount = Math.floor(Math.random() * 5) + 3; // Nh·∫≠n 3‚Äì7 m·ªói lo·∫°i
    switch (r.type) {
      case 'energy': player.energy += amount; break;
      case 'mana': player.mana += amount; break;
      case 'hp': player.hearts = Math.min(player.maxHearts, player.hearts + amount); break;
    }
    summary.push(`${r.icon} +${amount}`);
  });

  // üì¢ G·ªôp th√†nh m·ªôt d√≤ng th√¥ng b√°o duy nh·∫•t
  showWarning(`üì¶ H·ªôp v·∫≠t ph·∫©m: ${summary.join(', ')}`);
}
// H√†m x·ª≠ l√Ω khi nh·∫∑t v·∫≠t ph·∫©m Secret (phi√™n b·∫£n ƒë√£ c·∫≠p nh·∫≠t t·ªâ l·ªá)
function activateSecretItem(item) {
  if (!item) return;

  const r = Math.random(); // 0..1

  // 1) 30% Buff (6 nh√°nh, m·ªói nh√°nh 5%)
  if (r < 0.30) {
    if (r < 0.05) {
      luckyBuffEndTime = Date.now() + 45000;
      showWarning("‚ùì: Nh·∫≠n ƒë∆∞·ª£c buff LUCKY!");
    } else if (r < 0.10) {
      powerBuffEndTime = Date.now() + 45000;
      showWarning("‚ùì: Nh·∫≠n ƒë∆∞·ª£c buff POWER!");
    } else if (r < 0.15) {
      crazyBuffEndTime = Date.now() + 45000;
      showWarning("‚ùì: Nh·∫≠n ƒë∆∞·ª£c buff CRAZY!");
    } else if (r < 0.20) {
      expBuffEndTime = Date.now() + 45000;
      showWarning("‚ùì: Nh·∫≠n ƒë∆∞·ª£c buff EXP!");
    } else if (r < 0.25) {
      // 5%: Crit Rate
      if (typeof addCritRateBuff === 'function') {
        addCritRateBuff(0.15, 45000); // +15% trong 45s (tu·ª≥ ch·ªânh n·∫øu c·∫ßn)
      }
      showWarning("‚ùì: Crit Rate +15%");
    } else {
      // 5%: Crit Dmg
      if (typeof addCritDmgBuff === 'function') {
        addCritDmgBuff(0.25, 45000); // +25% trong 45s (tu·ª≥ ch·ªânh n·∫øu c·∫ßn)
      }
      showWarning("‚ùì: Crit Dmg +25%");
    }
  }

  // 2) 30%: Coin ho·∫∑c EXP (50/50)
  else if (r < 0.60) {
    if (Math.random() < 0.5) {
      const coinBonus = Math.round((wave + player.level) * (Math.random() * 3 + 2)); // 2‚Äì5 l·∫ßn (wave + level)
      player.coins += coinBonus;
      showWarning(`‚ùì: Nh·∫≠n ƒë∆∞·ª£c ${coinBonus} ü™ô!`);
    } else {
      activateExpBonusItem();
    }
  }

  // 3) 30%: Elite Pack (10%) / Mini Boss (10%) / Boss (10%)
  else if (r < 0.90) {
    showWarning("Oh! No");
    createSpawnEffect(item.x, item.y);
    setTimeout(() => {
      if (r < 0.70) {           // 0.60‚Äì0.70 ‚Üí 10% Elite Pack
        const cnt = 2 + ((Math.random() * 3) | 0); // 2‚Äì4 con
        showWarning(`‚ùó: ${cnt} Zombie tinh anh!`);
        spawnElitePackAt(item.x, item.y, cnt);
      } else if (r < 0.80) {    // 0.70‚Äì0.80 ‚Üí 10% Mini Boss
        showWarning("‚ùó: Mini Boss!");
        spawnMiniBossAt(item.x, item.y);
      } else {                  // 0.80‚Äì0.90 ‚Üí 10% Boss
        showWarning("‚ùó: Boss!");
        spawnBoss(item.x, item.y);
      }
    }, 500);
  }

  // 4) 10%: m·ªü Box
  else {
    showWarning("Nh·∫≠n ƒë∆∞·ª£c H·ªôp v·∫≠t ph·∫©m!");
    openItemBox(); 
  }
}

// H√†m x·ª≠ l√Ω khi nh·∫∑t v·∫≠t ph·∫©m ExpBonus
function activateExpBonusItem() {
    // L∆∞·ª£ng EXP th∆∞·ªüng = (wave + level) * (m·ªôt s·ªë ng·∫´u nhi√™n t·ª´ 5 ƒë·∫øn 10)
    const bonus = Math.round((wave + player.level) * (Math.random() * 5 + 5));
    player.exp += bonus;
    player.currentLevelExp += bonus;
    createExpGainEffect({x: player.x, y: player.y, radius: 20}, bonus);
    showWarning(`üåü Th∆∞·ªüng: +${bonus} EXP!`);
}
// üîÅ Bullet Pooling
function getBullet() {
  return bulletPool.length ? bulletPool.pop() : { x: 0, y: 0, dx: 0, dy: 0, active: true };
}
function releaseBullet(bullet) {
    bullet.active = false;
    
    // ‚ú® B·∫ÆT ƒê·∫¶U PH·∫¶N RESET TO√ÄN B·ªò THU·ªòC T√çNH ƒê·∫∂C BI·ªÜT ‚ú®
    delete bullet.isFairyBullet; // X√≥a c·ªù c·ªßa ƒë·∫°n Fairy
    delete bullet.isPetBullet; 
    delete bullet.icon;        
    delete bullet.stunDuration;
    delete bullet.customDmg;     // X√≥a s√°t th∆∞∆°ng ri√™ng c·ªßa Clone
    delete bullet.color;         // X√≥a m√†u t√πy ch·ªânh
    delete bullet.effect;        // X√≥a hi·ªáu ·ª©ng c·ªßa ƒë·∫°n Fairy
    delete bullet.isIceArrow;
    delete bullet.iceHits;  
    bullet.piercing = false;     // Reset thu·ªôc t√≠nh xuy√™n th·∫•u v·ªÅ m·∫∑c ƒë·ªãnh
    
    // Reset c√°c ki·ªÉu bay ƒë·∫∑c bi·ªát
    bullet.curveMode = false;
    bullet.zigzagMode = false;
    bullet.spiralForwardMode = false;
    // ‚ú® K·∫æT TH√öC PH·∫¶N RESET ‚ú®

    bulletPool.push(bullet);
}

// üí• Explosion Pooling
function getExplosion(x, y) {
  const e = explosionPool.length ? explosionPool.pop() : { x: 0, y: 0, radius: 0, life: 0, active: true };
  e.x = x;
  e.y = y;
  e.radius = 0;
  e.life = 20;
  e.active = true;
  return e;
}
function releaseExplosion(e) {
  e.active = false;
  explosionPool.push(e);
}

// üí• B·∫Øn ƒë·∫°n t·ª´ zombie v·ªÅ ph√≠a player - shootEnemyBullet pooling
function shootEnemyBullet(z, speed = 0.6, chance = 1) { // Nh·∫≠n c·∫£ ƒë·ªëi t∆∞·ª£ng zombie 'z'
    if (Math.random() > chance) return;

    const angle = Math.atan2(player.y - z.y, player.x - z.x);
    const b = getEnemyBullet();
    b.x = z.x;
    b.y = z.y;
    b.dx = Math.cos(angle);
    b.dy = Math.sin(angle);
    b.speed = speed;
    b.damage = calculateZombieDamage(z); // ‚ú® T√≠nh v√† l∆∞u s√°t th∆∞∆°ng v√†o ƒë·∫°n
    b.hit = false;
    b.active = true;

    enemyBullets.push(b);
}

// object pooling cho enemyBullets
const enemyBulletPool = [];

function getEnemyBullet() {
  return enemyBulletPool.length
    ? enemyBulletPool.pop()
    : { x: 0, y: 0, dx: 0, dy: 0, speed: 1, hit: false, active: true };
}

function releaseEnemyBullet(b) {
  b.hit = false;
  b.active = false;
  enemyBulletPool.push(b);
}

// üßü Zombie Pooling
function getZombie() {
    let z = zombiePool.length ? zombiePool.pop() : {
        x: 0, y: 0, radius: 15, canHit: true, speed: 1,
        color: "hotpink", isBoss: false, isBigBoss: false,
        hp: 1, active: true, type: "normal", level: 1
    };

    // Reset l·∫°i to√†n b·ªô khi l·∫•y t·ª´ pool
    z.active = true;
    z._killed = false;
    z.isBoss = false;
    z.isBigBoss = false;
    z.type = "normal";
    z.color = "hotpink";
    z.radius = 15;
    z.hp = 1;
    z.level = 1;
    z.baseSpeed = 0.1 + Math.random() * 0.1;
    z.speed = z.baseSpeed;
    z.canHit = true;
    return z;
}

function releaseZombie(z) {
  z.active = false;
  z.state = undefined;   
  zombiePool.push(z);
}
// üí• H√†m ti√™u di·ªát zombie, d√πng chung cho m·ªçi k·ªπ nƒÉng
function killZombie(z) {
  // --- B∆Ø·ªöC 1: X·ª¨ L√ù BAN ƒê·∫¶U ---

  // N·∫øu zombie ƒë√£ b·ªã x·ª≠ l√Ω r·ªìi ho·∫∑c kh√¥ng ho·∫°t ƒë·ªông, b·ªè qua ƒë·ªÉ tr√°nh l·ªói
  if (z._killed || !z.active) return;
  z._killed = true; // ƒê√°nh d·∫•u l√† ƒë√£ x·ª≠ l√Ω ƒë·ªÉ kh√¥ng g·ªçi l·∫°i h√†m n√†y tr√™n c√πng 1 zombie

  // Ph√°t √¢m thanh v√† hi·ªáu ·ª©ng h√¨nh ·∫£nh
  playSound('sfx-zombie-die', 0.3);
  spawnDyingEffect(z);

  // Tr·∫£ ƒë·ªëi t∆∞·ª£ng zombie v·ªÅ "kho" (object pool) ƒë·ªÉ t√°i s·ª≠ d·ª•ng, t·ªëi ∆∞u hi·ªáu nƒÉng
  releaseZombie(z);
  
  // --- B∆Ø·ªöC 2: C·∫¨P NH·∫¨T ƒêI·ªÇM S·ªê ---

  // Lu√¥n c·ªông 1 v√†o 'score' ƒë·ªÉ ƒë·∫øm kill v√† t√≠nh high score
  player.score++;
  zombieKillCount = player.score;

  // --- B∆Ø·ªöC 3: T√çNH TO√ÅN EXP (LOGIC HO√ÄN CH·ªàNH) ---

  let expBaseCalculated = 0; // Bi·∫øn t·∫°m ƒë·ªÉ l∆∞u EXP g·ªëc tr∆∞·ªõc khi th√™m y·∫øu t·ªë ng·∫´u nhi√™n

  // 3.1. T√≠nh EXP g·ªëc cho t·ª´ng lo·∫°i zombie
  if (z.isBigBoss) {
    // ƒê·ªëi v·ªõi c√°c lo·∫°i boss, g·ªçi h√†m t√≠nh EXP tƒÉng ti·∫øn ri√™ng
    expBaseCalculated = calculateScaledBossExp(1000, wave);
  } else if (z.isBoss) {
    expBaseCalculated = calculateScaledBossExp(100, wave);
  } else if (z.type === "miniBoss") {
    // S·ª≠ d·ª•ng EXP c∆° b·∫£n l√† 50 ƒë√£ s·ª≠a
    expBaseCalculated = calculateScaledBossExp(10, wave);
  } else {
    // Logic cho zombie th∆∞·ªùng v√† Elite
    const base = z.isElite ? 5 : 1;
    const levelBonus = z.level - 1;
    const waveBonus = wave - 1; // Th∆∞·ªüng theo wave ch·ªâ √°p d·ª•ng cho zombie th∆∞·ªùng/elite
    expBaseCalculated = base + levelBonus + waveBonus;
  }

  // 3.2. Th√™m y·∫øu t·ªë ng·∫´u nhi√™n +/- 10%
  // C√¥ng th·ª©c: gi√° tr·ªã * (1 + (s·ªë ng·∫´u nhi√™n t·ª´ -0.1 ƒë·∫øn +0.1))
  const randomFactor = 1 + (Math.random() * 0.2 - 0.1); 
  let expGained = expBaseCalculated * randomFactor;

  // 3.3. L√†m tr√≤n k·∫øt qu·∫£ v√† ƒë·∫£m b·∫£o EXP nh·∫≠n ƒë∆∞·ª£c lu√¥n √≠t nh·∫•t l√† 1
  expGained = Math.max(1, Math.round(expGained));

  // 3.4. √Åp d·ª•ng c√°c buff kh√°c n·∫øu c√≥ (v√≠ d·ª•: buff x1.5 EXP)
  if (Date.now() < expBuffEndTime) { // n·∫øu ƒëang c√≥ buff EXP
    expGained = Math.round(expGained * 1.5);// tƒÉng 50%
  }
  
  // 3.5. C·ªông EXP v√†o cho ng∆∞·ªùi ch∆°i
  player.exp += expGained;
  player.currentLevelExp += expGained;
  createExpGainEffect(z, expGained);

  // --- B∆Ø·ªöC 4: C·∫¨P NH·∫¨T TH·ªêNG K√ä V√Ä R∆†I V·∫¨T PH·∫®M ---

  // C·∫≠p nh·∫≠t th·ªëng k√™ s·ªë l∆∞·ª£ng zombie ƒë√£ di·ªát theo t·ª´ng lo·∫°i
  if (z.level && z.level >= 1 && z.level <= 10) {
    zombieByLevel[z.level] = (zombieByLevel[z.level] || 0) + 1;
  }
  if (z.type === "miniBoss") {
    zombieByLevel.miniBoss = (zombieByLevel.miniBoss || 0) + 1;
  }
  if (z.isBoss && !z.isBigBoss) {
    zombieByLevel.boss = (zombieByLevel.boss || 0) + 1;
  }
  if (z.isBigBoss) {
    zombieByLevel.bigBoss = (zombieByLevel.bigBoss || 0) + 1;
  }
  
  // G·ªçi h√†m ƒë·ªÉ x·ª≠ l√Ω vi·ªác r∆°i v·∫≠t ph·∫©m
  dropItem(z.x, z.y, z.isBoss, z.isBigBoss, z.type === "miniBoss", z.isElite);
}
/**
 * T√≠nh to√°n l∆∞·ª£ng EXP y√™u c·∫ßu ƒë·ªÉ ƒë·∫°t ƒë∆∞·ª£c c·∫•p ƒë·ªô ti·∫øp theo.
 * @param {number} level - C·∫•p ƒë·ªô hi·ªán t·∫°i c·ªßa ng∆∞·ªùi ch∆°i.
 * @returns {number} S·ªë EXP c·∫ßn thi·∫øt ƒë·ªÉ l√™n c·∫•p.
 */
function calculateRequiredExp(level) {
    // --- B·∫†N C√ì TH·ªÇ T√ôY CH·ªàNH C√ÅC THAM S·ªê N√ÄY ---
    // H·ªá s·ªë gia tƒÉng. Con s·ªë n√†y c√†ng l·ªõn, c√°c c·∫•p ƒë·ªô sau c√†ng kh√≥.
    // 1.5 l√† m·ªôt kh·ªüi ƒë·∫ßu t·ªët, b·∫°n c√≥ th·ªÉ th·ª≠ 1.6, 1.7... ƒë·ªÉ l√†m game kh√≥ h∆°n.
    const exponent = 1.5;
    // C√¥ng th·ª©c t√≠nh: BaseEXP * (Level ^ Exponent)
    // Math.floor d√πng ƒë·ªÉ l√†m tr√≤n xu·ªëng, cho ra m·ªôt con s·ªë ƒë·∫πp.
    return Math.floor(INITIAL_REQUIRED_EXP * Math.pow(level, exponent));
}
function calculateScaledBossExp(baseExp, currentWave) {
  // --- B·∫†N C√ì TH·ªÇ T√ôY CH·ªàNH H·ªÜ S·ªê C√ÇN B·∫∞NG T·∫†I ƒê√ÇY ---

  // M·ªói wave s·∫Ω c·ªông th√™m bao nhi√™u EXP cho boss.
  // V√≠ d·ª•: 10 nghƒ©a l√† ·ªü wave 10, boss s·∫Ω ƒë∆∞·ª£c c·ªông th√™m 90 EXP.
  const SCALING_FACTOR_PER_WAVE = 10;

  // ---------------------------------------------------

  // L∆∞·ª£ng EXP th∆∞·ªüng ƒë∆∞·ª£c t√≠nh t·ª´ wave th·ª© 2 tr·ªü ƒëi.
  // (currentWave - 1) ƒë·ªÉ ƒë·∫£m b·∫£o wave 1 kh√¥ng c√≥ th∆∞·ªüng.
  const waveBonus = Math.max(0, (currentWave - 1) * SCALING_FACTOR_PER_WAVE);

  // Tr·∫£ v·ªÅ t·ªïng EXP c∆° b·∫£n c·ªông v·ªõi ph·∫ßn th∆∞·ªüng, l√†m tr√≤n cho s·ªë ƒë·∫πp.
  return Math.round(baseExp + waveBonus);
}

/**
 * T√≠nh to√°n s√°t th∆∞∆°ng c·ªßa zombie d·ª±a tr√™n lo·∫°i, wave v√† level ng∆∞·ªùi ch∆°i.
 * @param {object} z - ƒê·ªëi t∆∞·ª£ng zombie.
 * @returns {number} S√°t th∆∞∆°ng cu·ªëi c√πng (t·ªëi thi·ªÉu l√† 1).
 */
function calculateZombieDamage(z) {
  // --- 1) Base g·ªëc theo lo·∫°i ---
  let baseDamage = 1;
  if (z.isBigBoss) baseDamage = 5;
  else if (z.isBoss) baseDamage = 3;
  else if (z.type === 'miniBoss' || z.type === 'mini_boss') baseDamage = 2;

  const damageFromWave = Math.max(0, (window.wave|0) - 1);
  const damageFromPlayerLevel = Math.max(0, (window.player?.level|0) - 1);

  // T·ªïng c∆° b·∫£n
  let totalDamage = baseDamage + damageFromWave + damageFromPlayerLevel;

  // --- 2) Nh√¢n h·ªá s·ªë theo lo·∫°i ƒë·ªÉ boss/bigboss v∆∞·ª£t tr·ªôi ---
  const isMini  = (z.type === 'miniBoss' || z.type === 'mini_boss' || z.isMini);
  const isElite = !!(z.isElite || z.elite || z.rank === 'elite' || z.tier === 'elite');
  const typeMult =
      z.isBigBoss ? 2.0 :
      z.isBoss    ? 1.6 :
      isMini      ? 1.3 :
      isElite     ? 1.15 :
                    1.0;

  totalDamage *= typeMult;

  // --- 3) C·ªông th√™m ph·∫ßn ng·∫´u nhi√™n theo lo·∫°i (roll 1 l·∫ßn / zombie) ---
  // D·∫£i ng·∫´u nhi√™n:
  // - Th∆∞·ªùng: 0..2
  // - Elite & Mini-boss: 1..10
  // - Boss: 5..20
  // - BigBoss: 10..50
  if (z._atkRnd == null) {
    const rnd = Math.random;
    if (z.isBigBoss) {
      z._atkRnd = (10 + Math.floor(rnd() * 41)); // 10..50
    } else if (z.isBoss) {
      z._atkRnd = (5 + Math.floor(rnd() * 16));  // 5..20
    } else if (isMini || isElite) {
      z._atkRnd = (1 + Math.floor(rnd() * 10));  // 1..10
    } else {
      z._atkRnd = Math.floor(rnd() * 3);   // 0..2 Math.floor(rnd()*3) cho ra {0,1,2}.
    }
  }
  totalDamage += z._atkRnd;

  // --- 4) Suy y·∫øu (gi·∫£m 50%) √°p d·ª•ng sau c√πng ---
  if (z.isWeakened && Date.now() < z.weakenEndTime) {
    totalDamage *= 0.5;
  } else if (z.isWeakened && Date.now() >= z.weakenEndTime) {
    z.isWeakened = false;
  }

  return Math.max(1, Math.floor(totalDamage));
}
// H√†m x·ª≠ l√Ω s√°t th∆∞∆°ng v√†o zombie, t·ª± ƒë·ªông ki·ªÉm tra ch·∫øt v√† hi·ªáu ·ª©ng
function dealDamageToZombie(z, dmg = 1) {
  if (window.isPlayerInSafeZone) return; // v√¥ hi·ªáu to√†n b·ªô s√°t th∆∞∆°ng t·ª´ ph√≠a player/skill
    let finalDamage = Math.max(1, Math.round(dmg));
    // --- LOGIC CHO CRAZYMADNESSTIME ---
    if (Date.now() < crazyMadnessTimeEndTime) {
        // TƒÉng s√°t th∆∞∆°ng x2 (v·∫´n gi·ªØ nguy√™n)
        finalDamage *= 2;

        // 1. T·ªâ l·ªá Crit 30%
        const isCrit = Math.random() < 0.3;

        // N·∫øu crit th√†nh c√¥ng...
        if (isCrit) {
            // TƒÉng 2.5 l·∫ßn s√°t th∆∞∆°ng
            finalDamage *= 2.5;
            finalDamage = Math.round(finalDamage);

            // 2. Hi·ªÉn th·ªã ch·ªØ "Crit!" bay l√™n t·ª´ zombie
            healEffects.push({
                x: z.x + 28 + (Math.random() - 0.5) * 5, // V·ªã tr√≠ ngang ng·∫´u nhi√™n ƒë·ªÉ tr√°nh ch·ªìng l·∫•n
                y: z.y - z.radius - 15, // Hi·ªán ·ªü v·ªã tr√≠ cao h∆°n s·ªë s√°t th∆∞∆°ng m·ªôt ch√∫t
                life: 90,   // T·ªìn t·∫°i 1.5 gi√¢y
                maxLife: 90,
                text: `Crit!`,
                delay: 0,
                color: 'orange' // M√†u cam cho n·ªïi b·∫≠t
            });

        // 3. H·ªìi m√°u CH·ªà KHI crit th√†nh c√¥ng
        const lifestealAmount = Math.ceil(finalDamage * 0.2); // H·ªìi 20% s√°t th∆∞∆°ng
        if (lifestealAmount > 0) {
            // 1. H·ªìi m√°u v√† √°p d·ª•ng gi·ªõi h·∫°n maxHearts (CH·ªà M·ªòT L·∫¶N)
            player.hearts = Math.min(player.maxHearts, player.hearts + lifestealAmount);
            createHealImpactEffect(player, lifestealAmount);
        }
      }
    }
    
// G√¢y s√°t th∆∞∆°ng sau khi tr·ª´ gi√°p (armor) ‚Äî cho ph√©p 0 dmg
const __armor = Math.max(0, Number(z.armor || 0));
let __afterArmor = Math.round(finalDamage) - __armor;
// Chu·∫©n ho√° -0 th√†nh 0 ƒë·ªÉ hi·ªÉn th·ªã ƒë·∫πp
if (Object.is(__afterArmor, -0)) __afterArmor = 0;
if (__afterArmor < 0) __afterArmor = 0;

z.hp -= __afterArmor;
createDamageImpactEffect(z, __afterArmor);
    // Ki·ªÉm tra v√† ti√™u di·ªát zombie n·∫øu h·∫øt m√°u
    if (!z._killed && z.hp <= 0) {
        killZombie(z);
    }
}

// üî™ Sword Pooling
function getSword() {
  return swordPool.length ? swordPool.pop() : {
    angle: 0,
    radius: 60,
    state: 'charging',
    chargeFrame: 90,
    x: 0,
    y: 0,
    target: null,
    fireDelay: 0,
    delay: 60
  };
}

function releaseSword(s) {
  swordPool.push(s);
}

// üî• Fireball Pooling
function getFireball() {
  return fireballPool.length ? fireballPool.pop() : {
    angle: 0,
    radius: 40,
    x: 0,
    y: 0
  };
}

function releaseFireball(f) {
  fireballPool.push(f);
}

// ‚ùÑÔ∏è Iceball Pooling
function getIceball() {
  return iceballPool.length ? iceballPool.pop() : {
    angle: 0,
    radius: 60,
    x: 0,
    y: 0
  };
}

function releaseIceball(i) {
  iceballPool.push(i);
}
// üßä Hi·ªÉn th·ªã c·∫£nh b√°o t·∫°m th·ªùi
function showWarning(message, customStyle = {}) {
  // T·∫°o khay n·∫øu ch∆∞a c√≥
  const container = document.getElementById('notificationContainer')
        || (() => {
             const c = document.createElement('div');
             c.id = 'notificationContainer';
             document.body.appendChild(c);
             return c;
           })();

  //  T·∫°o popup
  const popup = document.createElement('div');
  popup.className  = 'warningPopup';
  popup.textContent = message;
  Object.assign(popup.style, customStyle);   // n·∫øu c·∫ßn ƒë·ªïi m√†u, v.v.

  container.appendChild(popup);

  /* Gi·ªõi h·∫°n t·ªëi ƒëa N popup ƒë·ªìng th·ªùi */
  const MAX = 2;
  while (container.childElementCount > MAX) {
    container.firstElementChild.remove();
  }

  /* T·ª± xo√° sau 2 s */
  setTimeout(() => popup.remove(), 2000); // Th·ªùi gian hi·ªÉn th·ªã popup
}
/* ‚îÄ‚îÄ Buffer g·ªôp popup v·∫≠t ph·∫©m cho PET ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
const petLootBuffer  = {};
let   petLootTimer   = null;
/* --- Buffer g·ªôp popup cho Ng∆∞·ªùi ch∆°i --- */
const playerLootBuffer = {};
let playerLootTimer = null;

function queuePlayerLootPopup(icon, delay = 500) {
    playerLootBuffer[icon] = (playerLootBuffer[icon] || 0) + 1;

    clearTimeout(playerLootTimer);
    playerLootTimer = setTimeout(() => {
        const summary = Object.entries(playerLootBuffer)
            .map(([ico, c]) => `${ico} x${c}`)
            .join(', ');
        showWarning(`Nh·∫∑t ƒë∆∞·ª£c: ${summary}`);
        // X√≥a buffer sau khi hi·ªÉn th·ªã
        Object.keys(playerLootBuffer).forEach(k => delete playerLootBuffer[k]);
    }, delay);
}
function queuePetLootPopup(icon, delay = 500) { // <-- ƒê·ªïi t√™n h√†m
  petLootBuffer[icon] = (petLootBuffer[icon] || 0) + 1; // <-- ƒê·ªïi t√™n buffer

  clearTimeout(petLootTimer); // <-- ƒê·ªïi t√™n timer
  petLootTimer = setTimeout(() => { // <-- ƒê·ªïi t√™n timer
    const summary = Object.entries(petLootBuffer) // <-- ƒê·ªïi t√™n buffer
                  .map(([ico,c]) => `${ico} x${c}`)
                  .join(', ');
    showWarning(`üê∞ Pet nh·∫∑t: ${summary}`);
    Object.keys(petLootBuffer).forEach(k => delete petLootBuffer[k]); // <-- ƒê·ªïi t√™n buffer
  }, delay);
}
// H√†m b·∫Øn laze cho ng∆∞·ªùi ch∆°i
function firePlayerLaser() {
    const now = Date.now();
    if (now - lastManualShootTime < manualShootCooldown) return;
    lastManualShootTime = now;

    if (zombies.length === 0) return;

    // T√¨m m·ª•c ti√™u v√† g√≥c b·∫Øn (logic n√†y gi·ªØ nguy√™n)
    const target = zombies.reduce((a, b) =>
        distance(a, player) < distance(b, player) ? a : b
    );
    const angle = Math.atan2(target.y - player.y, target.x - player.x);

    // T·∫°o ra 2 ƒë·ªëi t∆∞·ª£ng lazer, m·ªôt cho m·ªói m·∫Øt
    playerLasers.push({ angle: angle, life: 20, eye: 'left' });
    playerLasers.push({ angle: angle, life: 20, eye: 'right' });

    // Ph·∫ßn x·ª≠ l√Ω s√°t th∆∞∆°ng gi·ªØ nguy√™n
    const laserPathTargets = [];
    const dx = Math.cos(angle);
    const dy = Math.sin(angle);

    zombies.forEach(z => {
        if (z.active) {
            const proj = (z.x - player.x) * dx + (z.y - player.y) * dy;
            const perp = Math.abs((z.x - player.x) * dy - (z.y - player.y) * dx);
            if (proj > 0 && proj < 2000 && perp < 10) { 
                laserPathTargets.push(z);
            }
        }
    });

    if (laserPathTargets.length > 0) {
        laserPathTargets.sort((a, b) => distance(player, a) - distance(player, b));
        const firstTarget = laserPathTargets[0];

        laserPathTargets.forEach(z => {
            let finalDamage = (z === firstTarget) 
                ? playerUpgrades.damageBoost 
                : Math.max(1, Math.round(playerUpgrades.damageBoost * 0.5));
            dealDamageToZombie(z, finalDamage);
        });
    }
}
// T·ªëc ƒë·ªô Ice Arrow (d·ª±a tr√™n c·∫•p ƒë·ªô n√¢ng c·∫•p)
function getIceArrowSpeed() {
  const base = 1;                     // lv0 = 1.0
  const lvl  = Math.min(4, (shopUpgrades.iceArrowSpeedLevel || 0)); // +0.5 m·ªói l·∫ßn, 4 l·∫ßn l√† 3.0
  return Math.min(3, base + lvl * 0.5);
}

//üî´ 4. B·∫Øn ƒë·∫°n & auto shoot
function shoot() {
  if (window.isPlayerInSafeZone) return; // ‚õ≥ trong Safe Zone: kh√¥ng b·∫Øn
  // Ki·ªÉm tra v√† ti√™u th·ª• stamina
  if (player.stamina < 1) {
    showWarning("Kh√¥ng ƒë·ªß üîπ Stamina!");
    return;
  }
  player.stamina--; // Tr·ª´ 1 stamina khi s·ª≠ d·ª•ng
  const now = Date.now();
  // d√πng cooldown ri√™ng cho Ice Arrow
  if (now - lastManualShootTime < getIceArrowCooldown()) return;
  lastManualShootTime = now;

  const directionCount = playerUpgrades.iceArrow;       // s·ªë m≈©i t√™n theo c·∫•p nh∆∞ c≈©
  const speed = getIceArrowSpeed();               // t·ªëc ƒë·ªô m≈©i t√™n theo c·∫•p
  const basePlayerDmg  = (playerUpgrades.damageBoost || 1);
  const iceBonus       = getIceArrowBonusDamage();
  const finalDmg       = basePlayerDmg + iceBonus;

  if (zombies.length === 0) return;

  // üîÅ M·ªêC 21: gi·ªØ nguy√™n h√†nh vi ‚Äúb·∫Øn 21 h∆∞·ªõng ph·ªß to√†n b·∫£n ƒë·ªì‚Äù
  if (directionCount >= 21) {
    const angleOffset = Math.random() * Math.PI * 2; // gi·ªØ ng·∫´u nhi√™n offset nh∆∞ b·∫£n g·ªëc
    for (let i = 0; i < directionCount; i++) {
      const angle = angleOffset + (2 * Math.PI / directionCount) * i;
      const b = getBullet();
      b.x = player.x; b.y = player.y;
      b.dx = Math.cos(angle); b.dy = Math.sin(angle);
      b.speed = speed; b.active = true;

      // üèπ bi·∫øn th√†nh m≈©i t√™n bƒÉng + xuy√™n + dmg ri√™ng
      b.isIceArrow = true;
      b.piercing   = true;
      b.customDmg  = finalDmg;

      bullets.push(b);
    }
    return;
  }

  // üéØ < 21: auto-aim ‚Äî ch·ªçn K zombie g·∫ßn nh·∫•t v√† b·∫Øn th·∫≥ng v√†o ch√∫ng
  const targets = kNearestZombiesByPlayer(directionCount, 0);
  if (!targets.length) return;

  for (let i = 0; i < directionCount; i++) {
    const t = targets[i % targets.length];
    const angle = Math.atan2(t.y - player.y, t.x - player.x);

    const b = getBullet();
    b.x = player.x; b.y = player.y;
    b.dx = Math.cos(angle); b.dy = Math.sin(angle);
    b.speed = speed; b.active = true;

    // üèπ Ice Arrow flags
    b.isIceArrow = true;
    b.piercing   = true;
    b.customDmg  = finalDmg;

    bullets.push(b);
  }
}

function autoShootBurst() {
  const now = Date.now(); // L·∫•y m·ªëc th·ªùi gian hi·ªán t·∫°i ƒë·ªÉ t√≠nh to√°n ch√≠nh x√°c

  // --- 1. QU·∫¢N L√ù TH·ªúI GIAN H·ªíI GI·ªÆA C√ÅC LO·∫†T B·∫ÆN ---

  // L·∫•y th·ªùi gian h·ªìi chi√™u g·ªëc t·ª´ bi·∫øn autoShootCooldown
  let currentCooldown = autoShootCooldown;

  // √Åp d·ª•ng c√°c buff gi√∫p b·∫Øn nhanh h∆°n n·∫øu c√≥
  if (supportAuraActive) {
    currentCooldown *= 0.8; // K·ªπ nƒÉng H√†o quang: gi·∫£m 20% th·ªùi gian h·ªìi chi√™u
  }
  if (Date.now() < crazyMadnessTimeEndTime) {
    currentCooldown /= 2; // Buff CrazyMadnessTime: t·ªëc ƒë·ªô b·∫Øn x2
  }

  // Ki·ªÉm tra xem ƒë√£ ƒë·ªß th·ªùi gian ƒë·ªÉ b·∫Øt ƒë·∫ßu m·ªôt lo·∫°t b·∫Øn M·ªöI ch∆∞a
  if (now - lastAutoShootTime >= currentCooldown) {
    lastAutoShootTime = now; // ƒê·∫∑t l·∫°i m·ªëc th·ªùi gian cho lo·∫°t b·∫Øn ti·∫øp theo
    autoBurstIndex = 0;      // Reset b·ªô ƒë·∫øm s·ªë ƒë·∫°n ƒë√£ b·∫Øn trong lo·∫°t v·ªÅ 0
  }

  // --- 2. QU·∫¢N L√ù VI·ªÜC B·∫ÆN T·ª™NG VI√äN TRONG M·ªòT LO·∫†T ---

  // L·∫•y s·ªë l∆∞·ª£ng ƒë·∫°n c·∫ßn b·∫Øn trong m·ªôt lo·∫°t t·ª´ ch·ªâ s·ªë n√¢ng c·∫•p c·ªßa ng∆∞·ªùi ch∆°i
  const bulletsPerDirection = playerUpgrades.lineBulletCount;

  // N·∫øu ƒë√£ b·∫Øn ƒë·ªß s·ªë ƒë·∫°n trong lo·∫°t n√†y r·ªìi th√¨ d·ª´ng l·∫°i
  if (autoBurstIndex >= bulletsPerDirection) return;

  // N·∫øu ch∆∞a ƒë·ªß ƒë·ªô tr·ªÖ gi·ªØa c√°c vi√™n ƒë·∫°n (v√≠ d·ª• 100ms), th√¨ d·ª´ng l·∫°i.
  if (now - autoLastBurstTime < autoBurstDelay) return;

  // --- 3. T√åM M·ª§C TI√äU V√Ä T√çNH TO√ÅN G√ìC B·∫ÆN ---
  const PLAYER_AUTOSHOOT_RANGE = 360; // T·∫ßm b·∫Øn t·ªëi ƒëa cho t·ª± ƒë·ªông b·∫Øn
  let nearestTarget = null;
  // So s√°nh b√¨nh ph∆∞∆°ng kho·∫£ng c√°ch ƒë·ªÉ tr√°nh d√πng Math.sqrt() t·ªën k√©m
  let minDistanceSq = PLAYER_AUTOSHOOT_RANGE * PLAYER_AUTOSHOOT_RANGE; 

  // D√πng v√≤ng l·∫∑p for ƒë∆°n gi·∫£n ƒë·ªÉ duy·ªát qua t·∫•t c·∫£ zombie
  for (const z of zombies) {
    // B·ªè qua nh·ªØng zombie kh√¥ng ho·∫°t ƒë·ªông
    if (!z.active) continue;

    // T√≠nh b√¨nh ph∆∞∆°ng kho·∫£ng c√°ch
    const dSq = distanceSq(player, z);

    // N·∫øu zombie n√†y g·∫ßn h∆°n m·ª•c ti√™u g·∫ßn nh·∫•t hi·ªán t·∫°i V√Ä n·∫±m trong t·∫ßm b·∫Øn
    if (dSq < minDistanceSq) {
      minDistanceSq = dSq;    // C·∫≠p nh·∫≠t kho·∫£ng c√°ch g·∫ßn nh·∫•t
      nearestTarget = z;      // G√°n m·ª•c ti√™u m·ªõi
    }
  }

  // N·∫øu sau v√≤ng l·∫∑p kh√¥ng t√¨m th·∫•y m·ª•c ti√™u n√†o, tho√°t ra
  if (nearestTarget === null) return;

  // G√°n target b·∫±ng m·ª•c ti√™u ƒë√£ t√¨m th·∫•y
  const target = nearestTarget; 

  // T√≠nh to√°n g√≥c b·∫Øn (radian) t·ª´ ng∆∞·ªùi ch∆°i ƒë·∫øn m·ª•c ti√™u
  const angle = Math.atan2(target.y - player.y, target.x - player.x);

  // --- 4. T·∫†O V√Ä B·∫ÆN ƒê·∫†N ---  
  const b = getBullet(); // L·∫•y m·ªôt vi√™n ƒë·∫°n t·ª´ kho (object pooling)
  // Thi·∫øt l·∫≠p c√°c thu·ªôc t√≠nh cho vi√™n ƒë·∫°n
  b.x = player.x;
  b.y = player.y;
  b.dx = Math.cos(angle); // H∆∞·ªõng di chuy·ªÉn theo tr·ª•c X
  b.dy = Math.sin(angle); // H∆∞·ªõng di chuy·ªÉn theo tr·ª•c Y
  b.speed = playerUpgrades.bulletSpeed;
  b.active = true;
  bullets.push(b); // Th√™m vi√™n ƒë·∫°n v√†o danh s√°ch ƒë·∫°n ƒëang bay

  playSound('sfx-shoot', 0.01); // Ph√°t √¢m thanh b·∫Øn v·ªõi √¢m l∆∞·ª£ng nh·ªè

  // TƒÉng b·ªô ƒë·∫øm s·ªë ƒë·∫°n ƒë√£ b·∫Øn trong lo·∫°t v√† c·∫≠p nh·∫≠t th·ªùi gian
  autoBurstIndex++;
  autoLastBurstTime = now;
}

//üî™ 5. K√≠ch ho·∫°t k·ªπ nƒÉng (K√≠ch ho·∫°t k·ªπ nƒÉng & g√°n n√∫t)
function activateSwordSkill() {
  if (swordActive) return;

  if (player.level < 1) return showWarning("üî™ Y√™u c·∫ßu Lv1");
  if (player.energy < 3) return showWarning("üî™ Kh√¥ng ƒë·ªß 3‚ö°");

  swordActive = true;
  swordEndTime = Date.now() + 60000;
  player.energy -= 3;
  document.getElementById("bladeBtn").classList.add("active");
  showWarning("üî™ K√≠ch ho·∫°t k·ªπ nƒÉng ƒêao xoay");
  // ‚ú® KH·ªûI T·∫†O B·ªò ƒêI·ªÄU KHI·ªÇN T·∫§N C√îNG
  lastBladeLaunchTime = Date.now();
  nextBladeToAttack = 0;

  swords = [];
  const count = skillUpgrades.bladeCount;
  for (let i = 0; i < count; i++) {
    const homeAngle = (2 * Math.PI / count) * i;
    swords.push({
      state: 'orbiting',
      angle: homeAngle,
      homeAngle: homeAngle,
      orbitRadius: 60,
      hitZombies: new Set(),
      pierceCount: 0,
      bladeIndex: i
    });
  }
}
// ‚öîÔ∏è K·ªπ nƒÉng m∆∞a ki·∫øm
function activateDownwardSwords() {
  if (bladeActive) return;

  if (player.level < 2) return showWarning("‚öîÔ∏è Y√™u c·∫ßu Lv2");
  if (player.energy < 6) return showWarning("‚öîÔ∏è Kh√¥ng ƒë·ªß 6‚ö°");

  bladeActive = true;
  bladeEndTime = Date.now() + 60000;
  player.energy -= 6;
  document.getElementById("swordBtn").classList.add("active");
  showWarning("‚öîÔ∏è K√≠ch ho·∫°t k·ªπ nƒÉng M∆∞a ki·∫øm");
  swordRainClouds = [];
  // S·ªë l∆∞·ª£ng m√¢y s·∫Ω b·∫±ng c·∫•p ƒë·ªô k·ªπ nƒÉng
  const cloudCount = skillUpgrades.swordLevel;
  
  for (let i = 0; i < cloudCount; i++) {
      // D√†n ƒë·ªÅu c√°c ƒë√°m m√¢y theo chi·ªÅu ngang m√†n h√¨nh
      const xPosition = (canvas.width / (cloudCount + 1)) * (i + 1);

      swordRainClouds.push({
          relativeX: xPosition,
          relativeY: 100 + (Math.random() - 0.5) * 20,
          driftSpeed: (Math.random() - 0.5) * 0.2,
          nextDropTime: Date.now() + Math.random() * 1000
      });
  }
}
// K√≠ch ho·∫°t k·ªπ nƒÉng PET ‚Äì Th·ªè m√†u h·ªìng
function activatePet() {
  petActive       = true;                      // nay ch·∫Øc ch·∫Øn ch∆∞a ho·∫°t ƒë·ªông
  petEndTime      = Date.now() + 60000;        // 60 s
  petLastHealTime = Date.now();

  petRabbit = {                                // speed t√≠nh ƒë·ªông m·ªói frame
    x      : player.x + 40,
    y      : player.y,
    radius : 14,
    attackTimer: 0
  };

  const btn        = document.getElementById("PetBtn");
  btn.innerText    = lastPetText;
  btn.classList.add("active");

  showWarning("üê∞ Pet th·ªè ƒë√£ ra tr·∫≠n!");
}
// üñ± G√°n s·ª± ki·ªán n√∫t
// üî™ K·ªπ nƒÉng ƒêao
document.getElementById("bladeBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 1) return showWarning("üî™ Y√™u c·∫ßu Lv1");
  if (player.energy < 5) return showWarning("üî™ Kh√¥ng ƒë·ªß 3‚ö°");
  activateSwordSkill();
};
// ‚öîÔ∏è K·ªπ nƒÉng Ki·∫øm
document.getElementById("swordBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 2) return showWarning("‚öîÔ∏è Y√™u c·∫ßu Lv2");
  if (player.energy < 6) return showWarning("‚öîÔ∏è Kh√¥ng ƒë·ªß 6‚ö°");
  activateDownwardSwords();
};
// üî• K·ªπ nƒÉng L·ª≠a
document.getElementById("fireBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 3) return showWarning("üî• Y√™u c·∫ßu Lv3");
  if (player.energy < 8) return showWarning("üî• Kh√¥ng ƒë·ªß 8‚ö°");
  if (!fireActive) {
    fireActive = true;
    fireballs.length = 0;
    const fireCount = skillUpgrades.fireCount;
    for (let i = 0; i < fireCount; i++) {
      const angle = (2 * Math.PI / fireCount) * i;
      const f = getFireball();
      f.angle = angle;
      f.radius = 40;
      f.x = player.x + Math.cos(angle) * 40;
      f.y = player.y + Math.sin(angle) * 40;
      fireballs.push(f);
    }
    fireEndTime = Date.now() + 60000;
    player.energy -= 8;
    document.getElementById("fireBtn").classList.add("active");
    showWarning("üî• K√≠ch ho·∫°t k·ªπ nƒÉng L·ª≠a");

  }
};
// ‚ùÑÔ∏è K·ªπ nƒÉng BƒÉng
document.getElementById("iceBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 3)   return showWarning("‚ùÑÔ∏è Y√™u c·∫ßu Lv3");
  if (player.energy < 12) return showWarning("‚ùÑÔ∏è Kh√¥ng ƒë·ªß 12‚ö°");
  if (!iceActive) {
    iceActive  = true;
    iceballs.length = 0;
    const iceCount = skillUpgrades.iceCount;
    for (let i = 0; i < iceCount; i++) {
      const angle = (2 * Math.PI / iceCount) * i;
      const b     = getIceball();
      b.angle  = angle;
      b.radius = 50;
      b.x = player.x + Math.cos(angle) * 60;
      b.y = player.y + Math.sin(angle) * 60;
      iceballs.push(b);
    }
    iceEndTime      = Date.now() + 60000;   // 60 s hi·ªáu l·ª±c
    player.energy  -= 12;                   // tr·ª´ nƒÉng l∆∞·ª£ng ƒë√∫ng 1 l·∫ßn
    document.getElementById("iceBtn").classList.add("active");
    showWarning("‚ùÑÔ∏è K√≠ch ho·∫°t k·ªπ nƒÉng BƒÉng");
  }
};
// === K·ªπ nƒÉng L√îI ===
document.getElementById("thunderBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 5) return showWarning("üîµ Y√™u c·∫ßu Lv5");
  if (player.energy < 18) return showWarning("üîµ Kh√¥ng ƒë·ªß 18‚ö°");
  if (!thunderActive) {
    thunderActive = true;
    thunderBalls.length = 0;
    const thunderCount = skillUpgrades.thunderCount;
    for (let i = 0; i < thunderCount; i++) {
      const angle = (2 * Math.PI / thunderCount) * i;
      thunderBalls.push({
        angle,
        radius: 50,
        x: player.x + Math.cos(angle) * 70,
        y: player.y + Math.sin(angle) * 70,
        stunCooldown: 0,
        nextZapTime: Date.now() + Math.random() * 1500
      });
    }
    thunderEndTime = Date.now() + 60000;
    player.energy -= 18;
    document.getElementById("thunderBtn").classList.add("active");
    showWarning("‚ùÑÔ∏è K√≠ch ho·∫°t k·ªπ nƒÉng L√¥i");
  }
};
// Auto b·∫Øn
document.getElementById("autoBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  autoShoot = !autoShoot;
  const btn = document.getElementById("autoBtn");
  if (autoShoot) {
    btn.classList.add("active");
    showWarning("üî´ K√≠ch ho·∫°t auto");
  } else {
    btn.classList.remove("active");
    showWarning("üî´ T·∫Øt auto!");
  }
};
// üê∞ K·ªπ nƒÉng Pet
document.getElementById("PetBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (petActive) return;                       // ƒëang c√≥ th·ªè ‚Üí b·ªè
  if (player.energy < 5) {
    showWarning("üê∞ Kh√¥ng ƒë·ªß 5 ‚ö°");
    return;
  }
  activatePet();                               // k√≠ch ho·∫°t th√†nh c√¥ng
  player.energy -= 5;                          // tr·ª´ ‚ö° duy nh·∫•t 1 l·∫ßn
};
// ‚ú® K·ªπ nƒÉng H√†o quang
document.getElementById("supportAuraBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
    if (player.level < 6) return showWarning("‚ú® Y√™u c·∫ßu Lv6");
    if (player.energy < 15) return showWarning("‚ú® Kh√¥ng ƒë·ªß 15‚ö°");
    
    if (!supportAuraActive) {
        supportAuraActive = true;
        supportAuraEndTime = Date.now() + 60000;
        player.energy -= 15;
        showWarning("‚ú® K√≠ch ho·∫°t H√†o quang!");
        document.getElementById("supportAuraBtn").classList.add("active");

        // T·∫°o hi·ªáu ·ª©ng c√°c ƒë∆∞·ªùng n·ª©t
        auraCrackLines = [];
        const crackCount = 30;
        const radius = 45;

        for (let i = 0; i < crackCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distFromCenter = Math.random() * radius;
            const length = 5 + Math.random() * 10;
            
            const x1 = Math.cos(angle) * distFromCenter;
            const y1 = Math.sin(angle) * distFromCenter;
            const x2 = x1 + Math.cos(angle) * length;
            const y2 = y1 + Math.sin(angle) * length;

            auraCrackLines.push({ x1, y1, x2, y2 });
        }
    }
};
// ü¶ã K√≠ch ho·∫°t k·ªπ nƒÉng Fairy activateFairySkill
document.getElementById("fairyBtn").onclick = () => {
  playSound('sfx-ui-click', 0.2);
  if (player.level < 7) return showWarning("ü¶ã Y√™u c·∫ßu Lv7");
  if (player.energy < 25) return showWarning("ü¶ã Kh√¥ng ƒë·ªß 25‚ö°");
  if (fairyActive) return; // Kh√¥ng k√≠ch ho·∫°t n·∫øu ƒëang trong th·ªùi gian h·ªìi

  fairyActive = true;
  fairyEndTime = Date.now() + 60000;
  player.energy -= 25;
  fairyDeathDefyAvailable = true; // K√≠ch ho·∫°t kh·∫£ nƒÉng h·ªìi sinh

  // T·∫°o c√°c Fairy d·ª±a tr√™n c·∫•p ƒë·ªô n√¢ng c·∫•p
  fairies = [];
  const count = skillUpgrades.fairyCount;
  for (let i = 0; i < count; i++) {
    fairies.push({
      angle: (2 * Math.PI / count) * i,
      orbitRadius: 50 + (i * 10), // C√°c Fairy bay ·ªü qu·ªπ ƒë·∫°o kh√°c nhau
      bobOffset: Math.random() * Math.PI * 2, // Hi·ªáu ·ª©ng nh·∫•p nh√¥ ri√™ng
      nextAttackTime: Date.now() + Math.random() * 2000
    });
  }

  showWarning("ü¶ã Tri·ªáu h·ªìi Fairy!");
};

//üßü 6. Sinh zombie v√† boss
// üé® M√†u t∆∞∆°ng ·ª©ng cho zombie c·∫•p 1 ‚Üí 10
const zombieColorsByLevel = [
  "#00cc66", // Level 1 ‚Äì Xanh l√° s√°ng (nh·∫π nh√†ng)
  "#3399ff", // Level 2 ‚Äì Xanh d∆∞∆°ng (nh·∫°t h∆°n boss)
  "#ffcc00", // Level 3 ‚Äì V√†ng s√°ng
  "#ff9900", // Level 4 ‚Äì Cam
  "#ff3333", // Level 5 ‚Äì ƒê·ªè s√°ng
  "#cc00cc", // Level 6 ‚Äì T√≠m
  "#9933ff", // Level 7 ‚Äì T√≠m xanh ƒëi·ªán
  "#ff66cc", // Level 8 ‚Äì H·ªìng neon
  "#00ffff", // Level 9 ‚Äì Xanh cyan
  "#ffffff"  // Level 10 ‚Äì Tr·∫Øng s√°ng ch√≥i (g·∫ßn max)
];

// üìä B·∫£ng x√°c su·∫•t c·∫•p ƒë·ªô zombie theo t·ª´ng wave
/**
 * T√≠nh to√°n c·∫•p ƒë·ªô (s·ª©c m·∫°nh) c·ªßa zombie, cho ph√©p c·∫£ 10 lo·∫°i xu·∫•t hi·ªán v·ªõi t·ªâ l·ªá thay ƒë·ªïi theo wave.
 * @param {number} wave - S·ªë wave hi·ªán t·∫°i.
 * @returns {number} C·∫•p ƒë·ªô c·ªßa zombie (d∆∞·ªõi d·∫°ng index t·ª´ 0 ƒë·∫øn 9).
 */
function getZombieLevelByWave(wave) {
    // Wave 1 v·∫´n lu√¥n l√† wave kh·ªüi ƒë·ªông v·ªõi zombie y·∫øu nh·∫•t.
    if (wave === 1) {
        return 0;
    }

    const MAX_ZOMBIE_LEVEL = 9; // C√≥ 10 c·∫•p ƒë·ªô, t·ª´ index 0 ƒë·∫øn 9.

    // 1. X√°c ƒë·ªãnh "tr·ªçng t√¢m ƒë·ªô kh√≥" cho wave hi·ªán t·∫°i.
    // Con s·ªë n√†y s·∫Ω tƒÉng d·∫ßn khi wave tƒÉng, quy·∫øt ƒë·ªãnh lo·∫°i zombie n√†o s·∫Ω ph·ªï bi·∫øn nh·∫•t.
    const centerLevel = (wave - 2) * 0.4;

    // 2. X√°c ƒë·ªãnh "ƒë·ªô ƒëa d·∫°ng". Con s·ªë n√†y c√†ng l·ªõn, c√°c lo·∫°i zombie xa tr·ªçng t√¢m c√†ng c√≥ c∆° h·ªôi xu·∫•t hi·ªán.
    const spread = 2.0 + (wave / 20);

    const weights = [];
    let totalWeight = 0;

    // 3. V√≤ng l·∫∑p qua t·∫•t c·∫£ 10 c·∫•p ƒë·ªô zombie (0 ƒë·∫øn 9) ƒë·ªÉ t√≠nh tr·ªçng s·ªë (t·ªâ l·ªá xu·∫•t hi·ªán).
    for (let i = 0; i <= MAX_ZOMBIE_LEVEL; i++) {
        // C√¥ng th·ª©c n√†y t√≠nh to√°n tr·ªçng s·ªë d·ª±a tr√™n m√¥ h√¨nh ƒë∆∞·ªùng cong Chu·∫©n (Gaussian curve).
        // Zombie c√≥ c·∫•p ƒë·ªô c√†ng g·∫ßn "tr·ªçng t√¢m ƒë·ªô kh√≥" th√¨ tr·ªçng s·ªë c√†ng cao, t·ªâ l·ªá xu·∫•t hi·ªán c√†ng l·ªõn.
        // Ngay c·∫£ ·ªü wave cao, zombie c·∫•p th·∫•p v·∫´n c√≥ m·ªôt tr·ªçng s·ªë r·∫•t nh·ªè (nh∆∞ng kh√°c 0).
        const distance = i - centerLevel;
        const weight = Math.exp(-(distance * distance) / (2 * spread * spread));
        
        weights.push({ level: i, weight: weight });
        totalWeight += weight;
    }

    // 4. Ch·ªçn ng·∫´u nhi√™n m·ªôt c·∫•p ƒë·ªô d·ª±a tr√™n c√°c tr·ªçng s·ªë ƒë√£ t√≠nh.
    const rand = Math.random() * totalWeight;
    let weightSum = 0;
    for (const item of weights) {
        weightSum += item.weight;
        if (rand < weightSum) {
            return item.level;
        }
    }

    return MAX_ZOMBIE_LEVEL; // D·ª± ph√≤ng n·∫øu c√≥ l·ªói x·∫£y ra.
}
// Kh·ªüi t·∫°o Zombie
function spawnZombie() {
  const z = getZombie();
    // ‚ú® G√ÅN CH·ª¶NG LO√ÄI NG·∫™U NHI√äN ‚ú®
  z.style = zombieTypes[Math.floor(Math.random() * zombieTypes.length)];
  const level = getZombieLevelByWave(wave); // c·∫•p t·ª´ 0‚Äì9
// HP zombie tƒÉng theo level player + random 1~10
// --- B·∫ÆT ƒê·∫¶U PH·∫¶N T√çNH HP C·∫¢I TI·∫æN ---

    // Ki·ªÉm tra xem c√≥ ph·∫£i l√† wave ƒë·∫ßu ti√™n kh√¥ng.
    // Wave 1 s·∫Ω c√≥ c√°ch t√≠nh HP ƒë·∫∑c bi·ªát ƒë·ªÉ gi√∫p ng∆∞·ªùi ch∆°i d·ªÖ kh·ªüi ƒë·∫ßu.
    if (wave === 1) {
        
        // G√°n HP cho zombie l√† m·ªôt s·ªë nguy√™n ng·∫´u nhi√™n t·ª´ 1 ƒë·∫øn 4.
        // Math.random() * 4 -> t·∫°o s·ªë th·∫≠p ph√¢n ng·∫´u nhi√™n t·ª´ 0 ƒë·∫øn 3.99...
        // Math.floor(...)   -> l√†m tr√≤n xu·ªëng (0, 1, 2, ho·∫∑c 3)
        // ... + 1           -> k·∫øt qu·∫£ cu·ªëi c√πng l√† 1, 2, 3, ho·∫∑c 4.
        z.hp = Math.floor(Math.random() * 2) + 1;

    } else {
        
        // N·∫øu kh√¥ng ph·∫£i wave 1 (t·ª©c l√† t·ª´ wave 2 tr·ªü ƒëi), √°p d·ª•ng c√¥ng th·ª©c t√≠nh HP ph·ª©c t·∫°p h∆°n.
        // C·∫•u h√¨nh c√°c ch·ªâ s·ªë c∆° b·∫£n ƒë·ªÉ t√≠nh to√°n HP.
        const HP_CONFIG = {
            BASE_HP: 1,                  // HP t·ªëi thi·ªÉu c·ªßa m·ªôt zombie.
            HP_PER_ZOMBIE_LEVEL: 5,      // L∆∞·ª£ng HP ƒë∆∞·ª£c c·ªông th√™m cho m·ªói c·∫•p c·ªßa zombie.
            HP_PER_WAVE: 2.5,            // L∆∞·ª£ng HP ƒë∆∞·ª£c c·ªông th√™m cho m·ªói wave (ƒë·ªô kh√≥ tƒÉng d·∫ßn).
            RANDOM_VARIANCE: 0.20,       // T·ªâ l·ªá ng·∫´u nhi√™n (+/- 20%) ƒë·ªÉ HP c·ªßa zombie ƒëa d·∫°ng h∆°n.
            ELITE_CHANCE: 0.05,          // 5% t·ªâ l·ªá xu·∫•t hi·ªán zombie Tinh Anh.
            ELITE_HP_MULTIPLIER: 5       // Zombie Tinh Anh s·∫Ω c√≥ l∆∞·ª£ng HP nh√¢n l√™n 5 l·∫ßn.
        };

        // T√≠nh to√°n HP c∆° b·∫£n tr∆∞·ªõc khi th√™m y·∫øu t·ªë ng·∫´u nhi√™n.
        // C√¥ng th·ª©c = HP g·ªëc + HP th∆∞·ªüng theo c·∫•p zombie + HP th∆∞·ªüng theo wave.
        // (wave - 1) ƒë∆∞·ª£c d√πng ƒë·ªÉ ƒë·∫£m b·∫£o vi·ªác c·ªông HP theo wave ch·ªâ b·∫Øt ƒë·∫ßu t·ª´ wave 2.
        let calculatedHp = HP_CONFIG.BASE_HP +
                           (level * HP_CONFIG.HP_PER_ZOMBIE_LEVEL) +
                           ((wave - 1) * HP_CONFIG.HP_PER_WAVE);

        // Th√™m y·∫øu t·ªë ng·∫´u nhi√™n v√†o HP ƒë√£ t√≠nh.
        const variance = calculatedHp * HP_CONFIG.RANDOM_VARIANCE; // T√≠nh to√°n l∆∞·ª£ng HP (+/- 20%).
        calculatedHp += Math.random() * variance * 2 - variance;   // C·ªông/tr·ª´ ng·∫´u nhi√™n trong kho·∫£ng ƒë√≥.

        // Ki·ªÉm tra xem zombie c√≥ ph·∫£i l√† lo·∫°i Tinh Anh (Elite) hay kh√¥ng.
        if (Math.random() < HP_CONFIG.ELITE_CHANCE) { // N·∫øu s·ªë ng·∫´u nhi√™n nh·ªè h∆°n 0.05 (5%)
            calculatedHp *= HP_CONFIG.ELITE_HP_MULTIPLIER; // Nh√¢n HP l√™n 5 l·∫ßn.
            z.isElite = true; // ƒê√°nh d·∫•u ƒë√¢y l√† zombie Tinh Anh.
        } else {
            z.isElite = false; // ƒê√°nh d·∫•u ƒë√¢y l√† zombie th∆∞·ªùng.
        }

        // G√°n HP cu·ªëi c√πng cho zombie, l√†m tr√≤n v√† ƒë·∫£m b·∫£o kh√¥ng bao gi·ªù nh·ªè h∆°n 1.
        z.hp = Math.max(1, Math.round(calculatedHp));
    }

    // --- K·∫æT TH√öC PH·∫¶N T√çNH HP ---

    // L∆∞u l·∫°i l∆∞·ª£ng HP ban ƒë·∫ßu c·ªßa zombie ƒë·ªÉ d√πng cho c√°c logic kh√°c n·∫øu c·∫ßn.
    z.baseHp = z.hp;
    z.level = level + 1; // c·∫•p th·∫≠t t·ª´ 1‚Äì10
    z.behaviorCheckCounter = 0; // Kh·ªüi t·∫°o b·ªô ƒë·∫øm chu k·ª≥ h√†nh vi
    z.showStatusIcon = Math.random() < 0.3; // G√°n ng·∫´u nhi√™n c√≥ hi·ªÉn th·ªã icon hay kh√¥ng l·∫ßn ƒë·∫ßu ti√™n
    z.lastDayBuffed = currentDay;
    z.isBuffed = false;
    z.nightBuffApplied = false;
    z.lastRegenTime = Date.now();

// üë£ Di chuy·ªÉn ng·∫´u nhi√™n ban ƒë·∫ßu
  z.state = "wandering";
  z.nextStateCheck = Date.now() + 3000; // ki·ªÉm tra m·ªói 3s khi ƒëang chasing - ki·ªÉm tra m·ªói gi√¢y
  z.wanderTime = Date.now() + 2000 + Math.random() * 2000; // t·ª´ 2 ƒë·∫øn 4 gi√¢y
  z.wanderAngle = Math.random() * Math.PI * 2;
// üé≤ Ch·ªçn ki·ªÉu wander: 80% di chuy·ªÉn, 20% ƒë·ª©ng im
  z.wanderBehavior = Math.random() < 0.2 ? "pause" : "move";
  z.baseSpeed = 0.2 + Math.random() * 1.3; // t·ªëc ƒë·ªô khi chasing - t·ªëc ƒë·ªô khi ƒëu·ªïi theo
  z.speed = 0.3 + Math.random() * 0.9;   // t·ªëc ƒë·ªô khi wandering - t·ªëc ƒë·ªô khi lang thang
  z.color = zombieColorsByLevel[level];
  z.type = "normal";
  z.radius = 15;
  z.isBoss = false;

// üéØ Random mini boss (xu·∫•t hi·ªán 2%) - T·ª∑ l·ªá xu·∫•t hi·ªán mini boss
// üéØ Random boss (xu·∫•t hi·ªán 1%)
if (Math.random() < 0.01) {
  z.type = "miniBoss";
  z.isBoss = false;                // boss th∆∞·ªùng (kh√°c v·ªõi isBigBoss c·ªßa world boss n·∫øu b·∫°n c√≥)
  // HP boss cao h∆°n miniBoss r√µ r·ªát ‚Äî b·∫°n c√≥ th·ªÉ tinh ch·ªânh h·ªá s·ªë n√†y
  z.hp = 25 * wave + Math.floor(player.level / 2) + Math.floor(Math.random() * 10 + 1);
  z.baseHp = z.hp;
  z.color = bossColors[Math.floor(Math.random() * bossColors.length)];
  z.radius = 16;                  // nh·ªè h∆°n miniBoss
  z.level = 98;                  // ƒë√°nh d·∫•u ri√™ng
  z.baseSpeed = 0.28 + Math.random() * 0.35;
  z.speed = 0.22 + Math.random() * 0.28;

// üéØ Random mini boss (xu·∫•t hi·ªán 2%) - ch·ªâ x√©t n·∫øu KH√îNG ph·∫£i boss
} else if (Math.random() < 0.02) {
  z.type = "miniBoss";
  z.isBoss = false;
  z.hp = 50 + wave + Math.floor(player.level / 2) + Math.floor(Math.random() * 20 + 1);
  z.baseHp = z.hp;
  z.color = bossColors[Math.floor(Math.random() * bossColors.length)];
  z.radius = 18;
  z.level = 99;
}
// üõ°Ô∏è ARMOR BY LEVEL + TYPE (kh√¥ng sinh r√°c)
{
  const lvClamp = Math.max(1, Math.min(10, Number(z.level || 1))); // 1..10
  const baseArmor = (lvClamp - 1) + Math.round(Math.random());     // lv-1 .. lv
  let extra = 0;
  if (z.isElite) extra += 2;
  if (z.type === "miniBoss") extra += 5;
  if (z.type === "boss") extra += 10;
  if (z.isBigBoss || z.type === "bigBoss") extra += 20;
  z.armor = baseArmor + extra;
}

// üìç T·∫°o zombie ng·∫´u nhi√™n b√™n trong b·∫£n ƒë·ªì
z.x = Math.random() * worldWidth;
z.y = Math.random() * worldHeight;
// üìç ƒê·∫∑t zombie
  zombies.push(z);
  zombieSpawnedCount++;
}

// M√†u boss
const bossColors = [
  "#ff3333", // ƒê·ªè t∆∞∆°i
  "#ff8800", // Cam r·ª±c
  "#ffaa00", // V√†ng cam
  "#00ccff", // Xanh d∆∞∆°ng s√°ng
  "#9933ff", // T√≠m ƒë·∫≠m
  "#00ff99", // Xanh ng·ªçc
  "#ff66cc", // H·ªìng neon
  "#ffffff", // Tr·∫Øng l·∫°nh
  "#888888", // X√°m tro (boss m√°y m√≥c)
  "#00ffff"  // Xanh cyan √°nh kim
];
// Gi·ªõi h·∫°n v√†o trong t∆∞·ªùng/map gi·ªëng dropItem
function clampToWorld(x, y) {
  const safeX = Math.min(worldWidth - wallThickness - 20, Math.max(wallThickness + 20, x));
  const safeY = Math.min(worldHeight - wallThickness - 20, Math.max(wallThickness + 20, y));
  return { x: safeX, y: safeY };
}
// === Mini Boss & Elite Spawners ===
function spawnMiniBossAt(x, y) {
  const z = getZombie();

  // V·ªã tr√≠ (k·∫πp bi√™n theo b√°n k√≠nh 18 n·∫øu c√≥)
  if (typeof clampToWorld === 'function') {
    const p = clampToWorld(x, y, 18);
    z.x = p.x; z.y = p.y;
  } else {
    z.x = x; z.y = y;
  }

  // ‚ú® ƒê·ªìng b·ªô c√°c field n·ªÅn nh∆∞ spawnZombie()
  z.style = zombieTypes[(Math.random() * zombieTypes.length) | 0];

  // State/di chuy·ªÉn (quan tr·ªçng ƒë·ªÉ kh√¥ng "ƒë·ª©ng im")
  z.state = "chasing";
  z.nextStateCheck = Date.now() + 3000;
  z.wanderTime = Date.now() + 2000 + Math.random() * 2000;
  z.wanderAngle = Math.random() * Math.PI * 2;
  z.wanderBehavior = Math.random() < 0.2 ? "pause" : "move";

  // D·∫£i t·ªëc ƒë·ªô nh∆∞ spawnZombie() (chasing d√πng baseSpeed)
  z.baseSpeed = 0.2 + Math.random() * 0.8; // 0.2‚Äì1.0
  z.speed = z.baseSpeed;                   // v√¨ ƒëang "chasing"

  // Mini Boss core
  z.type   = "miniBoss";
  z.radius = 18;
  z.hp     = 50 + wave + ((player.level / 2) | 0) + (((Math.random() * 20) | 0) + 1);
  z.baseHp = z.hp;   // ‚úÖ ƒë·ªìng b·ªô v·ªõi spawnZombie()
  z.level  = 99;
  if (Array.isArray(bossColors) && bossColors.length) {
    z.color = bossColors[(Math.random() * bossColors.length) | 0];
  }
  z.isBoss = false; // gi·ªØ r√µ r√†ng (getZombie() ƒë√£ false, d√≤ng n√†y ch·ªâ ƒë·ªÉ nh·∫•t qu√°n)

  // C·ªù/ƒë·∫øm nh∆∞ spawnZombie()
  z.behaviorCheckCounter = 0;
  z.showStatusIcon = Math.random() < 0.3;
  z.lastDayBuffed = currentDay;
  z.isBuffed = false;
  z.nightBuffApplied = false;
  z.lastRegenTime = Date.now();

  zombies.push(z);
  return z;
}
// Elite ƒë∆°n: ch·ªâ b·∫≠t c·ªù + AI, stat ƒë·ªÉ h·ªá th·ªëng chung lo (tr√°nh xung ƒë·ªôt)
function spawnEliteAt(x, y) {
  const z = getZombie();

  // V·ªã tr√≠ (k·∫πp bi√™n n·∫øu c√≥)
  if (typeof clampToWorld === 'function') {
    const p = clampToWorld(x, y, /*r=*/15);
    z.x = p.x; z.y = p.y;
  } else {
    z.x = x; z.y = y;
  }

  // ‚ú® G√ÅN CH·ª¶NG LO√ÄI NG·∫™U NHI√äN (nh∆∞ spawnZombie)
  z.style = zombieTypes[(Math.random() * zombieTypes.length) | 0];

  const levelIdx = getZombieLevelByWave(wave); // 0..9

  // --- T√çNH HP gi·ªëng h·ªát spawnZombie, nh∆∞ng √©p Elite ---
  if (wave === 1) {
    z.hp = Math.floor(Math.random() * 2) + 1; // 1..2 nh∆∞ code g·ªëc hi·ªán t·∫°i
  } else {
    const BASE_HP = 1;
    const HP_PER_ZOMBIE_LEVEL = 5;
    const HP_PER_WAVE = 2.5;
    const RANDOM_VARIANCE = 0.20;
    const ELITE_HP_MULTIPLIER = 5;

    let calculatedHp = BASE_HP
      + (levelIdx * HP_PER_ZOMBIE_LEVEL)
      + ((wave - 1) * HP_PER_WAVE);

    const variance = calculatedHp * RANDOM_VARIANCE;
    calculatedHp += Math.random() * variance * 2 - variance;

    calculatedHp *= ELITE_HP_MULTIPLIER; // √©p Elite
    z.hp = Math.max(1, Math.round(calculatedHp));
  }
  z.isElite = true;
  z.baseHp = z.hp;

  // --- C√°c field kh√°c nh∆∞ spawnZombie ---
  z.level = levelIdx + 1;        // 1..10
  z.behaviorCheckCounter = 0;
  z.showStatusIcon = Math.random() < 0.3;
  z.lastDayBuffed = currentDay;
  z.isBuffed = false;
  z.nightBuffApplied = false;
  z.lastRegenTime = Date.now();

  // üë£ State/di chuy·ªÉn (QUAN TR·ªåNG ƒë·ªÉ kh√¥ng "ƒë·ª©ng im")
  z.state = "wandering";
  z.nextStateCheck = Date.now() + 3000;
  z.wanderTime = Date.now() + 2000 + Math.random() * 2000;
  z.wanderAngle = Math.random() * Math.PI * 2;
  z.wanderBehavior = Math.random() < 0.2 ? "pause" : "move";
  z.baseSpeed = 0.2 + Math.random() * 0.8;
  z.speed = 0.15 + Math.random() * 0.5;

  // M√†u theo c·∫•p (gi·ªëng g·ªëc)
  z.color = zombieColorsByLevel[levelIdx];

  // Lo·∫°i/hitbox nh∆∞ zombie th∆∞·ªùng (KH√îNG chuy·ªÉn type)
  z.type = "normal";
  z.radius = 15;
  z.isBoss = false;

  zombies.push(z);
  zombieSpawnedCount++;
  return z;
}

// Elite Pack: d√πng spawnEliteAt ƒë·ªÉ b·∫£o to√†n pipeline
function spawnElitePackAt(cx, cy, cfg = 3) {
  const isNum  = typeof cfg === "number";
  const count  = isNum ? cfg : (cfg.count  ?? 3);
  const radius = isNum ? 24  : (cfg.radius ?? 24);
  const jitter = isNum ? 10  : (cfg.jitter ?? 10);

  for (let i = 0; i < count; i++) {
    const ang = Math.random() * Math.PI * 2;
    let ex = cx + Math.cos(ang) * (radius + Math.random() * jitter);
    let ey = cy + Math.sin(ang) * (radius + Math.random() * jitter);

    if (typeof clampToWorld === "function") {
      const p = clampToWorld(ex, ey, /*r=*/15);
      ex = p.x; ey = p.y;
    }
    spawnEliteAt(ex, ey);
  }
}
// H√†m sinh Boss üëπ
function spawnBoss(spawnX, spawnY) { // Th√™m 2 tham s·ªë v·ªã tr√≠
  const z = getZombie();

  // N·∫æU C√ì V·ªä TR√ç C·ª§ TH·ªÇ -> T·∫†O BOSS T·∫†I ƒê√ì
  if (spawnX !== undefined && spawnY !== undefined) {
      z.x = spawnX;
      z.y = spawnY;
  } else {   // üìç ‚ûä Ch·ªçn v·ªã tr√≠ ng·∫´u nhi√™n trong world
  // (worldWidth / worldHeight ƒë√£ d√πng cho zombie th∆∞·ªùng)
  do {
    z.x = Math.random() * worldWidth;
    z.y = Math.random() * worldHeight;
    // üìè ‚ûã B·∫£o ƒë·∫£m kh√¥ng ‚Äú√∫p s·ªçt‚Äù player
  } while (distance(z, player) < 250); // ‚â• 250 px m·ªõi cho xu·∫•t hi·ªán
  }
  z.radius = 30;
  z.baseSpeed = 0.015 + Math.random() * 0.2; // L∆∞u t·ªëc ƒë·ªô g·ªëc | T·ªëc ƒë·ªô boss
  z.speed = z.baseSpeed; // T·ªëc ƒë·ªô zombie
  z.isBoss = true;
  // HP boss tƒÉng theo wave v√† level player + random 1~100
  z.hp = 500 + wave * 2 + Math.floor(player.level / 2) + Math.floor(Math.random() * 100 + 1);
  z.baseHp = z.hp; // üîë Ghi nh·ªõ HP g·ªëc ƒë·ªÉ reset ban ng√†y
  z.type = "boss";
  z.level = 100; // level Boss
  z.armor = (9 + Math.round(Math.random())) + 10; // base(9..10) + 10 cho Boss
  z.color = bossColors[Math.floor(Math.random() * bossColors.length)]; // M√†u boss
  z.active = true;
  z.state = "chasing";
  zombies.push(z);
  zombieSpawnedCount++;
  z.lastDayBuffed = currentDay;
  z.isBuffed = false;
  z.nightBuffApplied = false;
  z.lastRegenTime = Date.now();
}
// H√†m sinh Big Boss üëπ ‚Äì boss m·∫°nh nh·∫•t
function spawnBigBoss() {
    const z = getZombie();
    z.active = true; // reset l·∫°i ch·∫Øc ch·∫Øn
    z.state = "chasing";
    z._killed = false;

    do {
        z.x = Math.random() * worldWidth;
        z.y = Math.random() * worldHeight;
    } while (distance(z, player) < 250); // tr√°nh sinh g·∫ßn player

    z.radius = 120; // K√≠ch th∆∞·ªõc bigboss
    z.baseSpeed = 0.01 + Math.random() * 0.2;
    z.speed = z.baseSpeed;
    z.isBoss = true;
    z.isBigBoss = true; // üîë ƒê√°nh d·∫•u ri√™ng bigBoss
    z.hp = 10000 + wave * 500 + Math.floor(Math.random() * 1000 + 250);
    z.baseHp = z.hp;
    z.type = "bigBoss";
    z.level = 999;
    z.armor = (9 + Math.round(Math.random())) + 20; // base(9..10) + 20 cho BigBoss
    z.color = "purple"; // ƒê·ªïi m√†u ƒë·ªÉ d·ªÖ ph√¢n bi·ªát
    z.active = true;
z.lazerTimer = 0;
z.isLazerAttacking = false;
z.lazerDuration = 0;
    zombies.push(z);
    zombieSpawnedCount++;
    z.lastDayBuffed = currentDay;
    z.isBuffed = false;
    z.nightBuffApplied = false;
    z.lastRegenTime = Date.now();
}

//üß† 7. C·∫≠p nh·∫≠t UI ‚Äì ch·ªâ DOM
// üßü H√†m c·∫≠p nh·∫≠t Wave ri√™ng bi·ªát
function updateWaveUI() {
  document.getElementById("score-bottom").innerText = 
  `Level: ${player.level.toString().padStart(4, '0')} |‚ö°: ${player.energy.toString().padStart(4, '0')}`;
  setTimeout(() => {
  document.getElementById("waveNumberDisplay").innerText = `Wave: ${wave}`;
}, 1000); // ‚è±Ô∏è hi·ªÉn th·ªã sau 1 gi√¢y
  document.getElementById("ui-mana").innerText = `üí† Mana: ${player.mana}`;
  document.getElementById("ui-stamina").innerText = `üîπ Stamina: ${player.stamina}`;
}
// C√°c bi·∫øn l∆∞u tr·∫°ng th√°i hi·ªÉn th·ªã tr∆∞·ªõc ƒë√≥ ƒë·ªÉ tr√°nh c·∫≠p nh·∫≠t DOM kh√¥ng c·∫ßn thi·∫øt
let lastScore = -1, lastLevel = -1, lastEnergy = -1, lastHearts = -1, lastHighScore = -1; let lastMana = -1;
let lastBladeText = "", lastSwordText = "", lastFireText = "", lastIceText = "", lastFpsText = "", lastPetText = "";
let lastDay = -1, lastCoins = -1, lastExp = -1;
const BUFF_INFO = {
  lucky: { icon: 'üçÄ', name: 'LuckyUp', desc: 'TƒÉng t·ªâ l·ªá r∆°i v·∫≠t ph·∫©m 30% v√† c√≥ th·ªÉ nh√¢n ƒë√¥i s·ªë l∆∞·ª£ng r∆°i.' },
  power: { icon: 'üçÅ', name: 'PowerUp', desc: 'TƒÉng m·∫°nh s√°t th∆∞∆°ng l√™n ƒë·∫øn 150% v√† tƒÉng theo c·∫•p ƒë·ªô c·ªßa b·∫°n.' },
  crazy: { icon: 'üçÇ', name: 'CrazyUp', desc: 'TƒÉng c√°c ch·ªâ s·ªë c∆° b·∫£n, t·ªëc ch·∫°y: 0.5, t·ªëc b·∫Øn: 1, s√°t th∆∞∆°ng 50%, s·ªë l∆∞·ª£ng ƒë·∫°n: 1, iceArrow: 10.' },
  exp:   { icon: 'üåø', name: 'ExpUp',   desc: 'TƒÉng 50% EXP nh·∫≠n ƒë∆∞·ª£c.' },
  magnet:{ icon: 'üß≤', name: 'Magnet',  desc: 'T·ª± ƒë·ªông h√∫t c√°c v·∫≠t ph·∫©m ·ªü g·∫ßn.' },
  crazymadness:{ icon:'üí¢', name:'CrazyMadnessTime', desc:'Tr·∫°ng th√°i cu·ªìng n·ªô ƒë·∫∑c bi·ªát, tƒÉng m·∫°nh c√°c ch·ªâ s·ªë c∆° b·∫£n, t·ªëc ch·∫°y: 0.5, t·ªëc b·∫Øn: 1, s√°t th∆∞∆°ng 200%, s·ªë l∆∞·ª£ng ƒë·∫°n: 1, iceArrow: 10.' }
};
function setBuffTip(el, id, endTime){
  if (!el) return;
  const info = BUFF_INFO[id];
  const now = Date.now();
  const active = now < endTime;
  const tip = `${info.icon} ${info.name}\n${info.desc}` + (active ? `\nC√≤n l·∫°i: ${((endTime - now)/1000).toFixed(1)}s` : '');
  if (el.dataset.tooltip !== tip) el.dataset.tooltip = tip; // tr√°nh ghi DOM th·ª´a
}

function updateUI() {
    // --- C·∫¨P NH·∫¨T C√ÅC TH√îNG TIN PH·ª§ ---
    if (currentDay !== lastDay) {
        document.getElementById('dayCounterDisplay').innerText = `Ng√†y: ${currentDay}`;
        lastDay = currentDay;
    }

    // C·∫≠p nh·∫≠t K·ª∑ l·ª•c (High Score) b·∫±ng player.score (s·ªë kill)
    const highScore = parseInt(localStorage.getItem('highScore') || '0');
    if (player.score > highScore) {
        localStorage.setItem('highScore', player.score);
    }
    if (highScore !== lastHighScore) {
        document.getElementById("highScoreDisplay").innerText = `üèÜ K·ª∑ l·ª•c: ${highScore}`;
        lastHighScore = highScore;
    }
    
    // --- C·∫¨P NH·∫¨T THANH TR·∫†NG TH√ÅI CH√çNH ---

    // C·∫≠p nh·∫≠t hi·ªÉn th·ªã ti·∫øn tr√¨nh EXP v√† HP
    const scoreTopDiv = document.getElementById("score-top");
    const required = player.requiredExp;
    const current = player.currentLevelExp;
    const remaining = required - current;

    // T·∫°o chu·ªói text m·ªõi cho EXP v√† HP
    const newExpText = `Exp: ${current.toString().padStart(4, '0')} |‚ù§Ô∏è: ${parseFloat(player.hearts.toFixed(2)).toString().padStart(4, '0')}`;
    // Ch·ªâ c·∫≠p nh·∫≠t DOM
    if (scoreTopDiv.innerText !== newExpText) {
        scoreTopDiv.innerText = newExpText;
    }
    
    // C·∫≠p nh·∫≠t tooltip v·ªõi l∆∞·ª£ng EXP c√≤n l·∫°i
    const newTooltip = `Exp c·∫•p ti·∫øp theo: ${remaining}`;
    if (scoreTopDiv.dataset.tooltip !== newTooltip) {
        scoreTopDiv.dataset.tooltip = newTooltip;
    }

    // C·∫≠p nh·∫≠t hi·ªÉn th·ªã s·ªë xu
    if (player.coins !== lastCoins) {
        const formattedCoins = player.coins.toString().padStart(4, '0');
        document.getElementById('coinCounterDisplay').innerText = `ü™ô: ${formattedCoins}`;
        lastCoins = player.coins;
    }

    // C·∫≠p nh·∫≠t hi·ªÉn th·ªã Level v√† Energy
    if (player.level !== lastLevel || player.energy !== lastEnergy) {
        lastLevel = player.level;
        lastEnergy = player.energy;
        updateWaveUI(); // G·ªçi h√†m con ƒë·ªÉ c·∫≠p nh·∫≠t text cho Level v√† Energy
    }

    // C·∫≠p nh·∫≠t hi·ªÉn th·ªã Mana
    if (player.mana !== lastMana) {
        lastMana = player.mana;
        document.getElementById("ui-mana").innerText = `üí† Mana: ${player.mana}`;
    }
if (player.stamina !== lastStamina) {
    lastStamina = player.stamina;
    const roundedStamina = parseFloat(player.stamina.toFixed(2)); // ‚¨ÖÔ∏è 2 ch·ªØ s·ªë
    document.getElementById("ui-stamina").innerText = `üîπ Stamina: ${roundedStamina}`;
}
    // --- C·∫¨P NH·∫¨T HI·ªÇN TH·ªä C√ÅC BUFF T·∫†M TH·ªúI ---
    
    // C·∫≠p nh·∫≠t hi·ªÉn th·ªã cho buff Lucky
    const luckyDisplay = document.getElementById('luckyBuffDisplay');
            setBuffTip(luckyDisplay, 'lucky', luckyBuffEndTime);
    if (Date.now() < luckyBuffEndTime) {
        luckyDisplay.classList.remove('inactive');
        luckyDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((luckyBuffEndTime - Date.now()) / 1000);
        luckyDisplay.innerHTML = `üçÄ LuckyUp: <span>${timeLeft}</span>s`; // S·ª≠a t√™n
    } else {
        luckyDisplay.classList.add('inactive');
        luckyDisplay.classList.remove('active-glow');
        luckyDisplay.innerHTML = `üçÄ LuckyUp: <span>---</span>`; // S·ª≠a t√™n
    }

    // C·∫≠p nh·∫≠t hi·ªÉn th·ªã cho buff Power
    const powerDisplay = document.getElementById('powerBuffDisplay');
            setBuffTip(powerDisplay, 'power', powerBuffEndTime);
    if (Date.now() < powerBuffEndTime) {
        powerDisplay.classList.remove('inactive');
        powerDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((powerBuffEndTime - Date.now()) / 1000);
        powerDisplay.innerHTML = `üçÅ PowerUp: <span>${timeLeft}</span>s`; // S·ª≠a t√™n
    } else {
        powerDisplay.classList.add('inactive');
        powerDisplay.classList.remove('active-glow');
        powerDisplay.innerHTML = `üçÅ PowerUp: <span>---</span>`; // S·ª≠a t√™n
    }
    
    // C·∫≠p nh·∫≠t hi·ªÉn th·ªã cho buff Crazy
    const crazyDisplay = document.getElementById('crazyBuffDisplay');
            setBuffTip(crazyDisplay, 'crazy', crazyBuffEndTime);
    if (Date.now() < crazyBuffEndTime) {
        crazyDisplay.classList.remove('inactive');
        crazyDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((crazyBuffEndTime - Date.now()) / 1000);
        crazyDisplay.innerHTML = `üçÇ CrazyUp: <span>${timeLeft}</span>s`; // S·ª≠a t√™n
    } else {
        crazyDisplay.classList.add('inactive');
        crazyDisplay.classList.remove('active-glow');
        crazyDisplay.innerHTML = `üçÇ CrazyUp: <span>---</span>`; // S·ª≠a t√™n
    }

    // C·∫≠p nh·∫≠t hi·ªÉn th·ªã cho buff ExpUp (M·ªöI)
    const expDisplay = document.getElementById('expBuffDisplay');
            setBuffTip(expDisplay, 'exp', expBuffEndTime);
    if (Date.now() < expBuffEndTime) {
        expDisplay.classList.remove('inactive');
        expDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((expBuffEndTime - Date.now()) / 1000);
        expDisplay.innerHTML = `üåø ExpUp: <span>${timeLeft}</span>s`;
    } else {
        expDisplay.classList.add('inactive');
        expDisplay.classList.remove('active-glow');
        expDisplay.innerHTML = `üåø ExpUp: <span>---</span>`;
    }
    // C·∫≠p nh·∫≠t hi·ªÉn th·ªã cho buff Magnet
    const magnetDisplay = document.getElementById('magnetBuffDisplay');
            setBuffTip(magnetDisplay, 'magnet', magnetBuffEndTime);
    if (Date.now() < magnetBuffEndTime) {
        magnetDisplay.style.display = 'block'; // Hi·ªán l√™n
        magnetDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((magnetBuffEndTime - Date.now()) / 1000);
        magnetDisplay.innerHTML = `üß≤ Magnet: <span>${timeLeft}</span>s`;
    } else {
        magnetDisplay.style.display = 'none'; // ·∫®n ƒëi
        magnetDisplay.classList.remove('active-glow');
    }
    // C·∫≠p nh·∫≠t hi·ªÉn th·ªã cho buff CrazyMadnessTime (M·ªöI)
    const crazyMadnessDisplay = document.getElementById('crazymadnesstimeBuffDisplay');
            setBuffTip(crazyMadnessDisplay, 'crazymadness', crazyMadnessTimeEndTime);
    if (Date.now() < crazyMadnessTimeEndTime) {
        crazyMadnessDisplay.style.display = 'block'; // Hi·ªán l√™n
        crazyMadnessDisplay.classList.add('active-glow');
        const timeLeft = Math.ceil((crazyMadnessTimeEndTime - Date.now()) / 1000);
        crazyMadnessDisplay.innerHTML = `üí¢ CrazyMadnessTime: <span>${timeLeft}</span>s`;
    } else {
        crazyMadnessDisplay.style.display = 'none'; // ·∫®n ƒëi
        crazyMadnessDisplay.classList.remove('active-glow');
    }
}

// üßø T√¨m zombie c√≤n s·ªëng g·∫ßn player nh·∫•t 
function findActiveZombie() {
  return zombies.find(z => z.active);
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   üê∞ C·∫¨P NH·∫¨T PET ‚Äì G·ªåI M·ªñI FRAME
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
// ====== PET EQUIP VISITOR (no-alloc) ========================================
// D√πng l·∫°i m·ªói frame, kh√¥ng t·∫°o callback ·∫©n danh.
let __petMinD2 = 0, __petRef = null;
function __visitDropForPet(d) {
  if (!d || d.active === false) return;
  const dx = d.x - __petRef.x, dy = d.y - __petRef.y;
  const d2 = dx * dx + dy * dy;
  if (d2 < __petMinD2) {
    __petMinD2 = d2;
    __petRef.target = d;
    __petRef.targetIsEquip = true;
  }
}

// ====== UPDATE PET ===========================================================
function updatePet() {
  const now = Date.now();
  if (!petActive || !petRabbit) return;

  // H·∫±ng s·ªë
  const DIST_ITEM    = 360;
  const DIST_FOLLOW  = 480;
  const TOLERANCE    = 40;
  const PICK_DIST    = 16;
  const GIVE_UP_MS   = 3000;
  const MIN_PROGRESS = 20;

  // T·ªëc ƒë·ªô pet
  petRabbit.speed = (player.speed ?? 1) + 0.4;

  // 0) Qu√° xa ‚Üí quay v·ªÅ
  if (distance(petRabbit, player) > DIST_FOLLOW) {
    moveTowards(petRabbit, player, petRabbit.speed * 1.6);
    petRabbit.target = null;
    petRabbit.targetIsEquip = false;
    return;
  }

  // 1) Ch·ªçn m·ª•c ti√™u m·ªõi (∆∞u ti√™n g·∫ßn nh·∫•t)
  if (!petRabbit.target || !petRabbit.target.active) {
    petRabbit.target = null;
    petRabbit.targetIsEquip = false;

    let minDistanceSq = DIST_ITEM * DIST_ITEM;

    // 1.a) ITEMS th∆∞·ªùng
    for (let i = 0; i < items.length; i++) {
      const it = items[i];
      if (!it || !it.active) continue;
      if (now - lastGiveUpTime < RESELECT_CD && it.id === lastGiveUpId) continue;
      const d2 = distanceSq(petRabbit, it);
      if (d2 < minDistanceSq) {
        minDistanceSq = d2;
        petRabbit.target = it;
        petRabbit.targetIsEquip = false;
      }
    }

    // 1.b) TRANG B·ªä r∆°i (EquipmentDropAPI) ‚Äî no-alloc visitor
    const api = window.EquipmentDropAPI;
    if (api && typeof api.forEachActiveDrop === 'function') {
      __petMinD2 = minDistanceSq;
      __petRef   = petRabbit;
      api.forEachActiveDrop(__visitDropForPet);
      // N·∫øu v·ª´a ch·ªçn equip ‚Üí c·∫≠p nh·∫≠t l·∫°i minDistanceSq ƒë·ªÉ progress chu·∫©n
      if (petRabbit.targetIsEquip) minDistanceSq = __petMinD2;
    }

    if (petRabbit.target) {
      petRabbit.chaseStart    = now;
      petRabbit.startDistance = Math.sqrt(minDistanceSq);
    }
  }

  // 2) ƒêu·ªïi & nh·∫∑t
  if (petRabbit.target) {
    const tg = petRabbit.target;
    const dNow    = distance(petRabbit, tg);
    const elapsed = now - (petRabbit.chaseStart || now);
    const progress = (petRabbit.startDistance || 0) - dNow;

    // Kh√¥ng ti·∫øn tri·ªÉn ‚Üí b·ªè
    if (elapsed > GIVE_UP_MS && progress < MIN_PROGRESS) {
      giveUp();
      return;
    }
    // M·ª•c ti√™u qu√° xa player ‚Üí b·ªè
    if (distance(player, tg) > DIST_FOLLOW) {
      giveUp();
      return;
    }

    // Di chuy·ªÉn t·ªõi m·ª•c ti√™u
    moveTowards(petRabbit, tg, petRabbit.speed);

    // T·ªõi g·∫ßn ‚Üí nh·∫∑t
    if (dNow < PICK_DIST) {
      collectLoot(); // ƒë√£ h·ªó tr·ª£ c·∫£ TRANG B·ªä (petRabbit.targetIsEquip)
      return;
    }
  }
  // 3) Kh√¥ng c√≥ m·ª•c ti√™u ‚Üí b√°m player
  else if (distance(petRabbit, player) > TOLERANCE) {
    moveTowards(petRabbit, player, petRabbit.speed * 1.2);
  }

  // ‚ú® T·∫•n c√¥ng (gi·ªØ t·ªëi ∆∞u)
  if (petRabbit.attackTimer > 0) {
    petRabbit.attackTimer -= 1000 * globalDeltaTime;
  }
  if (petRabbit.attackTimer <= 0) {
    let nearestZombie = null, minZombD2 = Infinity;
    for (let i = 0; i < zombies.length; i++) {
      const z = zombies[i];
      if (!z || !z.active) continue;
      const d2 = distanceSq(petRabbit, z);
      if (d2 < minZombD2) { minZombD2 = d2; nearestZombie = z; }
    }
    if (nearestZombie) {
      petRabbit.attackTimer = 1000;
      const b = getBullet();
      b.x = petRabbit.x; b.y = petRabbit.y;
      const ang = Math.atan2(nearestZombie.y - petRabbit.y, nearestZombie.x - petRabbit.x);
      b.dx = Math.cos(ang); b.dy = Math.sin(ang);
      b.isPetBullet = true;
      b.icon = 'ü•ï';
      b.speed = 2;
      b.stunDuration = 1000;
      b.customDmg = 1 + (wave - 1) + (player.level - 1);
      bullets.push(b);
    }
  }

  // H·ªìi m√°u & h·∫øt gi·ªù (gi·ªØ nguy√™n)
  if (now - petLastHealTime >= 3000) {
    petLastHealTime = now;
    player.hearts = Math.min(player.maxHearts, player.hearts + 1);
    createHealImpactEffect(player, 1);
  }
  if (now >= petEndTime) {
    petActive = false;
    petRabbit = null;
    showWarning("üê∞ Pet ƒë√£ r·ªùi ƒëi.");
  }
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   üöÄ C·∫¨P NH·∫¨T T√äN L·ª¨A ‚Äì G·ªåI M·ªñI FRAME
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function updateMissiles() {
  // L·∫∑p ng∆∞·ª£c ƒë·ªÉ x√≥a ph·∫ßn t·ª≠ an to√†n
  for (let i = missiles.length - 1; i >= 0; i--) {
    const m = missiles[i];
    let shouldRemove = false; // C·ªù ƒë·ªÉ quy·∫øt ƒë·ªãnh c√≥ x√≥a t√™n l·ª≠a kh√¥ng

    // --- Giai ƒëo·∫°n ch·ªù (delay) ---
    if (m.state === "delay") {
      m.delay--;
      if (m.delay <= 0) {
        m.state = "fly";
      }
      continue; 
    }

    // --- C·∫≠p nh·∫≠t di chuy·ªÉn & d·∫´n h∆∞·ªõng ---
    if (m.target && m.target.active) {
      const desiredAngle = Math.atan2(m.target.y - m.y, m.target.x - m.x);
      const currentAngle = Math.atan2(m.dy, m.dx);
      const turnRate = 0.05;
      let delta = desiredAngle - currentAngle;
      if (delta > Math.PI) delta -= 2 * Math.PI;
      if (delta < -Math.PI) delta += 2 * Math.PI;
      const newAngle = currentAngle + Math.sign(delta) * Math.min(turnRate, Math.abs(delta));
      const speed = 2.5;
      m.dx = Math.cos(newAngle) * speed;
      m.dy = Math.sin(newAngle) * speed;
    }
    m.x += m.dx;
    m.y += m.dy;

    // --- G√¢y s√°t th∆∞∆°ng xuy√™n tr√™n ƒë∆∞·ªùng bay ---
    zombies.forEach(z => {
      if (z.active && !m.hitSet.has(z) && distance(m, z) < 20) {
        if (!z.missileHitCooldown || Date.now() > z.missileHitCooldown) {
          dealDamageToZombie(z, m.damage);
          m.hitSet.add(z);
          z.missileHitCooldown = Date.now() + 100;
        }
      }
    });

    // --- Ki·ªÉm tra ƒëi·ªÅu ki·ªán ƒë·ªÉ n·ªï ---
    const travelDistance = distance({ x: m.startX, y: m.startY }, m);
    const hitTarget = m.target && m.target.active && distance(m, m.target) < 25;

    if (travelDistance > 360 || hitTarget) {
      // K√≠ch ho·∫°t v·ª• n·ªï k√©p
      zombies.forEach(z => {
        if (z.active && distance(m, z) < 120) {
          dealDamageToZombie(z, m.damage);
        }
      });
      createParticleExplosion(m.x, m.y, 50, 'fire');
      setTimeout(() => {
        zombies.forEach(z => {
          if (z.active && distance(m, z) < 120) {
            dealDamageToZombie(z, m.damage * 0.5);
          }
        });
        const secondaryExplosion = getExplosion(m.x, m.y);
        secondaryExplosion.life = 15;
        explosions.push(secondaryExplosion);
      }, 200);
      shouldRemove = true;
    }

    if (shouldRemove) {
      missiles.splice(i, 1);
    }
  }
}

/* ================================
   1) L∆Ø·ªöI KH√îNG GIAN (SPATIAL GRID)
   - M·ª•c ti√™u: ch·ªâ x√©t ƒë·ªëi t∆∞·ª£ng "·ªü g·∫ßn" h·ªë ƒëen.
   - KH√îNG t·∫°o m·∫£ng m·ªõi m·ªói frame -> tr√°nh GC.
   - V·ªõi world 3000x2000, cell 200 l√† h·ª£p l√Ω (c√≥ th·ªÉ ch·ªânh).
================================== */

const WORLD_W = 3000;
const WORLD_H = 2000;
const CELL_SIZE = 200; // n√™n >= pullRadius l·ªõn nh·∫•t ƒë·ªÉ gi·∫£m s·ªë cell ki·ªÉm tra

const GRID_COLS = Math.ceil(WORLD_W / CELL_SIZE);
const GRID_ROWS = Math.ceil(WORLD_H / CELL_SIZE);
const GRID_COUNT = GRID_COLS * GRID_ROWS;

// M·∫£ng cell t√°i s·ª≠ d·ª•ng cho m·ªói frame (m·ªói cell l√† 1 m·∫£ng reuse)
const gridZ = new Array(GRID_COUNT);
const gridB = new Array(GRID_COUNT);
for (let i = 0; i < GRID_COUNT; i++) {
    gridZ[i] = [];
    gridB[i] = [];
}

// Scratch array d√πng t·∫°m cho m·ªói h·ªë ƒëen (kh√¥ng c·∫•p ph√°t m·ªõi)
const scratchCells = [];

// Gi·ªõi h·∫°n & t√≠nh ch·ªâ s·ªë cell t·ª´ to·∫° ƒë·ªô
function clamp(v, min, max) {
    return v < min ? min : (v > max ? max : v);
}
function cellIndexFromXY(x, y) {
    // clamp ƒë·ªÉ tr√°nh v∆∞·ª£t ngo√†i bi√™n
    x = clamp(x, 0, WORLD_W - 1);
    y = clamp(y, 0, WORLD_H - 1);
    const col = (x / CELL_SIZE) | 0;
    const row = (y / CELL_SIZE) | 0;
    return row * GRID_COLS + col;
}

// Li·ªát k√™ c√°c cell m√† m·ªôt h√¨nh tr√≤n (t√¢m cx,cy; b√°n k√≠nh r) c·∫Øt qua
// Ghi th·∫≥ng v√†o 'out' (scratchCells), kh√¥ng return m·∫£ng m·ªõi -> tr√°nh GC.
function cellsForCircle(cx, cy, r, out) {
    let minCol = ((cx - r) / CELL_SIZE) | 0;
    let maxCol = ((cx + r) / CELL_SIZE) | 0;
    let minRow = ((cy - r) / CELL_SIZE) | 0;
    let maxRow = ((cy + r) / CELL_SIZE) | 0;

    if (minCol < 0) minCol = 0;
    if (minRow < 0) minRow = 0;
    if (maxCol >= GRID_COLS) maxCol = GRID_COLS - 1;
    if (maxRow >= GRID_ROWS) maxRow = GRID_ROWS - 1;

    // Ghi tr·ª±c ti·∫øp ch·ªâ s·ªë cell v√†o 'out'
    let k = 0;
    for (let r0 = minRow; r0 <= maxRow; r0++) {
        const base = r0 * GRID_COLS;
        for (let c = minCol; c <= maxCol; c++) {
            out[k++] = base + c;
        }
    }
    out.length = k; // c·∫Øt chi·ªÅu d√†i v·ªÅ ƒë√∫ng s·ªë √¥
}

/* ============================================
   2) C·∫¨P NH·∫¨T CH·ªà M·ª§C KH√îNG GIAN CHO ENTITIES
   - G·ªçi M·ªòT L·∫¶N tr∆∞·ªõc khi update h·ªë ƒëen m·ªói frame.
   - Kh√¥ng t·∫°o m·∫£ng m·ªõi: ch·ªâ reset length = 0.
============================================= */

function clearSpatialGrid() {
    // GRID_COUNT nh·ªè (~150) n√™n vi·ªác reset r·∫•t r·∫ª
    for (let i = 0; i < GRID_COUNT; i++) {
        gridZ[i].length = 0;
        gridB[i].length = 0;
    }
}

function updateSpatialIndex() {
    clearSpatialGrid();

    // Ghi zombie v√†o l∆∞·ªõi
    for (let i = 0; i < zombies.length; i++) {
        const z = zombies[i];
        if (!z.active) continue;
        const idx = cellIndexFromXY(z.x, z.y);
        gridZ[idx].push(z);
    }

    // Ghi ƒë·∫°n ƒë·ªãch v√†o l∆∞·ªõi
    for (let i = 0; i < enemyBullets.length; i++) {
        const b = enemyBullets[i];
        if (!b.active) continue;
        const idx = cellIndexFromXY(b.x, b.y);
        gridB[idx].push(b);
    }
}

/* ============================================================
   3) updateBlackHoles
   - duy·ªát ng∆∞·ª£c + splice ƒë·ªÉ xo√°.
   - Ch·ªâ x√©t entity trong c√°c cell giao v·ªõi pullRadius.
   - H·∫°n ch·∫ø Math.sqrt: ch·ªâ sqrt khi ch·∫Øc ch·∫Øn trong ph·∫°m vi.
   - Tr√°nh atan2/cos/sin: d√πng vector chu·∫©n ho√° (dx,dy)/d.
============================================================= */
const FEEL_COMPAT = true;
const Z_PULL_MULT = FEEL_COMPAT ? 4 : 2;
const B_PULL_MULT = FEEL_COMPAT ? 2 : 1;
const DAMAGE_INTERVAL = 30;
const PARTICLE_INTERVAL = FEEL_COMPAT ? 2 : 3;

function isCircleVisible(x, y, r, camera) {
    if (!camera) return true; // n·∫øu kh√¥ng c√≥ camera, lu√¥n v·∫Ω
    const left   = camera.x - r - 64;
    const right  = camera.x + camera.w + r + 64;
    const top    = camera.y - r - 64;
    const bottom = camera.y + camera.h + r + 64;
    return (x >= left && x <= right && y >= top && y <= bottom);
}

function updateBlackHoles() {
    const now = Date.now();

    // Duy·ªát ng∆∞·ª£c ƒë·ªÉ c√≥ th·ªÉ splice xo√° ph·∫ßn t·ª≠ an to√†n
    for (let i = blackHoles.length - 1; i >= 0; i--) {
        const hole = blackHoles[i];

        // H·∫øt h·∫°n s·ªëng ‚Üí xo√° ngay, kh√¥ng x·ª≠ l√Ω ti·∫øp
        if (now >= hole.endTime) {
            blackHoles.splice(i, 1);
            continue;
        }

        // Tick ch·ªâ tƒÉng 1 l·∫ßn/frame
        hole.tick++;

        // Cache thu·ªôc t√≠nh d√πng nhi·ªÅu l·∫ßn ƒë·ªÉ gi·∫£m lookup
        const pullRadius = hole.pullRadius | 0;
        const pullSpeed  = hole.pullSpeed;
        const hx = hole.x, hy = hole.y;

        // Precompute cho ki·ªÉm tra ph·∫°m vi
        const r2   = pullRadius * pullRadius;
        const invR = pullRadius > 0 ? (1 / pullRadius) : 0;
        const damageThisTick = (hole.tick % DAMAGE_INTERVAL === 0);

        // Ch·ªâ h√∫t khi c√≥ b√°n k√≠nh & t·ªëc ƒë·ªô h√∫t
        if (pullRadius > 0 && pullSpeed !== 0) {
            // L·∫•y danh s√°ch cell giao v·ªõi h√¨nh tr√≤n h√∫t (kh√¥ng t·∫°o m·∫£ng m·ªõi)
            cellsForCircle(hx, hy, pullRadius, scratchCells);
            // Duy·ªát t·ª´ng cell ·ª©ng vi√™n
            for (let ci = 0; ci < scratchCells.length; ci++) {
                const idx = scratchCells[ci];

                // --- H√∫t zombie ---
                const cellZ = gridZ[idx];
                for (let zi = 0; zi < cellZ.length; zi++) {
                    const z = cellZ[zi];
                    if (!z.active) continue;

                    // Vector t·ª´ zombie ƒë·∫øn t√¢m h·ªë
                    const dx = hx - z.x;
                    const dy = hy - z.y;
                    const d2 = dx * dx + dy * dy;

                    // So s√°nh b√¨nh ph∆∞∆°ng kho·∫£ng c√°ch ƒë·ªÉ tr√°nh sqrt s·ªõm
                    if (d2 < r2) {
                        // Ch·ªâ sqrt khi ch·∫Øc ch·∫Øn trong ph·∫°m vi
                        const d = Math.sqrt(d2) || 1e-6; // tr√°nh chia 0
                        const invD = 1 / d;

                        // L·ª±c h√∫t gi·∫£m theo kho·∫£ng c√°ch: (1 - d/R) * pullSpeed * Z_PULL_MULT
                        const strength = (1 - d * invR) * pullSpeed * Z_PULL_MULT;

                        // ƒê·∫©y zombie v·ªÅ ph√≠a t√¢m (chu·∫©n ho√° vector ‚Üí kh√¥ng c·∫ßn atan2/cos/sin)
                        z.x += dx * invD * strength;
                        z.y += dy * invD * strength;

                        if (damageThisTick) {
                            dealDamageToZombie(z, hole.damage);
                        }
                    }
                }

                // --- H√∫t ƒë·∫°n ƒë·ªãch ---
                const cellB = gridB[idx];
                for (let bi = 0; bi < cellB.length; bi++) {
                    const b = cellB[bi];
                    if (!b.active) continue;

                    const dx = hx - b.x;
                    const dy = hy - b.y;
                    const d2 = dx * dx + dy * dy;

                    if (d2 < r2) {
                        const d = Math.sqrt(d2) || 1e-6;
                        const invD = 1 / d;
                        b.x += dx * invD * pullSpeed * B_PULL_MULT;
                        b.y += dy * invD * pullSpeed * B_PULL_MULT;

                        // ƒê·ªß g·∫ßn t√¢m ‚Üí thu h·ªìi/hu·ª∑
                        if (d < 20) {
                            releaseEnemyBullet(b);
                        }
                    }
                }
            }
        }

        // Di chuy·ªÉn h·ªë ƒëen (sau khi h√∫t), r·ªìi clamp bi√™n
        hole.x = hx + hole.dx;
        hole.y = hy + hole.dy;

        if (hole.x < wallThickness) hole.x = wallThickness;
        else if (hole.x > worldWidth - wallThickness) hole.x = worldWidth - wallThickness;

        if (hole.y < wallThickness) hole.y = wallThickness;
        else if (hole.y > worldHeight - wallThickness) hole.y = worldHeight - wallThickness;

        if (hole.tick % PARTICLE_INTERVAL === 0) {
            if (!globalThis.camera || isCircleVisible(hole.x, hole.y, pullRadius, globalThis.camera)) {
                createVortexParticle(hole.x, hole.y, pullRadius);
            }
        }
    }
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function moveTowards(obj, target, spd) {
  const ang = Math.atan2(target.y - obj.y, target.x - obj.x);
  obj.x += Math.cos(ang) * spd;
  obj.y += Math.sin(ang) * spd;
}
// Pet nh·∫∑t v·∫≠t ph·∫©m
function collectLoot() {
  const t = petRabbit && petRabbit.target;
  if (!t) return;

  // üß∞ Nh·∫∑t TRANG B·ªä (equipment)
  if (petRabbit.targetIsEquip) {
    // API t·ª± ki·ªÉm kho·∫£ng c√°ch & nh·∫∑t v√†o Equip.inventory, b·∫Øn ticker, set inactive
    if (window.EquipmentDropAPI && typeof window.EquipmentDropAPI.updateEquipDrops === 'function') {
      window.EquipmentDropAPI.updateEquipDrops(Date.now(), petRabbit.x, petRabbit.y);
    }
    // D·ªçn tr·∫°ng th√°i target
    petRabbit.target = null;
    petRabbit.targetIsEquip = false;
    return;
  }

  // üéí Nh·∫∑t ITEMS th∆∞·ªùng
  playSound('sfx-pickup', 0.5);
  switch (t.type) {
    case "lucky":        luckyBuffEndTime = Date.now() + 45000; queuePetLootPopup("üçÄ"); playSound('sfx-powerup', 0.8); break;
    case "power":        powerBuffEndTime = Date.now() + 45000; queuePetLootPopup("üçÅ"); playSound('sfx-powerup', 0.8); break;
    case "crazy":        crazyBuffEndTime = Date.now() + 45000; queuePetLootPopup("üçÇ"); playSound('sfx-powerup', 0.8); break;
    case "exp":          expBuffEndTime = Date.now() + 45000; queuePetLootPopup("üåø"); playSound('sfx-powerup', 0.8); break;
    case "magnet":       magnetBuffEndTime = Date.now() + 30000; queuePetLootPopup("üß≤"); playSound('sfx-powerup', 0.8); break;
    case "crazymadnesstime":
                         crazyMadnessTimeEndTime = Date.now() + 30000; queuePetLootPopup("üí¢"); playSound('sfx-powerup', 0.8); break;
    case "critRateBuff": addCritRateBuff(0.15, 45000); queuePetLootPopup("‚ú®"); playSound('sfx-powerup', 0.8); break;
    case "critDmgBuff":  addCritDmgBuff(0.25, 45000); queuePetLootPopup("üí•"); playSound('sfx-powerup', 0.8); break;
    case "potion": {
      const baseHeal  = getRandomInt(10, 20);
      const bonusHeal = Math.round((player.level + wave) * 1.5);
      const totalHeal = baseHeal + bonusHeal;
      player.hearts   = Math.min(player.maxHearts, player.hearts + totalHeal);
      createHealImpactEffect(player, totalHeal);
      queuePetLootPopup("üíä");
      playSound('sfx-powerup', 0.8);
      break;
    }
    case "secret":   activateSecretItem(t); queuePetLootPopup("‚ùì"); playSound('sfx-powerup', 0.8); break;
    case "expBonus": activateExpBonusItem(); queuePetLootPopup("üåü"); playSound('sfx-powerup', 0.8); break;
    case "coin":     player.coins++; queuePetLootPopup("ü™ô"); playSound('sfx-pickup-coin', 0.5); break;
    case "energy":   player.energy++; queuePetLootPopup("‚ö°"); break;
    case "mana":     player.mana++; queuePetLootPopup("üí†"); break;
    case "hp":       player.hearts = Math.min(player.maxHearts, player.hearts + 1); queuePetLootPopup("‚ù§Ô∏è"); break;
    case "box":      openItemBox(); break;
  }

  t.active = false;
  petRabbit.target = null;
  petRabbit.targetIsEquip = false;
}

function giveUp() {
  lastGiveUpId   = petRabbit.target.id;   // ghi nh·ªõ id
  lastGiveUpTime = Date.now();
  petRabbit.target = null;
  showWarning("üê∞ ƒë·ª´ng ƒëi xa, quay v·ªÅ!");
}
// C·∫≠p nh·∫≠t k·ªπ nƒÉng ƒëao xoay
function updateBlades() {
    if (!swordActive) return;

    const now = Date.now();
    const MAX_SEEK_RADIUS = 450;
    const BLADE_FLY_SPEED = 4;
    const BLADE_LAUNCH_INTERVAL = 100;

    if (now - lastBladeLaunchTime > BLADE_LAUNCH_INTERVAL) {
        const bladeToLaunch = swords[nextBladeToAttack];
        if (bladeToLaunch && bladeToLaunch.state === 'orbiting') {
            const target = zombies.find(z => z.active && distance(player, z) < MAX_SEEK_RADIUS);
            if (target) {
                bladeToLaunch.state = 'seeking';
                bladeToLaunch.hitZombies.clear();
                bladeToLaunch.pierceCount = 0;
            }
        }
        nextBladeToAttack = (nextBladeToAttack + 1) % swords.length;
        lastBladeLaunchTime = now;
    }

    const formationAngle = (now / 1500);
    swords.forEach(s => {
        switch (s.state) {
            case 'orbiting':
                s.angle = s.homeAngle + formationAngle;
                s.x = player.x + Math.cos(s.angle) * s.orbitRadius;
                s.y = player.y + Math.sin(s.angle) * s.orbitRadius;
                
// GI·∫¢M T·∫¢I: d√πng kho·∫£ng c√°ch b√¨nh ph∆∞∆°ng + gi·ªõi h·∫°n s·ªë ki·ªÉm tra m·ªói frame
{
  const HIT_R2 = 20 * 20;         // b√°n k√≠nh va ch·∫°m^2
  let checks = 0, MAX_CHECKS = 24; // t·ªëi ƒëa 24 zombie/frame/ƒëao

  for (let j = 0; j < zombies.length && checks < MAX_CHECKS; j++) {
    const z = zombies[j];
    if (!z || !z.active) continue;

    // Ch·ªâ t√≠nh d2 (kh√¥ng sqrt)
    const dx = s.x - z.x, dy = s.y - z.y;
    if ((dx * dx + dy * dy) < HIT_R2 && (!z.bladeOrbitCooldown || now > z.bladeOrbitCooldown)) {
      const orbitingDamage = Math.max(1, Math.round(skillUpgrades.bladeDamage));
      dealDamageToZombie(z, orbitingDamage);
      z.bladeOrbitCooldown = now + 100;
    }
    checks++;
  }
}
                break;

            case 'seeking':
                let nearestTarget = null;
                let minDistance = Infinity;
                zombies.forEach(z => {
                    if (z.active && !s.hitZombies.has(z)) {
                        const d = distance(s, z);
                        if (d < minDistance) { minDistance = d; nearestTarget = z; }
                    }
                });
                if (nearestTarget) {
                    const angle = Math.atan2(nearestTarget.y - s.y, nearestTarget.x - s.x);
                    s.x += Math.cos(angle) * BLADE_FLY_SPEED;
                    s.y += Math.sin(angle) * BLADE_FLY_SPEED;
                }
                zombies.forEach(z => {
// D√πng kho·∫£ng c√°ch b√¨nh ph∆∞∆°ng ƒë·ªÉ tr√°nh sqrt
const dx = s.x - z.x, dy = s.y - z.y;
if (z.active && !s.hitZombies.has(z) && (dx*dx + dy*dy) < (20*20)) {
  const originalDamage = skillUpgrades.bladeDamage + playerUpgrades.damageBoost;
  let finalDamage;

  if (s.pierceCount === 0) {
    finalDamage = Math.max(1, Math.round(originalDamage));
                        }

                        dealDamageToZombie(z, finalDamage);
                        
                        s.hitZombies.add(z);
                        s.pierceCount++;
                        const impactExplosion = getExplosion(z.x, z.y);
                        impactExplosion.life = 10;
                        explosions.push(impactExplosion);
                    }
                });
                if (s.pierceCount >= 5 || distance(s, player) > MAX_SEEK_RADIUS || !nearestTarget) {
                    s.state = 'returning';
                }
                break;

            case 'returning':
                const angleToPlayer = Math.atan2(player.y - s.y, player.x - s.x);
                s.x += Math.cos(angleToPlayer) * 10;
                s.y += Math.sin(angleToPlayer) * 10;
                if (distance(s, player) < s.orbitRadius) {
                    s.state = 'orbiting';
                }
                break;
        }
    });
}

// Danh s√°ch lo·∫°i t√†i nguy√™n: t·∫°o 1 l·∫ßn, t√°i s·ª≠ d·ª•ng
const SUPPLY_RESOURCE_TYPES = ["coin", "hp", "mana", "energy"];

/** K√≠ch ho·∫°t s·ª± ki·ªán: t·∫°o 3‚Äì7 ki·ªán ü™Ç r∆°i t·ª´ tr√™n xu·ªëng */
function triggerSupplyDrop() {
  playSound("sfx-nuke-fall", 0.4);
  showWarning("H√†ng ti·∫øp t·∫ø ƒëang ƒë·∫øn!");

  const dropCount = getRandomInt(3, 7);

  // Ch·ªët snapshot camera/m√†n h√¨nh t·∫°i th·ªùi ƒëi·ªÉm spawn
  const camX = camera.x, camY = camera.y;
  const viewW = canvas.width, viewH = canvas.height;

  for (let i = 0; i < dropCount; i++) {
    supplyDrops.push({
      // id: performance.now() + i, // tu·ª≥ ch·ªçn n·∫øu b·∫°n mu·ªën debug
      x: camX + Math.random() * viewW,
      y: camY - 50,
      speedY: 1 + Math.random() * 0.5, // ~1..1.5 px/frame @60fps
      finalY: camY + viewH - (50 + Math.random() * 50), // ‚Äúch·∫°m ƒë·∫•t‚Äù g·∫ßn ƒë√°y m√†n h√¨nh
      active: true
    });
  }
}

/** C·∫≠p nh·∫≠t r∆°i cho c√°c ki·ªán h√†ng (g·ªçi trong update() m·ªói frame) */
// Kh√¥ng d√πng dt: t·ªëc ƒë·ªô r∆°i t√≠nh theo "m·ªói frame" (~60fps)
function updateSupplyDrops() {
  for (let i = supplyDrops.length - 1; i >= 0; i--) {
    const drop = supplyDrops[i];

    // N·∫øu c√≥ flag inactive th√¨ xo√° nhanh (swap-remove)
    if (!drop.active) {
      const last = supplyDrops.pop();
      if (i < supplyDrops.length) supplyDrops[i] = last;
      continue;
    }

    // R∆°i m·ªói frame (kh√¥ng scale theo th·ªùi gian)
    drop.y += drop.speedY; // speedY ~ 1..1.5 ƒë√£ set l√∫c spawn

    // Ch·∫°m "ƒë·∫•t" (finalY ch·ªët t·∫°i th·ªùi ƒëi·ªÉm spawn)
    if (drop.y > drop.finalY) {
      playSound("sfx-supply-drop-item", 0.5);

      const resourceCount = getRandomInt(2, 10);
      for (let j = 0; j < resourceCount; j++) {
        const type = SUPPLY_RESOURCE_TYPES[(Math.random() * SUPPLY_RESOURCE_TYPES.length) | 0];
        const offsetX = (Math.random() - 0.5) * 60;
        const offsetY = (Math.random() - 0.5) * 60;
        items.push({
          x: drop.x + offsetX,
          y: drop.y + offsetY,
          type,
          active: true,
          bornAt: Date.now(),
        });
      }

      // Xo√° ph·∫ßn t·ª≠ ƒë√£ ho√†n t·∫•t (swap-remove)
      drop.active = false;
      const last = supplyDrops.pop();
      if (i < supplyDrops.length) supplyDrops[i] = last;
    }
  }
}

/** V·∫Ω ki·ªán h√†ng ‚Äì c√≥ culling ƒë·ªÉ gi·∫£m overdraw */
function drawSupplyDrops() {
  ctx.font = "2rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  const left   = camera.x - 64;
  const right  = camera.x + canvas.width  + 64;
  const top    = camera.y - 64;
  const bottom = camera.y + canvas.height + 64;

  for (let i = 0; i < supplyDrops.length; i++) {
    const d = supplyDrops[i];
    if (d.x >= left && d.x <= right && d.y >= top && d.y <= bottom) {
      ctx.fillText("ü™Ç", d.x, d.y);
    }
  }
}

//üîÑ 8. C·∫≠p nh·∫≠t logic game (Main loop logic)

/* ---------- C√ÅC BI·∫æN CACHE UI NH·∫∏ ---------- */
const __uiCache = {
  waveText: "",
  bladeText: "",
  swordText: "",
  fireText: "",
  iceText: "",
  petText: "",
  auraText: "",
};

/* ---------- TI·ªÜN √çCH NHANH, KH√îNG R√ÅC ---------- */
function removeAtSwap(arr, i) { const n = arr.length - 1; if (i < 0 || i > n) return; if (i !== n) arr[i] = arr[n]; arr.pop(); }
function clamp(v, a, b) { return v < a ? a : v > b ? b : v; }
function d2(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return dx*dx + dy*dy; }
function setTextOnce(el, txt, cacheKey) { if (!el) return; if (__uiCache[cacheKey] !== txt) { el.innerText = txt; __uiCache[cacheKey] = txt; } }
function nearestZombieInRange(srcx, srcy, maxR) {
  const maxR2 = maxR * maxR; let best = null, bestD2 = maxR2;
  for (let i = 0; i < zombies.length; i++) {
    const z = zombies[i]; if (!z.active) continue;
    const dz2 = d2(srcx, srcy, z.x, z.y);
    if (dz2 < bestD2) { bestD2 = dz2; best = z; }
  }
  return best;
}
/* Top-K nearby (K nh·ªè, v√≠ d·ª• s·ªë clone ‚â§ 5) ‚Äî ch√®n tuy·∫øn t√≠nh, kh√¥ng sort to√†n c·ª•c */
function kNearestZombiesByPlayer(k, maxR) {
  const K = Math.max(0, k|0); if (K === 0) return [];
  const maxR2 = maxR > 0 ? maxR*maxR : Infinity;
  const idx = new Array(K).fill(-1), dist = new Array(K).fill(Infinity);
  for (let i = 0; i < zombies.length; i++) {
    const z = zombies[i]; if (!z.active) continue;
    const dz2 = d2(player.x, player.y, z.x, z.y);
    if (dz2 >= maxR2) continue;
    // ch√®n v√†o m·∫£ng top-K (nh·ªè), d·ªãch tr√°i
    let pos = K - 1; if (dz2 < dist[pos]) { dist[pos] = dz2; idx[pos] = i;
      while (pos > 0 && dist[pos] < dist[pos-1]) { // bubble tr√°i
        const td = dist[pos-1]; dist[pos-1] = dist[pos]; dist[pos] = td;
        const ti = idx[pos-1]; idx[pos-1] = idx[pos]; idx[pos] = ti; pos--;
      }
    }
  }
  const out = [];
  for (let j = 0; j < K; j++) if (idx[j] !== -1) out.push(zombies[idx[j]]);
  return out;
}

/* ========== 1) BUFF CORE (power/crazy/lucky/exp/magnet) + halo xoay ========== */
function sysUpdateBuffCore(now) {
  buffEffects.power.active  = now < powerBuffEndTime;
  buffEffects.crazy.active  = now < crazyBuffEndTime;
  buffEffects.lucky.active  = now < luckyBuffEndTime;
  buffEffects.exp.active    = now < expBuffEndTime;
  buffEffects.magnet.active = now < magnetBuffEndTime;
  buffEffects.crazymadness.active = now < crazyMadnessTimeEndTime;
  _compactTimedBuffs(_critRateBuffs, now);
  _compactTimedBuffs(_critDmgBuffs, now);
  buffEffects.critRate.active = _critRateBuffs.length > 0;
  buffEffects.critDmg.active = _critDmgBuffs.length > 0;

  for (const k in buffEffects) { const b = buffEffects[k]; if (b && b.active) b.angle += 0.01; }
}

/* ========== 2) PLAYER LASERS (gi·∫£m life, remove O(1)) ========== */
function sysUpdatePlayerLasers() {
  for (let i = playerLasers.length - 1; i >= 0; i--) {
    const l = playerLasers[i]; l.life--; if (l.life <= 0) removeAtSwap(playerLasers, i);
  }
}

/* ========== 3) WAVE TIMER + BIG BOSS (UI + respawn) ========== */
function sysUpdateWaveAndBoss(now) {
  if (!lastWaveTime) return;
  const elWave = document.getElementById("waveTimerDisplay");
  const elapsed = (now - lastWaveTime) / 1000;
  let remaining = waveTime - elapsed; if (remaining < 0) remaining = 0;

  const min = (remaining / 60) | 0, sec = (remaining | 0) % 60, cs = Math.floor((remaining - (remaining | 0)) * 100);
  setTextOnce(elWave, `${min.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')}:${cs.toString().padStart(2,'0')}`, "waveText");

  if (remaining <= 0) {
    wave++; pendingWave = wave; if (typeof showUpgradePopup === "function") showUpgradePopup();
    globalThis.wave = wave;  // ƒê·ªìng b·ªô wave ra global ƒë·ªÉ m·ªçi n∆°i (k·ªÉ c·∫£ popup hover) ƒë·ªçc ƒë∆∞·ª£c ngay
    if (wave === 5) { bigBossRespawnTimer = 0; lastBigBossTimerUpdate = performance.now(); }
    lastWaveTime = now; if (typeof updateWaveUI === "function") updateWaveUI();
  }

  // BigBoss UI + respawn (ƒë·∫øm th·ª±c)
  let hasBoss = false;
  for (let i = 0; i < zombies.length; i++) { const z = zombies[i]; if (z.active && z.isBigBoss) { hasBoss = true; break; } }
  const box = document.getElementById("bigBossRespawnDisplay"); if (box) box.style.display = "block";
  if (wave < 5) { if (box) setTextOnce(box, "BigBoss: zZzz..", "bossText"); return; }

  if (!lastBigBossTimerUpdate) lastBigBossTimerUpdate = performance.now();
  if (!hasBoss) {
    const nowp = performance.now(); const dt = (nowp - lastBigBossTimerUpdate) / 1000;
    if (dt > 0) bigBossRespawnTimer += dt; lastBigBossTimerUpdate = nowp;
    const remain = Math.max(0, Math.ceil(bigBossRespawnInterval - bigBossRespawnTimer));
    if (box) setTextOnce(box, remain > 0 ? `BigBoss: -${remain.toString().padStart(3,'0')}s-` : "BigBoss: READY", "bossText");
    if (bigBossRespawnTimer >= bigBossRespawnInterval && typeof spawnBigBoss === "function") { spawnBigBoss(); bigBossRespawnTimer = 0; }
  } else {
    if (box) setTextOnce(box, "BigBoss: living", "bossText");
    bigBossRespawnTimer = 0; lastBigBossTimerUpdate = performance.now();
  }
}

/* ========== 4) SWORD (üî™) ‚Äî v√≤ng l∆∞·ª°i ƒëao auto 30s + updateBlades() ========== */
function skillUpdateBladesUIAndSpawn(now) {
  if (!swordActive) return;
  if (now >= swordEndTime) {
    swordActive = false; swords.length = 0;
    const btn = document.getElementById("bladeBtn");
    if (btn) { btn.classList.remove("active"); btn.innerText = "üî™ ƒêao"; }
    return;
  }
  // UI
  const remain = Math.ceil((swordEndTime - now) / 1000);
  const btn = document.getElementById("bladeBtn");
  if (btn) setTextOnce(btn, `üî™ ${remain}s`, "bladeText");

  // Spawn n·∫øu ch∆∞a c√≥
  if (swords.length === 0) {
    const count = skillUpgrades.bladeCount|0; nextFireIndex = 0;
    for (let i = 0; i < count; i++) {
      const s = getSword(); s.angle = (2*Math.PI / count) * i; s.radius = 60;
      s.state = 'charging'; s.chargeFrame = 90; s.fireDelay = 20 + i * 10; s.fireOrder = i;
      swords.push(s);
    }
  }
  // v√≤ng ƒëi·ªÅu khi·ªÉn l∆∞·ª°i ƒëao g·ªëc c·ªßa b·∫°n:
  if (typeof updateBlades === "function") updateBlades();
}

/* ========== 5) BLADE RAIN (‚öîÔ∏è) ‚Äî m√¢y th·∫£ ki·∫øm c√≥ m·ª•c ti√™u ========== */
function skillUpdateBladeRain(now) {
  if (!bladeActive) return;
  if (now >= bladeEndTime) {
    bladeActive = false; downwardSwords.length = 0; swordRainClouds.length = 0;
    const btn = document.getElementById("swordBtn"); if (btn) { btn.classList.remove("active"); btn.innerText = "‚öîÔ∏è Ki·∫øm"; }
    return;
  }
  // UI
  const btn = document.getElementById("swordBtn"); if (btn) setTextOnce(btn, `‚öîÔ∏è ${Math.ceil((bladeEndTime - now)/1000)}s`, "swordText");

  // M√¢y tr√¥i + th·∫£ ki·∫øm (kh√¥ng forEach)
  const SWORD_DROP_INTERVAL = Math.max(100, 1200 - (skillUpgrades.swordLevel * 100));
  for (let i = 0; i < swordRainClouds.length; i++) {
    const c = swordRainClouds[i];
    // drift
    c.relativeX += c.driftSpeed;
    if (c.relativeX < 50 || c.relativeX > canvas.width - 50) c.driftSpeed *= -1;
    // drop
    if (now > c.nextDropTime) {
      downwardSwords.push({ x: camera.x + c.relativeX, y: camera.y + c.relativeY + 20, speed: 4 + skillUpgrades.swordLevel * 0.2, vx: (Math.random()-0.5)*2 });
      c.nextDropTime = now + SWORD_DROP_INTERVAL + Math.random()*200;
    }
  }
  // Ki·∫øm r∆°i
  for (let i = downwardSwords.length - 1; i >= 0; i--) {
    const s = downwardSwords[i]; s.y += s.speed; s.x += s.vx;
    if (s.y > camera.y + canvas.height + 30) { removeAtSwap(downwardSwords, i); continue; }
    for (let j = 0; j < zombies.length; j++) {
      const z = zombies[j]; if (!z.active) continue;
      if (d2(s.x, s.y, z.x, z.y) < 400) { // 20^2
        if (!z.swordCooldown || now > z.swordCooldown) {
          dealDamageToZombie(z, skillUpgrades.swordDamage + playerUpgrades.damageBoost);
          z.swordCooldown = now + 100;
        }
      }
    }
  }
}

/* ========== 6) PLAYER MOVE + CAMERA + TOUCH ========== */
function sysUpdateMovementAndCamera() {
  let mx = 0, my = 0;
  if (keys.w) my -= 1; if (keys.s) my += 1; if (keys.a) mx -= 1; if (keys.d) mx += 1;
  if (mx !== 0 || my !== 0) {
    const len = Math.hypot(mx, my); mx /= len; my /= len;
    let v = player.speed;
    if (disguiseActive) v *= 1.5;
    if (supportAuraActive) v *= 1.2;
    player.x += mx * v; player.y += my * v;
    player.x = clamp(player.x, wallThickness + player.size, worldWidth - wallThickness - player.size);
    player.y = clamp(player.y, wallThickness + player.size, worldHeight - wallThickness - player.size);
    camera.x = clamp(player.x - canvas.width/2, 0, worldWidth - canvas.width);
    camera.y = clamp(player.y - canvas.height/2, 0, worldHeight - canvas.height);
  }
  // touch
  if (touchStartX !== null && touchMoveX !== null) {
    let dx = touchMoveX - touchStartX, dy = touchMoveY - touchStartY;
    const len = Math.hypot(dx, dy);
    if (len > 10) { dx /= len; dy /= len; player.x += dx * player.speed; player.y += dy * player.speed; }
  }
}

/* ========== 7) K·ª∏ NƒÇNG L·ª¨A/BƒÇNG ‚Äî orbit + tia ph·ª• (kh√¥ng filter/sort) ========== */
function skillUpdateFireIce(now) {
  // üî• Fire
  if (fireActive) {
    const fireBtn = document.getElementById("fireBtn");
    const rem = Math.ceil((fireEndTime - now)/1000);
    if (rem > 0) setTextOnce(fireBtn, `üî• ${rem}s`, "fireText");
    else {
      fireActive = false; for (let i = 0; i < fireballs.length; i++) releaseFireball(fireballs[i]);
      fireballs.length = 0; if (fireBtn) { fireBtn.innerText = "üî• L·ª≠a"; fireBtn.classList.remove("active"); }
    }
  }
  for (let i = 0; i < fireballs.length; i++) {
    const f = fireballs[i]; f.angle += 0.05;
    f.x = player.x + Math.cos(f.angle) * f.radius; f.y = player.y + Math.sin(f.angle) * f.radius;
    if (!f.nextSparkTime) f.nextSparkTime = 0;
    if (now > f.nextSparkTime) {
      f.nextSparkTime = now + 1500;
      // nearest trong 200
      const t = nearestZombieInRange(f.x, f.y, 200);
      if (t) {
        const sparkDamage = Math.max(1, Math.round((skillUpgrades.fireDamage + playerUpgrades.damageBoost) * 0.5));
        particles.push({ type: 'fire_spark', x: f.x, y: f.y, target: t, speed: 2, damage: sparkDamage });
      }
    }
    // ch·∫°m tr·ª±c ti·∫øp
    for (let j = 0; j < zombies.length; j++) {
      const z = zombies[j]; if (!z.active) continue;
      if (d2(f.x, f.y, z.x, z.y) < 25*25) {
        if (!z.fireCooldown || now > z.fireCooldown) {
          dealDamageToZombie(z, skillUpgrades.fireDamage + playerUpgrades.damageBoost);
          z.fireCooldown = now + 100; z.onFireUntil = now + 400; z.burnEndTime = now + 3000;
          z.state = "wandering"; z.wanderTime = now + 3000 + Math.random()*2000; z.wanderAngle = Math.random()*Math.PI*2;
        }
      }
    }
  }

  // ‚ùÑÔ∏è Ice
  if (iceActive) {
    const iceBtn = document.getElementById("iceBtn");
    const rem = Math.ceil((iceEndTime - now)/1000);
    if (rem > 0) setTextOnce(iceBtn, `‚ùÑÔ∏è ${rem}s`, "iceText");
    else {
      iceActive = false; for (let i = 0; i < iceballs.length; i++) releaseIceball(iceballs[i]);
      iceballs.length = 0; if (iceBtn) { iceBtn.innerText = "‚ùÑÔ∏è BƒÉng"; iceBtn.classList.remove("active"); }
    }
  }
  for (let i = 0; i < iceballs.length; i++) {
    const f = iceballs[i]; f.angle += 0.03;
    f.x = player.x + Math.cos(f.angle) * f.radius; f.y = player.y + Math.sin(f.angle) * f.radius;
    if (!f.nextShardTime) f.nextShardTime = 0;
    if (now > f.nextShardTime) {
      f.nextShardTime = now + 2000;
      const t = nearestZombieInRange(f.x, f.y, 250);
      if (t) {
        const shardDamage = Math.max(1, Math.round((skillUpgrades.iceDamage + playerUpgrades.damageBoost) * 0.5));
        particles.push({ type: 'ice_shard', x: f.x, y: f.y, target: t, speed: 2, damage: shardDamage });
      }
    }
    // ch·∫°m tr·ª±c ti·∫øp
    for (let j = 0; j < zombies.length; j++) {
      const z = zombies[j]; if (!z.active) continue;
      if (d2(f.x, f.y, z.x, z.y) < 25*25) {
        if (!z.iceCooldown || now > z.iceCooldown) {
          dealDamageToZombie(z, skillUpgrades.iceDamage + playerUpgrades.damageBoost);
          z.iceCooldown = now + 100; z.onIceUntil = now + 400; z.slowEndTime = now + 3000;
          z.state = "wandering"; z.wanderTime = now + 3000 + Math.random()*2000; z.wanderAngle = Math.random()*Math.PI*2;
        }
      }
    }
  }
}

/* ========== 8) PET UI NH·∫∏ ========== */
function sysUpdatePetUI(now) {
  if (!petActive) return;
  const rem = Math.ceil((petEndTime - now)/1000), btn = document.getElementById("PetBtn");
  if (rem > 0) setTextOnce(btn, `üê∞ ${rem}s`, "petText");
  else if (btn) { btn.innerText = "üê∞ Pet"; btn.classList.remove("active"); }
}

/* ========== 9) BULLETS (player/clone/fairy/pet) & ENEMY BULLETS ========== */
function sysUpdateBullets() {
  for (let i = 0; i < bullets.length; i++) {
    const b = bullets[i]; if (!b.active) continue;
// Ch·ªâ ch·∫∑n khi zone ƒëang ACTIVE
if (safeZones.some(zone => zone.active && distance(b, zone) < zone.radius)) {
  createShieldImpactEffect(b.x, b.y);
  releaseEnemyBullet(b);
  continue;
}
    // qu·ªπ ƒë·∫°o
    if (b.curveMode) {
      b.curveRadius += 0.6; b.angle += b.curveSpeed * 0.5;
      b.x = player.x + Math.cos(b.angle) * b.curveRadius; b.y = player.y + Math.sin(b.angle) * b.curveRadius;
    } else if (b.zigzagMode) {
      b.travel += b.speed; const off = Math.sin(b.travel * b.oscillateSpeed + b.oscillatePhase) * b.oscillateAmplitude, ang = b.baseAngle;
      b.x = b.startX + Math.cos(ang)*b.travel - Math.sin(ang)*off; b.y = b.startY + Math.sin(ang)*b.travel + Math.cos(ang)*off;
    } else if (b.spiralForwardMode) {
      b.travel += b.speed; const ang = b.baseAngle;
      const cx = b.startX + Math.cos(ang)*b.travel, cy = b.startY + Math.sin(ang)*b.travel;
      const offAng = b.spiralPhase + b.travel*b.spiralSpeed;
      b.x = cx + Math.cos(offAng)*b.spiralRadius; b.y = cy + Math.sin(offAng)*b.spiralRadius;
    } else { b.x += b.dx * b.speed; b.y += b.dy * b.speed; }

    // va ch·∫°m zombies
for (let j = 0; j < zombies.length; j++) {
  const z = zombies[j]; if (!z.active) continue;
  if (d2(b.x, b.y, z.x, z.y) < 20*20) {

    const now = Date.now();

    // Cooldown CHUNG cho m·ªçi lo·∫°i ƒë·∫°n (gi·ªØ nguy√™n logic c·ªßa b·∫°n)
    if (z.bulletHitCooldown && now < z.bulletHitCooldown) continue;

    if (b.isFairyBullet) { // fairy
      if (b.effect === 'sleep') { z.isSleeping = true; z.sleepUntil = now + 3000; }
      else if (b.effect === 'wandering') { z.state = 'wandering'; z.wanderTime = now + 3000; }
      z.isWeakened = true; z.weakenEndTime = now + 5000; for (let k = 0; k < 4; k++) createFairyHitParticle(z);
      z.bulletHitCooldown = now + 100;
      releaseBullet(b); break;

    } else if (b.isPetBullet) { // pet
      // üîΩ √°p CRIT v√†o s√°t th∆∞∆°ng pet
      const petDmg = calcCritDamage(b.customDmg, now);
      dealDamageToZombie(z, petDmg);
      z.stunnedByThunder = true; z.stunnedThunderUntil = now + b.stunDuration;
      z.bulletHitCooldown = now + 100;
      releaseBullet(b); break;

} else { // player/clone b√¨nh th∆∞·ªùng
  // ‚ûï th·ªùi gian an to√†n: d√πng _now n·∫øu c√≥, else Date.now()
  const now = (typeof _now === 'number') ? _now : Date.now();

  let dmg = (b.customDmg !== undefined) ? b.customDmg : (playerUpgrades.damageBoost || 1);

  if (b.isIceArrow) {
    if (!b.iceHits) b.iceHits = 0;
    const baseDmg = (b.iceHits === 0) ? dmg : Math.max(1, Math.round(dmg * 0.5));

    // üîΩ √°p CRIT v√†o Ice Arrow
    const critDmg = calcCritDamage(baseDmg, now);

    // ‚ûï hi·ªán ‚ÄúCrit!‚Äù n·∫øu c√≥ ch√≠ m·∫°ng (kh√¥ng h·ªìi m√°u)
    if (critDmg > baseDmg) {
      const r = z.radius || 15;
      healEffects.push({
      x: z.x + 28 + (Math.random() - 0.5) * 5, // V·ªã tr√≠ ngang ng·∫´u nhi√™n ƒë·ªÉ tr√°nh ch·ªìng l·∫•n
      y: z.y - z.radius - 15, // Hi·ªán ·ªü v·ªã tr√≠ cao h∆°n s·ªë s√°t th∆∞∆°ng m·ªôt ch√∫t
        life: 90, maxLife: 90,
        text: 'Crit!', delay: 0,
        color: 'orange'
      });
    }

    dealDamageToZombie(z, critDmg);
    if (typeof window.applyOnHitFromEquips === 'function') window.applyOnHitFromEquips(z, now, b.x, b.y);

    b.iceHits++;
    z.bulletHitCooldown = now + 100; // cooldown chung
    // piercing: kh√¥ng release

  } else {
    // üîΩ √°p CRIT v√†o ƒë·∫°n th∆∞·ªùng
    const critDmg = calcCritDamage(dmg, now);

    // ‚ûï hi·ªán ‚ÄúCrit!‚Äù n·∫øu c√≥ ch√≠ m·∫°ng (kh√¥ng h·ªìi m√°u)
    if (critDmg > dmg) {
      const r = z.radius || 15;
      healEffects.push({
      x: z.x + 28 + (Math.random() - 0.5) * 5, // V·ªã tr√≠ ngang ng·∫´u nhi√™n ƒë·ªÉ tr√°nh ch·ªìng l·∫•n
      y: z.y - z.radius - 15, // Hi·ªán ·ªü v·ªã tr√≠ cao h∆°n s·ªë s√°t th∆∞∆°ng m·ªôt ch√∫t
        life: 90, maxLife: 90,
        text: 'Crit!', delay: 0,
        color: 'orange'
      });
    }

    dealDamageToZombie(z, critDmg);
    if (typeof window.applyOnHitFromEquips === 'function') window.applyOnHitFromEquips(z, now, b.x, b.y);

    z.bulletHitCooldown = now + 100;

    if (!b.piercing) { releaseBullet(b); break; }
  }
}
}
}

const buffer = 50;
if (b.x < camera.x - buffer || 
    b.x > camera.x + canvas.width + buffer ||
    b.y < camera.y - buffer || 
    b.y > camera.y + canvas.height + buffer) {
  releaseBullet(b);
}
}
}
/* ====== CRIT SYSTEM (rate & dmg, c√≥ th·ªùi h·∫°n) ====== */

// Gi·ªõi h·∫°n & m·∫∑c ƒë·ªãnh buff crit rate, crit dmg
const CRIT_DMG_CAP = 9.00;   // Gi·ªõi h·∫°n t·ªëi ƒëa +400%
const CRIT_RATE_CAP = 0.75;   // 75%
let   baseCritRate   = 0.00;  // 0% (c√≥ th·ªÉ tƒÉng khi l√™n c·∫•p vƒ©nh vi·ªÖn n·∫øu mu·ªën)
let   baseCritDmg    = 0.50;  // +50%  => t·ª©c l√† multiplier = 1 + 0.50 = 1.5x

// Buff t·∫°m th·ªùi mua trong shop / nh·∫≠n khi l√™n c·∫•p
const _critRateBuffs = [];     // { value: 0.15, until: ms }
const _critDmgBuffs  = [];     // { value: 0.25, until: ms }

// N√©n m·∫£ng t·∫°i ch·ªó (kh√¥ng t·∫°o m·∫£ng m·ªõi)
function _compactTimedBuffs(arr, now) {
  let w = 0;
  for (let i = 0; i < arr.length; i++) {
    const it = arr[i];
    if (it && it.until > now) arr[w++] = it;
  }
  arr.length = w;
}

// API th√™m buff (mua trong shop / nh·∫≠n khi l√™n c·∫•p)
function addCritRateBuff(inc, durationMs) {
  const now = Date.now();
  _critRateBuffs.push({ value: inc, until: now + durationMs });
}
function addCritDmgBuff(inc, durationMs) {
  const now = Date.now();
  _critDmgBuffs.push({ value: inc, until: now + durationMs });
}

// L·∫•y ch·ªâ s·ªë hi·ªán h√†nh (g·ªôp base + buff c√≤n h·∫°n)
function getCritRate(now) {
  let sum = baseCritRate;
  _compactTimedBuffs(_critRateBuffs, now);
  for (let i = 0; i < _critRateBuffs.length; i++) sum += _critRateBuffs[i].value;
  // K·∫πp tr·∫ßn 70%
  return (sum > CRIT_RATE_CAP) ? CRIT_RATE_CAP : (sum < 0 ? 0 : sum);
}
function getCritDmg(now) {
  let sum = baseCritDmg;
  _compactTimedBuffs(_critDmgBuffs, now);
  for (let i = 0; i < _critDmgBuffs.length; i++) sum += _critDmgBuffs[i].value;
  return Math.max(0, Math.min(sum, CRIT_DMG_CAP));
}

// T√≠nh damage ƒë√£ √°p CRIT. 
// Quy ∆∞·ªõc: Crit DMG = +X% => multiplier = 1 + X (vd 50% => 1.5x)
function calcCritDamage(base, now) {
  const rate = getCritRate(now);     // 0..0.7
  if (rate > 0 && Math.random() < rate) {
    const mult = 1 + getCritDmg(now);  // v√≠ d·ª• 1 + 0.5 = 1.5x
    const v = Math.round(base * mult);
    return (v > 0 ? v : 1);
  }
  // kh√¥ng crit
  const b = base | 0;
  return (b > 0 ? b : 1);
}

function sysUpdateEnemyBullets(now) {
  for (let i = 0; i < enemyBullets.length; i++) {
    const b = enemyBullets[i]; if (!b.active) continue;
    b.x += b.dx * b.speed; b.y += b.dy * b.speed;
        // Ki·ªÉm tra va ch·∫°m v·ªõi T·∫§T C·∫¢ c√°c m√°i v√≤m
        if (safeZones.some(zone => zone.active && distance(b, zone) < zone.radius)) {
            createShieldImpactEffect(b.x, b.y);
            releaseEnemyBullet(b);
            continue;
        }
    // tr√∫ng player
    if (d2(b.x, b.y, player.x, player.y) < 15*15) {
      if (player.shieldActive) {
        playSound('sfx-shield-block', 0.3);
        const ang = Math.atan2(b.y - player.y, b.x - player.x), R = 48;
        const ix = player.x + Math.cos(ang)*R, iy = player.y + Math.sin(ang)*R;
        createShieldImpactEffect(ix, iy);
        releaseEnemyBullet(b); continue;
      }
      if (player.hitTimer === 0 && !player.safeInvincible) {
  let damage = b.damage || 1; if (supportAuraActive) damage *= 0.5;
  // TH√äM M·ªöI: T√≠nh s√°t th∆∞∆°ng cu·ªëi c√πng sau khi tr·ª´ gi√°p
  const finalDamage = Math.max(0, Math.round(damage) - (player.armor || 0));
  player.hearts -= finalDamage;
  player.hitTimer = 30;
  createDamageImpactEffect(player, finalDamage); // Hi·ªÉn th·ªã ƒë√∫ng s√°t th∆∞∆°ng ƒë√£ gi·∫£m
        if (player.hearts <= 0) handlePlayerDeath();
      }
      b.hit = true;
    }
    const oob = b.x < -50 || b.x > worldWidth + 50 || b.y < -50 || b.y > worldHeight + 50;
    if (b.hit || oob) releaseEnemyBullet(b);
  }
}

/* ========== 10) ZOMBIES CORE: tr·∫°ng th√°i, debuff, b·∫Øn tr·∫£, va ch·∫°m player ========== */
function sysUpdateZombies(now) {
    // KI·ªÇM TRA NG∆Ø·ªúI CH∆†I C√ì ·ªû B·∫§T K·ª≤ V√ôNG AN TO√ÄN N√ÄO KH√îNG
    const isPlayerSafe = safeZones.some(zone => zone.active && distance(player, zone) < zone.radius);

    for (let i = 0; i < zombies.length; i++) {
        const z = zombies[i];
        if (!z.active) continue;

    // N·∫øu ng∆∞·ªùi ch∆°i an to√†n, zombie s·∫Ω kh√¥ng ƒëu·ªïi theo n·ªØa
    if (isPlayerSafe && !z.isBoss) {
        // N·∫øu zombie ƒëang ƒëu·ªïi, chuy·ªÉn n√≥ sang tr·∫°ng th√°i ƒëi lang thang
        if (z.state === "chasing") {
            z.state = "wandering";
            z.wanderTime = now + 5000 + Math.random() * 5000; // Lang thang trong 5-10 gi√¢y
            z.wanderAngle = Math.random() * Math.PI * 2;
        }
    }

    // ƒê·∫©y zombie ra n·∫øu n√≥ v√¥ t√¨nh ƒëi v√†o m√°i v√≤m
        safeZones.forEach(zone => {
            if (zone.active && distance(z, zone) < zone.radius) {
                const angle = Math.atan2(z.y - zone.y, z.x - zone.x);
                z.x += Math.cos(angle) * 2;
                z.y += Math.sin(angle) * 2;
            }
        });
  }
  for (let i = 0; i < zombies.length; i++) {
    const z = zombies[i]; if (!z.active) continue;
    // T·ªêI ∆ØU: N·∫øu zombie ·ªü qu√° xa ng∆∞·ªùi ch∆°i, b·ªè qua vi·ªác c·∫≠p nh·∫≠t logic cho n√≥
    const activationRange = canvas.width; // Kho·∫£ng c√°ch zombie b·∫Øt ƒë·∫ßu "th·ª©c d·∫≠y"
    if (distance(player, z) > activationRange) {
        continue; // B·ªè qua t·∫•t c·∫£ logic b√™n d∆∞·ªõi cho con zombie n√†y
    }
    // burn tick m·ªói gi√¢y
    if (z.burnEndTime && now < z.burnEndTime) {
      if (!z.lastBurnTick || now - z.lastBurnTick > 1000) { z.lastBurnTick = now;
        const burnDmg = Math.max(1, Math.round((skillUpgrades.fireDamage + playerUpgrades.damageBoost) * 0.25));
        dealDamageToZombie(z, burnDmg);
      }
    } else if (z.burnEndTime) z.burnEndTime = null;

    // slow
    const slowed = z.slowEndTime && now < z.slowEndTime; if (z.slowEndTime && now >= z.slowEndTime) z.slowEndTime = null;

    // stun thunder
    if (z.stunnedByThunder && now < z.stunnedThunderUntil) continue; else if (z.stunnedByThunder && now >= z.stunnedThunderUntil) z.stunnedByThunder = false;
// Burn t·ª´ SPECIAL v≈© kh√≠
    if (z.weaponBurnUntil && now < z.weaponBurnUntil) {
      if (!z._wburnTick || now - z._wburnTick >= 1000) {
        z._wburnTick = now;
        const d = Math.max(1, Math.round((playerUpgrades.damageBoost || 1) * (z.weaponBurnDpsMul || 0.15)));
        dealDamageToZombie(z, d);
      }
    } else if (z.weaponBurnUntil && now >= z.weaponBurnUntil) {
      z.weaponBurnUntil = 0; z._wburnTick = 0;
    }
    // buff theo ng√†y/ƒë√™m
    if (isNight()) {
      if (!z.nightBuffApplied) { const bonus = (Math.random()*9|0) + 2; z.hp += bonus; z.baseHp += bonus; z.nightBuffApplied = true; }
    } else z.nightBuffApplied = false;

    if (currentDay > (z.lastDayBuffed || 0)) { const sb = Math.round(z.baseHp * 0.1); z.hp += sb; z.baseHp += sb; z.lastDayBuffed = currentDay; z.isBuffed = true; }

// regen/tr·ª´ m√°u 5s
if (!z.lastRegenTime || now - z.lastRegenTime > 5000) {
  if (isNight()) {
    // Khi regen, tƒÉng c·∫£ m√°u hi·ªán t·∫°i v√† m√°u t·ªëi ƒëa
    z.hp += 1;
    z.baseHp += 1;
    z.lastRegenTime = now;
    // Th√™m logic h·ªìi ph·ª•c 1% HP cho boss v√† big boss
    if (z.isBoss || z.isBigBoss) {
      const healAmount = Math.ceil(z.hp * 0.01);
      z.hp += healAmount;
      // ƒê·∫£m b·∫£o HP kh√¥ng v∆∞·ª£t qu√° baseHp
      if (z.hp > z.baseHp) {
        z.hp = z.baseHp;
      }
    }
  } else if (wave > 3) {
    // Khi m·∫•t m√°u, ch·ªâ tr·ª´ m√°u hi·ªán t·∫°i
    z.hp -= 1;
    z.lastRegenTime = now;
    if (z.hp <= 0 && !z._killed) killZombie(z);
  }
}

// H·ªìi ph·ª•c 1HP m·ªói 2s n·∫øu m√°u hi·ªán t·∫°i nh·ªè h∆°n m√°u t·ªëi ƒëa
if (isNight() && (!z.lastHPRegenTime || now - z.lastHPRegenTime > 2000)) {
  if (z.hp < z.baseHp) {
    z.hp += 1;
  }
  z.lastHPRegenTime = now;
}
    // state
    if (z.state === "wandering") {
      if (now >= z.wanderTime) { z.state = "chasing"; z.speed = z.baseSpeed; z.nextStateCheck = now + 3000; }
      else if (z.wanderBehavior === "move") {
        let v = z.speed; 
        if (wave === 1 && !z.isBoss && !z.isBigBoss) v *= 0.5; // gi·∫£m 50% ·ªü wave 1, 0.8 = gi·∫£m 20%
        if (slowed) v *= 0.5; z.x += Math.cos(z.wanderAngle) * v; z.y += Math.sin(z.wanderAngle) * v;
      }
    } else if (z.state === "chasing") {
      if (now >= (z.nextStateCheck || 0) && !z.isBoss) {
        z.behaviorCheckCounter = (z.behaviorCheckCounter || 0) + 1;
        if (z.behaviorCheckCounter >= 3) { z.showStatusIcon = Math.random() < 0.3; z.behaviorCheckCounter = 0; }
        if (Math.random() < 0.6) z.nextStateCheck = now + 3000;
        else {
          const pauseChance = isNight() ? 0.1 : 0.2;
          z.state = "wandering"; z.wanderTime = now + 1500 + Math.random()*8500; z.wanderAngle = Math.random()*Math.PI*2;
          z.speed = 0.15 + Math.random()*0.05; z.wanderBehavior = Math.random() < pauseChance ? "pause" : "move"; continue;
        }
      }
// ‚¨áÔ∏è M·ªöI: Boss/BigBoss n√© Safe Zone + ƒëi v√≤ng quanh bi√™n
const playerInSafe = safeZones.some(zone => distance(player, zone) < zone.radius);
let orbited = false;

if ((z.isBoss || z.isBigBoss) && safeZones.length) {
    for (let k = 0; k < safeZones.length; k++) {
        const zone = safeZones[k];
        const dz = distance(z, zone);
        const margin = (z.radius || 18) + 12;

        // N·∫øu ti·∫øn s√°t m√°i v√≤m (ho·∫∑c player ƒëang ·ªü trong m√°i v√≤m) -> ƒëi theo ti·∫øp tuy·∫øn
        if (dz < zone.radius + margin || (playerInSafe && dz < zone.radius + 140)) {
            // G√°n h∆∞·ªõng qu·ªπ ƒë·∫°o 1 l·∫ßn cho ·ªïn ƒë·ªãnh
            if (z.orbitDir == null) z.orbitDir = (Math.random() < 0.5 ? 1 : -1);
            const toCenter = Math.atan2(zone.y - z.y, zone.x - z.x);
            const tangent = toCenter + z.orbitDir * Math.PI / 2;

            let v2 = z.speed;
            if (!isNight()) v2 *= 0.7;
            if (slowed) v2 *= 0.5;

            // N·∫øu l·ª° chui v√†o trong, ƒë·∫©y nh·∫π ra bi√™n
            if (dz < zone.radius + (z.radius || 18) - 4) {
                z.x -= Math.cos(toCenter) * 2;
                z.y -= Math.sin(toCenter) * 2;
            }

            z.x += Math.cos(tangent) * v2;
            z.y += Math.sin(tangent) * v2;
            orbited = true;
            break;
        }
    }
}

if (!orbited) {
    const ang = Math.atan2(player.y - z.y, player.x - z.x);
    let v = z.speed; 
    if (wave === 1 && !z.isBoss && !z.isBigBoss) v *= 0.5;// gi·∫£m 50% ·ªü wave 1, 0.8 = gi·∫£m 20%
    if (!isNight()) v *= 0.7;
    if (slowed) v *= 0.5;
    z.x += Math.cos(ang) * v;
    z.y += Math.sin(ang) * v;
}
    }

    // b·∫Øn tr·∫£
    if (z.isBoss || z.type === "miniBoss") {
      if (!z.lastShoot) z.lastShoot = 0; if (now - z.lastShoot >= 8000) { z.lastShoot = now; shootEnemyBullet(z, 2, 0.8); }
    } else {
      if (!z.lastShoot) z.lastShoot = 0; if (now - z.lastShoot >= 60000) { z.lastShoot = now; shootEnemyBullet(z, 1 + Math.random()*0.5, 0.001); }
    }

    // va ch·∫°m player
    if (d2(z.x, z.y, player.x, player.y) < (z.radius + player.size) ** 2) {
      if (player.shieldActive) {
        const R = 48, repel = R + z.radius; const dist = Math.sqrt(d2(z.x, z.y, player.x, player.y));
        if (dist < repel) {
          const now2 = now; if (!window.lastShieldBlockSoundTime || now2 - lastShieldBlockSoundTime > 100) { playSound('sfx-shield-block', 0.3); window.lastShieldBlockSoundTime = now2; }
          const ang = Math.atan2(z.y - player.y, z.x - player.x), push = (repel - dist) + 20;
          z.x += Math.cos(ang)*push; z.y += Math.sin(ang)*push; continue;
        }
      }
      const dist = Math.sqrt(d2(z.x, z.y, player.x, player.y));
      if (dist < z.radius + player.size) {
        // KI·ªÇM TRA B·∫§T T·ª¨ C·ª¶A PLAYER T·∫†I ƒê√ÇY
      if (player.hitTimer === 0 && !player.safeInvincible && z.canHit) {
        let dmg = calculateZombieDamage(z); 
        if (supportAuraActive) dmg *= 0.5;

        // TH√äM M·ªöI: T√≠nh s√°t th∆∞∆°ng cu·ªëi c√πng sau khi tr·ª´ gi√°p
        const finalDamage = Math.max(0, Math.round(dmg) - (player.armor || 0)); // X·ª≠ l√Ω s√°t th∆∞∆°ng cu·ªëi c√πng

        player.hearts -= finalDamage; 
        player.hitTimer = 30;
        createDamageImpactEffect(player, finalDamage); // Hi·ªÉn th·ªã ƒë√∫ng s√°t th∆∞∆°ng ƒë√£ gi·∫£m
          z.canHit = false; 
          setTimeout(() => { z.canHit = true; }, 500);
          
          if (player.hearts <= 0) handlePlayerDeath();
        }
        
        // Logic ƒë·∫©y l√πi gi·ªØ nguy√™n
        const ang = Math.atan2(z.y - player.y, z.x - player.x), push = (z.radius + player.size - dist) + 1;
        z.x += Math.cos(ang)*push; z.y += Math.sin(ang)*push;
      }
    }

    // clamp map
    z.x = clamp(z.x, wallThickness + z.radius, worldWidth  - wallThickness - z.radius);
    z.y = clamp(z.y, wallThickness + z.radius, worldHeight - wallThickness - z.radius);
  }
}

/* ========== 11) ITEMS PICKUP + MAGNET + LEVEL-UP ========== */
function sysPickupItemsAndLevel(now) {
  // Magnet: h√∫t item (tr·ª´ buff types)
  if (now < magnetBuffEndTime) {
    const R = 200, typesBlock = ['lucky','power','crazy','exp','magnet','secret', 'crazymadnesstime'];
    for (let i = 0; i < items.length; i++) {
      const it = items[i]; if (!it.active) continue;
      let skip = false; for (let k = 0; k < typesBlock.length; k++) if (it.type === typesBlock[k]) { skip = true; break; }
      if (skip) continue;
      if (d2(player.x, player.y, it.x, it.y) < R*R) {
        const ang = Math.atan2(player.y - it.y, player.x - it.x); it.x += Math.cos(ang)*5; it.y += Math.sin(ang)*5;
      }
    }
  }
  // Pickup
  for (let i = 0; i < items.length; i++) {
    const it = items[i]; if (!it.active) continue;
    if (d2(it.x, it.y, player.x, player.y) < 20*20) {
      playSound('sfx-pickup', 0.5);
      switch (it.type) {
        case 'lucky':  luckyBuffEndTime  = now + 45000; playSound('sfx-powerup',0.8); break;
        case 'power':  powerBuffEndTime  = now + 45000; playSound('sfx-powerup',0.8); break;
        case 'crazy':  crazyBuffEndTime  = now + 45000; playSound('sfx-powerup',0.8); break;
        case 'exp':    expBuffEndTime    = now + 45000; playSound('sfx-powerup',0.8); break;
        case 'magnet': magnetBuffEndTime = now + 30000; playSound('sfx-powerup',0.8); break;
        case 'crazymadnesstime': crazyMadnessTimeEndTime = now + 30000; playSound('sfx-powerup',0.8); break;
        case 'secret': activateSecretItem(it); playSound('sfx-powerup',0.8); break;
        case 'expBonus': activateExpBonusItem(); playSound('sfx-powerup',0.8); break;
        case 'coin':   player.coins += 1;  queuePlayerLootPopup("ü™ô"); playSound('sfx-pickup-coin', 0.5); break;
        case 'energy': player.energy += 1; queuePlayerLootPopup("‚ö°"); break;
        case 'mana':   player.mana += 1;   queuePlayerLootPopup("üí†"); break;
        case 'hp': player.hearts = Math.min(player.maxHearts, player.hearts + 1); createHealImpactEffect(player, 1);
        queuePlayerLootPopup("‚ù§Ô∏è"); break;
        case 'potion': {
        const baseHeal = (Math.random()*11|0) + 10, bonus = Math.round((player.level + wave) * 1.5), total = baseHeal + bonus; player.hearts = Math.min(player.maxHearts, player.hearts + total); createHealImpactEffect(player, total);
        showWarning(`üíä +${total} HP`);} break;
        case 'critRateBuff': addCritRateBuff(0.15, 45000); showWarning("‚ú® TƒÉng t·ªâ l·ªá ch√≠ m·∫°ng!"); playSound('sfx-powerup', 0.8); break;
        case 'critDmgBuff': addCritDmgBuff(0.25, 45000); showWarning("üí• TƒÉng s√°t th∆∞∆°ng ch√≠ m·∫°ng!"); playSound('sfx-powerup', 0.8); break;
        case 'box': openItemBox(); break;
      }
      it.active = false;
    }
  }

  // Level up: while x·ª≠ l√Ω l√™n nhi·ªÅu c·∫•p
  while (player.currentLevelExp >= player.requiredExp) {
    const leftover = player.currentLevelExp - player.requiredExp;
    playSound('sfx-level-up'); player.level++;
    // TƒÉng ch·ªâ s·ªë t·ªëi ƒëa khi l√™n c·∫•p
    player.maxHearts += 5;
    player.staminaMax += 1;
    player.stamina = player.staminaMax; // H·ªìi ƒë·∫ßy stamina
    // ‚ûï M·ªñI C·∫§P +3 ƒêI·ªÇM
    player.statPoints = (player.statPoints || 0) + 3;
    window.CharacterPanel?.refresh();
    const healOnLevelUp = 1 + (UPGRADE_TIERS.hpBoost[playerUpgrades.hpBoost] || 0);
    player.hearts = Math.min(player.maxHearts, player.hearts + healOnLevelUp);
    player.energy += 10; player.mana += 10; playerUpgrades.damageBoost += 0.5; showWarning("+0.5 üí•");

    const popup = document.getElementById("levelUpPopup");
    if (popup) { popup.style.animation = "none"; void popup.offsetWidth; popup.style.display = "block"; setTimeout(()=>{ popup.style.display="none"; }, 1200); }
    levelUpGlowTime = 60; if (typeof showSkillLevelUpPopup === "function") showSkillLevelUpPopup();
    if (player.level % 1 === 0 && typeof spawnBoss === "function") spawnBoss();

    player.currentLevelExp = leftover; player.requiredExp = calculateRequiredExp(player.level);
  }
}

/* ========== 12) EXPLOSIONS / EXPANDING / EXTRA SHOCKWAVES ========== */
function sysUpdateExplosionsAndShockwaves() {
  for (let i = 0; i < explosions.length; i++) {
    const e = explosions[i]; if (!e.active) continue;
    e.radius += 2; e.life--; if (e.life <= 0) releaseExplosion(e);
  }
  for (let i = expandingExplosions.length - 1; i >= 0; i--) {
    const exp = expandingExplosions[i]; const prevR = exp.radius;
    exp.radius += exp.maxRadius / exp.duration; exp.duration--;
    for (let j = 0; j < zombies.length; j++) {
      const z = zombies[j]; if (!z.active) continue;
      const dist = Math.sqrt(d2(exp.x, exp.y, z.x, z.y));
      if (dist >= prevR && dist < exp.radius && !exp.hitSet.has(z)) { dealDamageToZombie(z, exp.damage); exp.hitSet.add(z); }
    }
    if (exp.duration <= 0) removeAtSwap(expandingExplosions, i);
  }
  for (let i = extraShockwaves.length - 1; i >= 0; i--) {
    const sw = extraShockwaves[i]; sw.radius += 8; sw.alpha -= 0.012; if (sw.alpha <= 0) removeAtSwap(extraShockwaves, i);
  }
}

/* ========== 13) SATELLITES (laze xuy√™n ‚Äî nearest ∆∞u ti√™n) ========== */
function skillUpdateSatellites(now) {
  if (!satelliteActive) return;
  if (now >= satelliteEndTime) { satelliteActive = false; satellites.length = 0; return; }

  for (let i = 0; i < satellites.length; i++) {
    const sat = satellites[i];
    sat.angle += sat.orbitSpeed; sat.x = player.x + Math.cos(sat.angle)*sat.orbitRadius; sat.y = player.y + Math.sin(sat.angle)*sat.orbitRadius;
    if (!sat.laserCooldown) sat.laserCooldown = now;

    if (now >= sat.laserCooldown) {
      // nearest trong 500
      const t = nearestZombieInRange(sat.x, sat.y, 500);
      if (t) {
        playSound('sfx-laser', 0.5); sat.laserCooldown = now + 2000;
        sat.laserBeam = { angle: Math.atan2(t.y - sat.y, t.x - sat.x), life: 60, hitZombiesThisShot: new Set() };
      }
    }
    if (sat.laserBeam && sat.laserBeam.life > 0) {
      sat.laserBeam.life--;
      const x1 = sat.x, y1 = sat.y, ang = sat.laserBeam.angle, dx = Math.cos(ang), dy = Math.sin(ang);
      const sk = (function(){ for (let s=0; s<activeSkills.length; s++) { const a=activeSkills[s]; if (a && a.name==="V·ªá tinh laze") return a; } return null; })();
      const baseDmg = (sk && sk.baseDamage) || 5;

      // Qu√©t t·∫•t c·∫£ m·ª•c ti√™u tr√™n tia (kh√¥ng sort): t√¨m first (g·∫ßn nh·∫•t) + g√¢y dmg cho t·∫•t c·∫£
      let first = null, firstD2 = Infinity;
      const hitList = [];
      for (let j = 0; j < zombies.length; j++) {
        const z = zombies[j]; if (!z.active) continue;
        const proj = (z.x - x1)*dx + (z.y - y1)*dy; if (proj <= 0 || proj >= 500) continue;
        const perp = Math.abs((z.x - x1)*dy - (z.y - y1)*dx); if (perp >= 20) continue;
        hitList.push(z);
        const dz2 = d2(sat.x, sat.y, z.x, z.y);
        if (dz2 < firstD2) { firstD2 = dz2; first = z; }
      }
      if (hitList.length) {
        for (let j = 0; j < hitList.length; j++) {
          const z = hitList[j]; if (sat.laserBeam.hitZombiesThisShot.has(z)) continue;
          const dmg = (z === first) ? baseDmg : Math.max(1, Math.round(baseDmg * 0.5));
          dealDamageToZombie(z, dmg); sat.laserBeam.hitZombiesThisShot.add(z);
        }
      }
      if (sat.laserBeam.life <= 0) sat.laserBeam = null;
    }
  }
}

/* ========== 14) LIGHTNING ‚Äî m√¢y v√≤ng cung + strike ========== */
function skillUpdateLightning(now) {
  if (!lightningActive) return;
  const bobY = Math.sin(frame * 0.05) * 4;
  const n = lightningBolts.length, R = 80, spread = Math.PI * 0.7;

  for (let i = 0; i < n; i++) {
    const bolt = lightningBolts[i];
    let ang = -Math.PI/2; if (n > 1) { const start = -Math.PI/2 - spread/2, step = spread / (n-1); ang = start + i * step; }
    bolt.x = player.x + Math.cos(ang)*R; bolt.y = player.y + Math.sin(ang)*R + bobY;
    if (!bolt.nextZapTime) bolt.nextZapTime = 0;

    if (now > bolt.nextZapTime) {
      // nearest trong 240
      const t = nearestZombieInRange(bolt.x, bolt.y, 240);
      if (t) {
        dealDamageToZombie(t, bolt.damage / 2);
        activeLightningStrikes.push({ path: getZigZag(bolt, t, 4), life: 60, type: 'chain' });
        bolt.nextZapTime = now + 1000 + Math.random()*500;
      }
    }
  }

  // strike l·ªõn: ch·ªçn 1 zombie nh√¨n th·∫•y b·∫±ng reservoir sampling
  if (now > nextLightningStrikeTime) {
    let count = 0, target = null;
    for (let i = 0; i < zombies.length; i++) {
      const z = zombies[i]; if (!z.active) continue;
      if (z.x > camera.x && z.x < camera.x + canvas.width && z.y > camera.y && z.y < camera.y + canvas.height) {
        count++; if (Math.random() < (1 / count)) target = z; // reservoir
      }
    }
    if (target) {
      const start = { x: target.x, y: camera.y - 20 }, end = { x: target.x, y: target.y };
      activeLightningStrikes.push({ path: getZigZag(start, end, 8), life: 60 });
      if (lightningBolts.length) dealDamageToZombie(target, lightningBolts[0].damage);
      explosions.push(getExplosion(target.x, target.y));
    }
    const baseInterval = 800 / Math.max(1, lightningBolts.length); const rand = (Math.random()-0.5)*400;
    nextLightningStrikeTime = now + Math.max(100, baseInterval + rand);
  }
  // gi·∫£m life & d·ªçn tia
  for (let i = activeLightningStrikes.length - 1; i >= 0; i--) { const s = activeLightningStrikes[i]; s.life--; if (s.life <= 0) removeAtSwap(activeLightningStrikes, i); }
}

/* ========== 15) CLONES ‚Äî nh·∫Øm K m·ª•c ti√™u g·∫ßn PLAYER (kh√¥ng sort) ========== */
function skillUpdateClones(now) {
  if (!clonesActive) return;
  if (now >= clonesEndTime) { clonesActive = false; clones.length = 0; return; }

  // Ch·ªçn K m·ª•c ti√™u g·∫ßn ng∆∞·ªùi ch∆°i
  const targets = kNearestZombiesByPlayer(clones.length, 600);

  for (let i = 0; i < clones.length; i++) {
    const c = clones[i]; const t = targets[i] || null;
    if (t) {
      const ang = Math.atan2(t.y - c.y, t.x - c.x), dist = Math.sqrt(d2(c.x, c.y, t.x, t.y));
      if (dist > 250) { c.x += Math.cos(ang)*c.moveSpeed; c.y += Math.sin(ang)*c.moveSpeed; }
      if (!c.lastShot) c.lastShot = 0; if (!c.shotCount) c.shotCount = 0;
      if (now - c.lastShot >= 500) { // T·ªëc ƒë·ªô b·∫Øn clone
        c.lastShot = now; c.shotCount++;
        if (c.shotCount >= 3) {
          c.shotCount = 0; playSound('sfx-laser', 0.5);
          activeCloneLasers.push({ cloneId: c.id, endX: t.x, endY: t.y, life: 60 });
          dealDamageToZombie(t, c.baseDamage * 3);
        } else {
          const b = getBullet(); b.x = c.x; b.y = c.y; b.dx = Math.cos(ang); b.dy = Math.sin(ang); b.speed = 3; b.active = true; b.customDmg = c.baseDamage; b.color = "#ff66ff";
          bullets.push(b);
        }
      }
    } else {
      const dist = Math.sqrt(d2(c.x, c.y, player.x, player.y));
      if (dist > 150) { const angBack = Math.atan2(player.y - c.y, player.x - c.x); c.x += Math.cos(angBack)*c.moveSpeed; c.y += Math.sin(angBack)*c.moveSpeed; }
    }
    c.x = clamp(c.x, wallThickness, worldWidth - wallThickness); c.y = clamp(c.y, wallThickness, worldHeight - wallThickness);
  }

  for (let i = activeCloneLasers.length - 1; i >= 0; i--) { const L = activeCloneLasers[i]; L.life--; if (L.life <= 0) removeAtSwap(activeCloneLasers, i); }
}

/* ========== 16) BLOOD ORB (ü©∏) ========== */
function skillUpdateBloodOrb(now) {
  if (!bloodOrbActive) return;
  if (now > bloodOrbEndTime) { bloodOrbActive = false; bloodOrbs.length = 0; return; }
  for (let i = 0; i < bloodOrbs.length; i++) {
    const o = bloodOrbs[i]; o.angle += 0.01; o.x = player.x + Math.cos(o.angle)*o.radius; o.y = player.y + Math.sin(o.angle)*o.radius;
    // nearest 300
    let best = null, bestD2 = 300*300;
    for (let j = 0; j < zombies.length; j++) { const z = zombies[j]; if (!z.active) continue; const dz2 = d2(o.x, o.y, z.x, z.y); if (dz2 < bestD2) { bestD2 = dz2; best = z; } }
    if (best !== o.target) { o.target = best; o.lockTime = now; }
    if (!o.target) continue;
    if ((now - (o.lockTime||0)) > 400 && (now - (window.bloodOrbLastDrain||0)) > 300) {
      window.bloodOrbLastDrain = now;
    let sk = null; for (let s=0; s<activeSkills.length; s++){const a=activeSkills[s]; if (a && a.name==="Qu·∫£ c·∫ßu h·∫•p huy·∫øt"){sk=a;break;}}
    dealDamageToZombie(o.target, (sk && sk.baseDamage) || 1);
    player.hearts = Math.min(player.maxHearts, player.hearts + 1);
    createHealImpactEffect(player, 1);
      for (let k = 0; k < 2; k++) createBloodOrbParticle(o);
      for (let k = 0; k < 2; k++) createBloodOrbParticleOnBeam(o);
    }
  }
}

/* ========== 17) THUNDER (üîµ) ========== */
function skillUpdateThunder(now) {
  if (!thunderActive) return;
  const btn = document.getElementById("thunderBtn"); const rem = Math.ceil((thunderEndTime - now)/1000);
  if (rem > 0) { if (btn) btn.innerText = `üîµ ${rem}s`; } else { thunderActive = false; thunderBalls.length = 0; if (btn){ btn.innerText="üîµ L√¥i"; btn.classList.remove("active"); } return; }

  for (let i = 0; i < thunderBalls.length; i++) {
    const ball = thunderBalls[i];
    ball.angle += 0.02; ball.x = player.x + Math.cos(ball.angle)*ball.radius; ball.y = player.y + Math.sin(ball.angle)*ball.radius;
    for (let j = 0; j < zombies.length; j++) {
      const z = zombies[j]; if (!z.active) continue;
      if (d2(ball.x, ball.y, z.x, z.y) < 40*40) {
        if (!z.thunderCooldown || now > z.thunderCooldown) {
          dealDamageToZombie(z, skillUpgrades.thunderDamage + playerUpgrades.damageBoost);
          z.stunnedByThunder = true; z.stunnedThunderUntil = now + 800; z.thunderCooldown = now + 100;
          const ang = Math.atan2(z.y - player.y, z.x - player.x), push = 16; z.x += Math.cos(ang)*push; z.y += Math.sin(ang)*push;
        }
      }
    }
    if (!ball.nextZapTime) ball.nextZapTime = 0;
    if (now > ball.nextZapTime) {
      const t = nearestZombieInRange(ball.x, ball.y, 250);
      if (t) {
        dealDamageToZombie(t, (skillUpgrades.thunderDamage + playerUpgrades.damageBoost) / 2);
        t.stunnedByThunder = true; t.stunnedThunderUntil = now + 800;
        activeLightningStrikes.push({ path: getZigZag(ball, t, 4), life: 30, type: 'chain' });
        ball.nextZapTime = now + 2000;
      }
    }
  }
  // d·ªçn tia s√©t
  for (let i = activeLightningStrikes.length - 1; i >= 0; i--) { const s = activeLightningStrikes[i]; s.life--; if (s.life <= 0) removeAtSwap(activeLightningStrikes, i); }
}

/* ========== 18) SUPPORT AURA (‚ú® Heal) ========== */
function skillUpdateSupportAura(now) {
  const btn = document.getElementById("supportAuraBtn");
  if (supportAuraActive) {
    if (now > supportAuraEndTime) {
      supportAuraActive = false; auraCrackLines.length = 0; auraLightBeams.length = 0; if (btn) btn.classList.remove("active");
    } else {
      if (!window.lastAuraHealTime) window.lastAuraHealTime = 0;
    if (now - lastAuraHealTime > 1000) { // h·ªìi m√°u m·ªói gi√¢y
        lastAuraHealTime = now;
        const totalHeal = Math.min(1 + skillUpgrades.auraHealLevel, 5);
        player.hearts = Math.min(player.maxHearts, player.hearts + totalHeal); // <-- THAY ƒê·ªîI
        createHealImpactEffect(player, totalHeal);
    }
      // h·∫°t + c·ªôt s√°ng nh·∫π, throttle theo frame
      if (frame % 15 === 0) {
        const ax = (player.x - 50) + Math.random()*100;
        particles.push({ x: ax, y: player.y + player.size - 5, type:'aura_particle', vx:(Math.random()-0.5)*0.1, vy:-0.5 - Math.random()*0.5, size:0.5+Math.random()*0.5, color:'rgba(255,215,0,0.8)', alpha:1, alphaDecay:0.005 });
      }
      if (frame % 20 === 0) { const bx = (player.x - 50) + Math.random()*100; auraLightBeams.push({ x: bx, width: 0.5 + Math.random(), alpha: 0, life: 60, initialLife: 60 }); }
      const rem = Math.ceil((supportAuraEndTime - now)/1000); if (btn) setTextOnce(btn, `‚ú® ${rem}s`, "auraText");
    }
  } else if (btn && btn.innerText !== "‚ú® Heal") btn.innerText = "‚ú® Heal";

  for (let i = auraLightBeams.length - 1; i >= 0; i--) {
    const b = auraLightBeams[i]; b.life--; b.alpha = Math.sin((1 - b.life / b.initialLife) * Math.PI); if (b.life <= 0) removeAtSwap(auraLightBeams, i);
  }
}

/* ========== 19) SPACE GATE (3-phase) ‚Äî n·∫øu ƒëang d√πng c·ªïng ki·ªÉu kh√°c, gi·ªØ nguy√™n ========== */
function sysUpdateSpaceGate(now) {
  // N·∫øu b·∫°n ƒëang d√πng h·ªá th·ªëng c·ªïng trong m√£ hi·ªán t·∫°i (player.isTeleporting / isGrowingAfterTeleport / spaceGateActive)
  // th√¨ kh·ªëi d∆∞·ªõi ƒë√¢y gi·ªØ nguy√™n h√†nh vi ƒë√≥, ch·ªâ gom & comment l·∫°i ƒë·ªÉ ƒë·ªçc d·ªÖ h∆°n, kh√¥ng c·∫•p ph√°t.
  if (player.isTeleporting) {
    player.size *= 0.92; if (spaceGate) spaceGate.radius *= 0.92;
    if (player.size < 1) {
      player.isTeleporting = false; player.isGrowingAfterTeleport = true;
      const t = findSafeTeleportLocation(); player.x = t.x; player.y = t.y; lastTeleportTime = now;
      camera.x = clamp(player.x - canvas.width/2, 0, worldWidth - canvas.width);
      camera.y = clamp(player.y - canvas.height/2, 0, worldHeight - canvas.height);
      if (now < spaceGateEndTime) createNewGate(player.x, player.y); else { spaceGateActive = false; spaceGate = null; }
    }
  } else if (player.isGrowingAfterTeleport) {
    player.size += (player.originalSize - player.size) * 0.1;
    if (player.originalSize - player.size < 0.1) {
      player.size = player.originalSize; player.isGrowingAfterTeleport = false;
      const ang = Math.random() * Math.PI * 2; player.x += Math.cos(ang)*40; player.y += Math.sin(ang)*40;
    }
  } else if (spaceGateActive && spaceGate) {
    if (now > spaceGateEndTime) { spaceGateActive = false; spaceGate = null; }
    else {
      if (spaceGate.alpha < 1) spaceGate.alpha += 0.05; spaceGate.rotation += 0.04;
      if (frame % 10 === 0) { // h·∫°t c·ªïng kh√¥ng gian
        createGateOrbitParticle(spaceGate);
        const PR = 80, KR = 25, PS = 1.8, PR2 = PR*PR, KR2 = KR*KR, BPS = PS*2.5;
        for (let i = 0; i < zombies.length; i++) { const z = zombies[i]; if (!z.active) continue;
          const dz2 = d2(spaceGate.x, spaceGate.y, z.x, z.y);
          if (dz2 < PR2) {
            const ang = Math.atan2(spaceGate.y - z.y, spaceGate.x - z.x); z.x += Math.cos(ang)*PS; z.y += Math.sin(ang)*PS;
            if (!z.gateDamageCooldown || now > z.gateDamageCooldown) { dealDamageToZombie(z, spaceGate.damage); z.gateDamageCooldown = now + 500; }
          }
          if (dz2 < KR2) { killZombie(z); explosions.push(getExplosion(z.x, z.y)); }
        }
        for (let i = 0; i < enemyBullets.length; i++) { const b = enemyBullets[i]; if (!b.active) continue;
          const db2 = d2(spaceGate.x, spaceGate.y, b.x, b.y);
          if (db2 < PR2) { const ang = Math.atan2(spaceGate.y - b.y, spaceGate.x - b.x); b.x += Math.cos(ang)*BPS; b.y += Math.sin(ang)*BPS; if (db2 < KR2) { releaseEnemyBullet(b); explosions.push(getExplosion(b.x, b.y)); } }
        }
      }
      const canUse = now > lastTeleportTime + GATE_COOLDOWN;
      if (canUse && d2(player.x, player.y, spaceGate.x, spaceGate.y) < spaceGate.radius * spaceGate.radius) { player.originalSize = player.size; player.isTeleporting = true; }
    }
  }
}

/* ========== 20) FAIRY (ü¶ã) ========== */
function skillUpdateFairy(now) {
  if (!fairyActive) return;
  const btn = document.getElementById("fairyBtn");
  if (now > fairyEndTime) {
    fairyActive = false; fairies.length = 0; playerUpgrades.damageBoost -= fairyDamageBonus; fairyDamageBonus = 0;
    if (btn) { btn.classList.remove("active"); btn.innerText = "ü¶ã Fairy"; }
    return;
  }
  if (btn) { btn.classList.add("active"); btn.innerText = `ü¶ã ${Math.ceil((fairyEndTime - now)/1000)}s`; }

  // buff heal/damage theo ng√†y/ƒë√™m
  let healAmt = isNight() ? (2 + skillUpgrades.fairyHealLevel*2) : (1 + skillUpgrades.fairyHealLevel*1);
  let dmgAmt  = isNight() ? (1 + skillUpgrades.fairyDamageLevel*0.5) : (2 + skillUpgrades.fairyDamageLevel);
  healAmt = Math.min(healAmt, isNight() ? 10 : 5);

  playerUpgrades.damageBoost -= fairyDamageBonus;
  fairyDamageBonus = dmgAmt * skillUpgrades.fairyCount;
  playerUpgrades.damageBoost += fairyDamageBonus;

  if (!window.lastFairyHealTime) window.lastFairyHealTime = 0;
  if (now - lastFairyHealTime > 2000) {
      const totalHeal = healAmt * skillUpgrades.fairyCount;
      player.hearts = Math.min(player.maxHearts, player.hearts + totalHeal); // <-- THAY ƒê·ªîI
      lastFairyHealTime = now;
      if (totalHeal > 0) createHealImpactEffect(player, totalHeal);
  }

  for (let i = 0; i < fairies.length; i++) {
    const f = fairies[i]; f.angle += 0.02; const bob = Math.sin(frame*0.05 + f.bobOffset)*5;
    f.x = player.x + Math.cos(f.angle)*f.orbitRadius; f.y = player.y + Math.sin(f.angle)*f.orbitRadius + bob;
    if (frame % 30 === 0) createFairyParticle(f.x, f.y); // h·∫°t c·ªßa k·ªπ nƒÉng fairy

    if (!f.nextAttackTime) f.nextAttackTime = 0;
    if (now > f.nextAttackTime) {
      f.nextAttackTime = now + 1000;
      let nearest = null, bestD2 = 600*600;
      for (let j = 0; j < zombies.length; j++) {
        const z = zombies[j]; if (!z.active || z.isSleeping) continue;
        const dz2 = d2(f.x, f.y, z.x, z.y); if (dz2 < bestD2) { bestD2 = dz2; nearest = z; }
      }
      if (nearest) {
        const b = getBullet(); const ang = Math.atan2(nearest.y - f.y, nearest.x - f.x);
        b.x = f.x; b.y = f.y; b.dx = Math.cos(ang); b.dy = Math.sin(ang); b.speed = 2; b.isFairyBullet = true; b.piercing = false; b.effect = isNight() ? 'sleep' : 'wandering';
        bullets.push(b);
      }
    }
  }
}

/* ========== 21) C·∫¨P NH·∫¨T BUFF CHI·∫æN ƒê·∫§U (C·ªông d·ªìn hi·ªáu ·ª©ng) ========== */
function sysUpdateCombatBuffs(now) {
// --- X·ª≠ l√Ω buff üí¢ CrazyMadnessTime (Power + Crazy g·ªôp, speed ch·ªâ +0.5) ---
const wasCrazyMadness = isCrazyMadnessTimeActive;
isCrazyMadnessTimeActive = now < crazyMadnessTimeEndTime;
if (isCrazyMadnessTimeActive && !wasCrazyMadness) {
  // 1) L·∫•y "base" ch∆∞a c√≥ c·ªông t·ª´ Power/Crazy (n·∫øu ƒëang b·∫≠t 1 trong 2)
  const existingCrazyD = (isCrazyBuffActive && window.crazyBuffStats && typeof crazyBuffStats.damage === 'number')
    ? crazyBuffStats.damage : 0;
  const existingPowerD = (typeof window.powerBuffDamageBonus === 'number' && (now < (window.powerBuffEndTime || 0)))
    ? powerBuffDamageBonus : 0;

  const baseDmgBoost = Math.max(0, playerUpgrades.damageBoost - existingCrazyD - existingPowerD);

  // 2) T√≠nh ‚Äút∆∞∆°ng ƒë∆∞∆°ng Power + Crazy‚Äù d·ª±a tr√™n base + level-scaling 1 d√≤ng nh∆∞ b·∫°n quy ∆∞·ªõc
  const powerEq = (baseDmgBoost * 1.5) + 2 + Math.floor(player.level * 1.2); // Power
  const crazyEq = (baseDmgBoost * 0.5) + 1 + player.level;                   // Crazy (+1 m·ªói c·∫•p)
  const dmgAdd  = powerEq + crazyEq;

  // 3) G√≥i c√°c stats c·ªßa CMT (speed ch·ªâ +0.5 ƒë·ªÉ c·ªông d·ªìn v·ªõi Crazy th√†nh +1)
  crazyMadnessTimeBuffStats = {
    speed: 0.5,               // KH√îNG x2 n·ªØa; ƒë·ªÉ Crazy (+0.5) => t·ªïng +1 khi c√πng ho·∫°t ƒë·ªông
    bulletSpeed: 1,           // nh∆∞ Crazy
    damage: dmgAdd,           // Power + Crazy (t√≠nh tr√™n base)
    lineBulletCount: 1,       // nh∆∞ Crazy
    iceArrow: 10              // nh∆∞ Crazy
  };

  // 4) √Åp d·ª•ng
  player.speed                     += crazyMadnessTimeBuffStats.speed;
  playerUpgrades.bulletSpeed       += crazyMadnessTimeBuffStats.bulletSpeed;
  playerUpgrades.damageBoost       += crazyMadnessTimeBuffStats.damage;
  playerUpgrades.lineBulletCount   += crazyMadnessTimeBuffStats.lineBulletCount;
  playerUpgrades.iceArrow          += crazyMadnessTimeBuffStats.iceArrow;

  updateStatsOverlay();
} else if (!isCrazyMadnessTimeActive && wasCrazyMadness) {
  // Ho√†n tr·∫£ an to√†n (fallback n·∫øu stats b·ªã clear)
  const s = crazyMadnessTimeBuffStats || {speed:0, bulletSpeed:0, damage:0, lineBulletCount:0, iceArrow:0};

  player.speed                     -= s.speed;
  playerUpgrades.bulletSpeed       -= s.bulletSpeed;
  playerUpgrades.damageBoost       -= s.damage;
  playerUpgrades.lineBulletCount   -= s.lineBulletCount;
  playerUpgrades.iceArrow          -= s.iceArrow;

  // Clamp nh·ªè ƒë·ªÅ ph√≤ng √¢m do n∆°i kh√°c c√πng ch·ªânh
  playerUpgrades.bulletSpeed       = Math.max(0, playerUpgrades.bulletSpeed);
  playerUpgrades.lineBulletCount   = Math.max(0, playerUpgrades.lineBulletCount);
  playerUpgrades.iceArrow          = Math.max(0, playerUpgrades.iceArrow);

  crazyMadnessTimeBuffStats = {};
  updateStatsOverlay();
}
    // --- X·ª≠ l√Ω buff üçÅ Power (ho·∫°t ƒë·ªông ƒë·ªôc l·∫≠p) ---
    const wasPower = isPowerBuffActive;
    isPowerBuffActive = now < powerBuffEndTime;
    if (isPowerBuffActive && !wasPower) {
        powerBuffDamageBonus = (playerUpgrades.damageBoost * 1.5) + 2 + Math.floor(player.level * 1.2);
        // TƒÉng 150% s√°t th∆∞∆°ng hi·ªán t·∫°i + 2 + 1.2 s√°t th∆∞∆°ng m·ªói c·∫•p
        playerUpgrades.damageBoost += powerBuffDamageBonus;
        updateStatsOverlay();
    } else if (!isPowerBuffActive && wasPower) {
        playerUpgrades.damageBoost -= powerBuffDamageBonus;
        powerBuffDamageBonus = 0;
        updateStatsOverlay();
    }

    // --- X·ª≠ l√Ω buff üçÇ Crazy (ho·∫°t ƒë·ªông ƒë·ªôc l·∫≠p) ---
    const wasCrazy = isCrazyBuffActive;
    isCrazyBuffActive = now < crazyBuffEndTime;
    if (isCrazyBuffActive && !wasCrazy) {
        const crazyD = (playerUpgrades.damageBoost * 0.5) + 1 + player.level;
        // TƒÉng 50% s√°t th∆∞∆°ng hi·ªán t·∫°i + 1 + 1 s√°t th∆∞∆°ng m·ªói c·∫•p
        crazyBuffStats = { speed: 0.5, bulletSpeed: 1, damage: crazyD, lineBulletCount: 1, iceArrow: 10 };
        player.speed += crazyBuffStats.speed;
        playerUpgrades.bulletSpeed += crazyBuffStats.bulletSpeed;
        playerUpgrades.damageBoost += crazyBuffStats.damage;
        playerUpgrades.lineBulletCount += crazyBuffStats.lineBulletCount;
        playerUpgrades.iceArrow += crazyBuffStats.iceArrow;
        updateStatsOverlay();
    } else if (!isCrazyBuffActive && wasCrazy) {
        player.speed -= crazyBuffStats.speed;
        playerUpgrades.bulletSpeed -= crazyBuffStats.bulletSpeed;
        playerUpgrades.damageBoost -= crazyBuffStats.damage;
        playerUpgrades.lineBulletCount -= crazyBuffStats.lineBulletCount;
        playerUpgrades.iceArrow -= crazyBuffStats.iceArrow;
        crazyBuffStats = {};
        updateStatsOverlay();
    }
}
// ===== [C·∫§U H√åNH] TTL cho item =====
const ITEM_TTL_MS = 15000; // 15 gi√¢y ‚Äî x√≥a item

// (T·ªëi ∆∞u nh·∫π) Kh√¥ng c·∫ßn qu√©t m·ªói frame; 200‚Äì500ms/l·∫ßn l√† ƒë·ªß
let _nextItemTTLCheckAt = 0;

function pruneExpiredItems(now) {
  // Gi·∫£m t·∫ßn su·∫•t qu√©t ƒë·ªÉ kh√¥ng t·ªën CPU khi FPS cao
  if (now < _nextItemTTLCheckAt) return;
  _nextItemTTLCheckAt = now + 300; // qu√©t m·ªói 300ms

  // Duy·ªát ng∆∞·ª£c ƒë·ªÉ x√≥a an to√†n
  for (let i = items.length - 1; i >= 0; i--) {
    const it = items[i];
    if (!it) continue;

    // N·∫øu ch∆∞a c√≥ bornAt (do c√°c ch·ªó spawn ch∆∞a set), kh·ªüi t·∫°o lu√¥n ·ªü l·∫ßn g·∫∑p ƒë·∫ßu
    if (it.bornAt == null) {
      it.bornAt = now;
      continue; // m·ªõi sinh (theo chu·∫©n), ƒë·ª£i l·∫ßn qu√©t sau
    }

    // Qu√° 30s th√¨ x√≥a
    if ((now - it.bornAt) >= ITEM_TTL_MS) {
      // C√°ch 1: x√≥a nhanh, √≠t side-effect (swap-pop) n·∫øu b·∫°n c√≥ s·∫µn helper removeAtSwap()
      if (typeof removeAtSwap === 'function') {
        removeAtSwap(items, i);
      } else {
        // C√°ch 2: d√πng splice cho ƒë∆°n gi·∫£n (ƒë√£ duy·ªát ng∆∞·ª£c n√™n an to√†n)
        items.splice(i, 1);
      }
    }
  }
}
// ===== SAFE UI LOCK - kh√≥a thanh n√∫t tr√™n khi ·ªü Safe Zone =====
(function () {
  let cached = false;
  let box = null;         // container thanh n√∫t
  let btns = [];          // t·∫•t c·∫£ button n·∫±m trong container

  function ensureCache() {
    if (cached) return;
    cached = true;

    // Container thanh n√∫t: file c·ªßa b·∫°n l√† <div id="ui"> ... c√°c button ...
    box = document.getElementById('ui');
    if (box) {
      btns = Array.from(box.querySelectorAll('button'));

      // Ch·∫∑n click t·ª´ giai ƒëo·∫°n capture => m·ªçi onclick/addeventlistener b√™n d∆∞·ªõi ƒë·ªÅu b·ªã ch·∫∑n khi ·ªü safe zone
      if (!box.__safeClickBlocker) {
        box.addEventListener('click', (e) => {
          if (window.isPlayerInSafeZone) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        }, true); // capture
        box.__safeClickBlocker = true;
      }
    } else {
      // N·∫øu DOM ch∆∞a c√≥ #ui, l·∫ßn sau g·ªçi s·∫Ω th·ª≠ l·∫°i
      cached = false;
    }
  }

  // H√†m public: ƒë·ªìng b·ªô UI theo tr·∫°ng th√°i
  window.syncSafeZoneTopUI = function () {
    ensureCache();
    const inSafe = !!window.isPlayerInSafeZone;

    if (box) box.classList.toggle('safe-ui-disabled', inSafe);

    for (let i = 0; i < btns.length; i++) {
      const b = btns[i];
      b.classList.toggle('safe-ui-btn-disabled', inSafe);
      if (inSafe) {
        b.setAttribute('aria-disabled', 'true');
        b.tabIndex = -1;
      } else {
        b.removeAttribute('aria-disabled');
        b.tabIndex = 0;
      }
    }
  };
})();

/* ========== 22) MAIN UPDATE ‚Äî PIPELINE R√ï R√ÄNG ========== */
function update() {
  updateSafeZoneStatus();
  // V√πng an to√†n (safe zones)
  const isPlayerSafe = safeZones.some(zone => zone.active && distance(player, zone) < zone.radius);
  player.inSafeZone = isPlayerSafe;
  window.isPlayerInSafeZone = isPlayerSafe;
  // Ch·ªâ sync khi ƒë·ªïi tr·∫°ng th√°i ƒë·ªÉ kh√¥ng t·ªën CPU m·ªói frame
if (window._prevSafe !== isPlayerSafe) {
  window._prevSafe = isPlayerSafe;
  if (window.syncSafeZoneTopUI) window.syncSafeZoneTopUI(); // ‚úÖ ch·ªâ g·ªçi khi ƒë√£ c√≥
}
// H·ªìi m√°u khi ·ªü trong v√πng an to√†n
if (isPlayerSafe) {
    if (!player.lastSafeHeal || Date.now() - player.lastSafeHeal > 1000) { // m·ªói gi√¢y h·ªìi 10 m√°u
        // L∆∞u gi√° tr·ªã m√°u hi·ªán t·∫°i tr∆∞·ªõc khi h·ªìi
        const currentHearts = player.hearts;
        // H·ªìi m√°u, ƒë·∫£m b·∫£o kh√¥ng v∆∞·ª£t qu√° m√°u t·ªëi ƒëa
        player.hearts = Math.min(player.maxHearts, player.hearts + 10);
        player.stamina = Math.min(player.staminaMax, player.stamina + 10);
        // Ch·ªâ t·∫°o hi·ªáu ·ª©ng n·∫øu m√°u th·ª±c s·ª± tƒÉng
        if (player.hearts > currentHearts) {
            createHealImpactEffect(player, 10);
        }
        // C·∫≠p nh·∫≠t th·ªùi gian h·ªìi m√°u cu·ªëi c√πng
        player.lastSafeHeal = Date.now();
    }
}
// ƒê·∫∑t b·∫•t t·ª≠ khi ·ªü trong Safe Zone
player.safeInvincible = !!isPlayerSafe;

  const now = Date.now();
  if (!gameStarted || gameOver || isPaused) return;

  updatePlayerRegen(now); // h·ªìi m√°u
  updatePlayerStaminaRegen(now); // H·ªìi stamina
  updateSkillCooldowns();

  if (player.hitTimer > 0) player.hitTimer--;

  // dying ‚Üí ch·ªâ h·∫°t
  if (player.isDying) { updateParticles(); return; }

  // 1) Buff l√µi + Halo
  sysUpdateBuffCore(now);

  // 2) Player lasers
  if (!isPlayerSafe) sysUpdatePlayerLasers();

  // 3) Wave + BigBoss
  sysUpdateWaveAndBoss(now);

  // 4) Skill ƒêao v√≤ng + L∆∞·ª°i ki·∫øm m∆∞a
  if (!isPlayerSafe) {
  skillUpdateBladesUIAndSpawn(now);
  skillUpdateBladeRain(now);
  }
  // 5) Movement + Camera + Touch
  sysUpdateMovementAndCamera();

  // 6) Auto shoot
  if (!window.isPlayerInSafeZone && autoShoot && player.level >= 1) autoShootBurst();

  // 7) Fire/Ice
  if (!isPlayerSafe) skillUpdateFireIce(now);

  // 8) Pet UI nh·∫π
  sysUpdatePetUI(now);

  // 9) Bullets (player/clone/fairy/pet) & Enemy bullets
  if (!isPlayerSafe) sysUpdateBullets(); // v·∫´n ƒë·ªÉ enemy bullets ch·∫°y ph√≠a d∆∞·ªõi
  sysUpdateEnemyBullets(now);

  // 10) Zombies
  sysUpdateZombies(now);

  // 11) BigBoss lazer follow (n·∫øu c√≥)
  for (let i = 0; i < zombies.length; i++) { const z = zombies[i]; if (z.active) updateBigBossLazer(z, globalDeltaTime); }

  // 12a) TTL Items 30s ‚Äî d·ªçn item qu√° h·∫°n TR∆Ø·ªöC khi h√∫t/nh·∫∑t ƒë·ªÉ gi·∫£m chi ph√≠
  pruneExpiredItems(now);

  // 12) Items + Magnet + Level up
  sysPickupItemsAndLevel(now);
window.EquipmentDropAPI?.updateEquipDrops?.(now, player.x, player.y);

  // 13) Explosions & Shockwaves
  sysUpdateExplosionsAndShockwaves();

  if (levelUpGlowTime > 0) levelUpGlowTime--;
  // 14..21) To√†n b·ªô skill tick => t·∫Øt khi trong safe zone
  // 14) Satellites
  if (!isPlayerSafe) {
  skillUpdateSatellites(now);

  // 15) Lightning
  skillUpdateLightning(now);

  // 16) Clones
  skillUpdateClones(now);

  // 17) Blood Orb
  skillUpdateBloodOrb(now);

  // 18) Thunder
  skillUpdateThunder(now);

  // 19) Support Aura
  skillUpdateSupportAura(now);

  // 20) Space Gate
  sysUpdateSpaceGate(now);

  // 21) Fairy
  skillUpdateFairy(now);
  }
  // 22) Power/Crazy √°p ch·ªâ s·ªë
  sysUpdateCombatBuffs(now);

  // 23) Particles/Pet/Missiles/Spatial/Black holes/Cleanup/UI/Music/Supply
  updateParticles();
  updatePet();
  updateMissiles();
  updateSpatialIndex();
  updateBlackHoles();
  cleanupInactiveObjects();
  updateUI();
  updateStatsOverlay();
  updateMusic();
  updateSupplyDrops();
}

// C·∫≠p nh·∫≠t cooldown c·ªßa k·ªπ nƒÉng
function updateSkillCooldowns() {
    const listItems = document.querySelectorAll('#skills-list .skill-item');
    const now = Date.now();

    // üîí Kh√≥a/ m·ªü kh√≥a c√°c n√∫t k·ªπ nƒÉng theo safe zone
    const inSafe = (window.isPlayerInSafeZone === true) || safeZones.some(zone => zone.active && distance(player, zone) < zone.radius);
    listItems.forEach(it => {
        if (inSafe) it.classList.add('disabled');
        else it.classList.remove('disabled');
    });
    activeSkills.forEach((skill, index) => {
        const item = listItems[index];
        if (!item || !skill.endTime) return;

        if (now < skill.endTime) {
            const remain = Math.ceil((skill.endTime - now) / 1000);
            item.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${remain}s`;
            item.classList.add('active');
        } else {
            skill.endTime = null; // Reset khi h·∫øt gi·ªù
            item.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${skill.manaCost}üí†`;
            item.classList.remove('active');
        }
    });
}
// Lazer boss
function updateBigBossLazer(z, deltaTime) {
    if (!z.active || !z.isBigBoss) return;

    if (z.lazerDamageCooldown === undefined) z.lazerDamageCooldown = 0;
    if (z.isChargingLazer === undefined) z.isChargingLazer = false;

    const distanceToPlayer = distance(z, player);
    const ATTACK_RANGE = 600; // T·∫ßm b·∫Øt ƒë·∫ßu ng·∫Øm b·∫Øn
    const CHARGE_TIME = 2;    // Th·ªùi gian ng·∫Øm b·∫Øn

    const chargeSound = document.getElementById('sfx-lazer-charging');

    // ‚õ≥ SAFE ZONE: d·ª´ng to√†n b·ªô laser khi player ·ªü trong
    const playerInSafe = safeZones.some(zone => distance(player, zone) < zone.radius);
    if (playerInSafe) {
        if (z.isChargingLazer && chargeSound) {
            chargeSound.pause();
            chargeSound.currentTime = 0;
        }
        z.isChargingLazer = false;
        z.isLazerAttacking = false;
        z.lazerTimer = 0;
        return; // Kh√¥ng b·∫Øn laser khi player ·ªü trong m√°i v√≤m
    }

    // N·∫øu ng∆∞·ªùi ch∆°i ·ªü ngo√†i t·∫ßm v√† boss kh√¥ng ƒëang b·∫Øn
    if (distanceToPlayer > ATTACK_RANGE && !z.isLazerAttacking) {
        // N·∫øu boss ƒêANG g·ªìng th√¨ ph·∫£i t·∫Øt √¢m thanh ƒëi
        if (z.isChargingLazer && chargeSound) {
            chargeSound.pause();
            chargeSound.currentTime = 0;
        }
        z.isChargingLazer = false;
        z.lazerTimer = 0;
    } 
    // N·∫øu ng∆∞·ªùi ch∆°i ·ªü trong t·∫ßm v√† boss ch∆∞a l√†m g√¨ c·∫£
    else if (distanceToPlayer < ATTACK_RANGE && !z.isLazerAttacking && !z.isChargingLazer) {
        z.isChargingLazer = true; // B·∫Øt ƒë·∫ßu g·ªìng
        z.lazerTimer = 0;
        
        // B·∫Øt ƒë·∫ßu ph√°t √¢m thanh g·ªìng
        if (chargeSound) {
            chargeSound.volume = 0.5; // 0.5 = 50% √¢m l∆∞·ª£ng
            chargeSound.play();
    }
  }
    // N·∫øu ƒëang trong giai ƒëo·∫°n g·ªìng laze
    if (z.isChargingLazer) {
        z.lazerTimer += deltaTime;
        // N·∫øu g·ªìng ƒë·ªß 2 gi√¢y th√¨ b·∫Øn
        if (z.lazerTimer > CHARGE_TIME) {
            z.isChargingLazer = false;
            z.isLazerAttacking = true;
            
            // D·ª´ng √¢m thanh g·ªìng
            if (chargeSound) {
                chargeSound.pause();
                chargeSound.currentTime = 0;
            }
            // Ph√°t √¢m thanh b·∫Øn
            playSound('sfx-bigboss-laser', 0.5);
            
            z.lazerDuration = 2;
            z.lazerTimer = 0;
            z.lazerAngle = Math.atan2(player.y - z.y, player.x - z.x);
        }
    }

    // Giai ƒëo·∫°n b·∫Øn tia lazer
    if (z.isLazerAttacking) {
        z.lazerDuration -= deltaTime;
        if (z.lazerDuration <= 0) {
            z.isLazerAttacking = false;
        }
        
        if (z.lazerAngle !== undefined) {
            const proj = (player.x - z.x) * Math.cos(z.lazerAngle) + (player.y - z.y) * Math.sin(z.lazerAngle);
            const perp = Math.abs((player.x - z.x) * Math.sin(z.lazerAngle) - (player.y - z.y) * Math.cos(z.lazerAngle));
            
            const lazerRange = 600;
            const lazerWidth = 18;
            const lazerCooldown = 60;

            if (proj > 0 && proj < lazerRange && perp < lazerWidth) {
                if (z.lazerDamageCooldown <= 0 && player.hearts > 0 && !player.safeInvincible) {
                    if (player.shieldActive) {
                      const now = Date.now();
                        // D√πng chung cooldown v·ªõi va ch·∫°m zombie ƒë·ªÉ tr√°nh spam √¢m thanh
                        if (now - lastShieldBlockSoundTime > 100) {
                            playSound('sfx-shield-block', 0.3); // 30% √¢m l∆∞·ª£ng
                            lastShieldBlockSoundTime = now;
                        }
                        if (frame % 5 === 0) {
                            createParticleExplosion(player.x, player.y, 2, 'smoke');
                        }
                    } else {
                        let lazerDamage = calculateZombieDamage(z);
                        if (supportAuraActive) {
                            lazerDamage *= 0.5;
                        }
                        player.hearts -= lazerDamage;
                        z.lazerDamageCooldown = lazerCooldown;
                        createDamageImpactEffect(player, lazerDamage);
                        if (player.hearts <= 0) {
                            handlePlayerDeath(); 
                        }
                    }
                }
            }
          }
        
        if (z.lazerDamageCooldown > 0) z.lazerDamageCooldown--;
    }
}
// === üåç MINI MAP ===
// To√†n b·∫£n ƒë·ªì r·ªông 3000 x 2000 (c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh)
const worldWidth = 3000;
const worldHeight = 2000;
const wallThickness = 10; // ƒê·ªô d√†y t∆∞·ªùng vi·ªÅn b·∫£n ƒë·ªì
const miniMapCanvas = document.getElementById("miniMap");
const miniCtx = miniMapCanvas.getContext("2d");
let showMiniMap = true; //false ƒë·ªÉ ·∫©n ban ƒë·∫ßu
miniMapCanvas.style.display = showMiniMap ? "block" : "none";

// B·∫Øt ph√≠m M ƒë·ªÉ b·∫≠t/t·∫Øt
document.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "m") {
    showMiniMap = !showMiniMap;
    miniMapCanvas.style.display = showMiniMap ? "block" : "none";
  }
  // ‚å®Ô∏è ·∫®n/hi·ªán menu UI khi b·∫•m ph√≠m t
  if (e.key.toLowerCase() === "t") {
    uiVisible = !uiVisible;
    const ui = document.getElementById("ui");
    ui.style.display = uiVisible ? "flex" : "none";
}
});
// ====== MINIMAP EQUIP VISITOR (no-alloc) ====================================
// T√°i d√πng m·ªói frame, kh√¥ng t·∫°o callback m·ªõi.
let __mmCtx = null, __mmSX = 1, __mmSY = 1;
function __visitDropForMiniMap(d) {
  if (!d || d.active === false) return;
  const mx = d.x * __mmSX, my = d.y * __mmSY;
  __mmCtx.fillStyle = d.color || '#00ffd5'; // m√†u theo rarity ƒë√£ set trong equipment_drop.js
  __mmCtx.beginPath();
  __mmCtx.arc(mx, my, 1, 0, Math.PI * 1);
  __mmCtx.fill();
}
// H√†m v·∫Ω mini map
function drawMiniMap() {
  if (!showMiniMap) return;

  miniCtx.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);

  const scaleX = miniMapCanvas.width / worldWidth;
  const scaleY = miniMapCanvas.height / worldHeight;
    // üü¶ V·∫Ω SAFE ZONES l√™n minimap (xanh d∆∞∆°ng)
  // ƒê·∫∑t ngay sau khi c√≥ scaleX/scaleY trong drawMiniMap()
  // Gi·ªØ nh·∫π: ch·ªâ ~5 v√πng ‚Üí kh√¥ng t·ªën CPU
  miniCtx.save();
  const rScale = Math.min(scaleX, scaleY); // gi·ªØ h√¨nh tr√≤n ·ªïn khi t·ªâ l·ªá kh√°c nhau
    safeZones.forEach(zone => {
        if (zone.active) { // <-- Ch·ªâ v·∫Ω zone ƒëang active
            const cx = zone.x * scaleX;
            const cy = zone.y * scaleY;
            const r  = zone.radius * rScale;

            const g = miniCtx.createRadialGradient(cx, cy, 0, cx, cy, r);
            g.addColorStop(0.00, "rgba(59,130,246,0.10)");
            g.addColorStop(0.85, "rgba(59,130,246,0.20)");
            g.addColorStop(1.00, "rgba(59,130,246,0.35)");
            miniCtx.fillStyle = g;
            miniCtx.beginPath();
            miniCtx.arc(cx, cy, r, 0, Math.PI * 2);
            miniCtx.fill();

            miniCtx.strokeStyle = "#3b82f6";
            miniCtx.lineWidth = 1;
            miniCtx.stroke();
        }
    });
    miniCtx.restore();
 // d·ªÖ ch·ªânh k√≠ch th∆∞·ªõc sau n√†y
  const ITEM_SIZE   = 1.2;   // chi·ªÅu r·ªông/ cao d·∫•u v·∫≠t ph·∫©m (px tr√™n minimap)
  const ZOMBIE_SIZE = 2;     // zombie th∆∞·ªùng (√¥ vu√¥ng)
  const DOT_PLAYER  = 3;     // b√°n k√≠nh ch·∫•m player & boss/mini
  // V·∫Ω c√°c h√≤m ti·∫øp t·∫ø (ü™Ç) ƒëang r∆°i
  supplyDrops.forEach(drop => {
      const mapX = drop.x * scaleX;
      const mapY = drop.y * scaleY;
      miniCtx.fillStyle = "cyan"; // Ch·∫•m m√†u xanh cyan cho d·ªÖ th·∫•y
      miniCtx.beginPath();
      miniCtx.arc(mapX, mapY, 2, 0, Math.PI * 2); // V·∫Ω m·ªôt ch·∫•m tr√≤n
      miniCtx.fill();
  });

// Draw items (energy, mana, hp)
for (let it of items) {
  if (!it.active) continue;
  switch (it.type) {
    case "crazymadnesstime": miniCtx.fillStyle = "#3b82f6"; break; // M√†u xanh d∆∞∆°ng cho CrazyMadnessTime
    case "energy": miniCtx.fillStyle = "yellow"; break; // M√†u v√†ng cho nƒÉng l∆∞·ª£ng
    case "mana": miniCtx.fillStyle = "cyan"; break; // M√†u xanh lam cho mana
    case "hp": miniCtx.fillStyle = "lime"; break; // M√†u xanh l√° c√¢y cho HP
    case "box": miniCtx.fillStyle = "blue"; break; // M√†u xanh d∆∞∆°ng cho h·ªôp
    // Th√™m c√°c tr∆∞·ªùng h·ª£p m·ªõi cho c√°c v·∫≠t ph·∫©m ƒë·∫∑c bi·ªát
    case "lucky": miniCtx.fillStyle = "#22c55e"; break; // M√†u xanh l√° c√¢y cho Lucky
    case "power": miniCtx.fillStyle = "#ef4444"; break; // M√†u ƒë·ªè cho Power
    case "crazy": miniCtx.fillStyle = "#f59e0b"; break; // M√†u v√†ng cam cho Crazy
    case "exp": miniCtx.fillStyle = "#ffeb3b"; break; // M√†u v√†ng cho Exp
    case "magnet": miniCtx.fillStyle = "#8b5cf6"; break; // M√†u t√≠m cho Magnet
    case "secret": miniCtx.fillStyle = "violet"; break; // M√†u t√≠m ƒë·∫≠m cho Secret
    case "expBonus": miniCtx.fillStyle = "gold"; break; // M√†u v√†ng kim cho ExpBonus
    case "potion": miniCtx.fillStyle = "red"; break; // V√≠ d·ª•: ch·∫•m m√†u ƒë·ªè

    default: miniCtx.fillStyle = "gray";
  }
  miniCtx.fillRect(it.x * scaleX - 0.5, it.y * scaleY - 0.5, 1, 1); // V·∫Ω k√≠ch th∆∞·ªõc v·∫≠t ph·∫©m tr√™n minimap
}
// ‚≠ê V·∫Ω trang b·ªã r∆°i (equipment) tr√™n minimap
if (window.EquipmentDropAPI && typeof window.EquipmentDropAPI.forEachActiveDrop === 'function') {
  __mmCtx = miniCtx; __mmSX = scaleX; __mmSY = scaleY;
  window.EquipmentDropAPI.forEachActiveDrop(__visitDropForMiniMap);
}
// üíú V·∫Ω clone tr√™n minimap
clones.forEach(clone => {
  const mapX = (clone.x / worldWidth) * miniMapCanvas.width;
  const mapY = (clone.y / worldHeight) * miniMapCanvas.height;
  miniCtx.fillStyle = "#cc66ff";
  miniCtx.beginPath();
  miniCtx.arc(mapX, mapY, 2, 0, Math.PI * 2);
  miniCtx.fill();
});
// üü¶ V·∫Ω m√°y bay tr√™n minimap
activePlanes.forEach(plane => {
  const mapX = (plane.x / worldWidth) * miniMapCanvas.width;
  const mapY = (plane.y / worldHeight) * miniMapCanvas.height;
  miniCtx.fillStyle = "#cc66ff";
  miniCtx.beginPath();
  miniCtx.arc(mapX, mapY, 2, 0, Math.PI * 2);
  miniCtx.fill();
});
  // Draw zombies
for (let z of zombies) {
  if (!z.active) continue;

  const mapX = (z.x / worldWidth) * miniMapCanvas.width;
  const mapY = (z.y / worldHeight) * miniMapCanvas.height;

  if (z.isBigBoss) {
    // BigBoss ‚Äì to nh·∫•t, m√†u r√µ r√†ng kh√°c h·∫≥n
    miniCtx.fillStyle = "purple";
    miniCtx.beginPath();
    miniCtx.arc(mapX, mapY, 3, 0, Math.PI * 2);
    miniCtx.fill();
  } 
  else if (z.isBoss) {
    // üî¥ Boss th∆∞·ªùng ‚Äì m√†u ƒë·ªè ho·∫∑c cam, tu·ª≥ b·∫°n
    miniCtx.fillStyle = "orange";
    miniCtx.beginPath();
    miniCtx.arc(mapX, mapY, 2, 0, Math.PI * 2);
    miniCtx.fill();
  } 
  else if (z.type === "miniBoss") {
    // üü† MiniBoss ‚Äì kh√°c boss th∆∞·ªùng ch√∫t
    miniCtx.fillStyle = "gold";
    miniCtx.beginPath();
    miniCtx.arc(mapX, mapY, 1.5, 0, Math.PI * 2);
    miniCtx.fill();
  } 
  else {
    // üî≤ Zombie th∆∞·ªùng ‚Äì vu√¥ng nh·ªè
    miniCtx.fillStyle = "red";
    miniCtx.fillRect(mapX - 1, mapY - 1, 2, 2);
  }
}
  // Draw player
  miniCtx.fillStyle = "#00ccff";  // Xanh d∆∞∆°ng ƒë·ªìng b·ªô t√™n
  miniCtx.beginPath();
  miniCtx.arc(player.x * scaleX, player.y * scaleY, 2, 0, Math.PI * 2);
  miniCtx.fill();
  /* ‚Äî ch·∫•m pet Th·ªè m√†u h·ªìng ‚Äî */
if (petRabbit && petActive) {
  miniCtx.fillStyle = "#ff4dc4";          // h·ªìng ƒë·∫≠m
  miniCtx.beginPath();
  miniCtx.arc(petRabbit.x * scaleX, petRabbit.y * scaleY, 2, 0, Math.PI * 2);
  miniCtx.fill();
}
}
// üé® V·∫Ω ƒë∆∞·ªùng ch√©o s·ªçc (diagonal stripes) tr√™n canvas
function drawDiagonalStripes(ctx, x, y, width, height, stripeColor = "#666", spacing = 10) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(x, y, width, height);
  ctx.clip();

  ctx.strokeStyle = stripeColor;
  ctx.lineWidth = 1; // ƒê·ªô d√†y ƒë∆∞·ªùng s·ªçc

  const maxLength = width + height;
  for (let i = -height; i < maxLength; i += spacing) {
    ctx.beginPath();
    ctx.moveTo(x + i, y);
    ctx.lineTo(x + i - height, y + height);
    ctx.stroke();
  }

  ctx.restore();
}
function drawBloodOrb(ctx) {
    if (!bloodOrbActive) return;
    bloodOrbs.forEach(o => {
        ctx.save();
        ctx.translate(o.x, o.y);

        // Qu·∫£ c·∫ßu t·ª± xoay quanh ch√≠nh n√≥
        ctx.rotate(frame / 100);

        // === V·∫Ω c√°c gai d√†i ===
        ctx.shadowBlur = 6;         // Th√™m blur cho c√°c gai
        ctx.shadowColor = "red";
        for (let i = 0; i < 12; i++) {
            const angle = (Math.PI * 2 / 12) * i;
            const x = Math.cos(angle) * 24; // Gai d√†i h∆°n h·∫≥n
            const y = Math.sin(angle) * 24;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(x, y);
            ctx.strokeStyle = "rgba(50, 0, 0, 0.7)";
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // === V·∫Ω v√≤ng tr√≤n ngo√†i t·ªëi, vi·ªÅn ƒë·ªè b√≥ng ===
        ctx.beginPath();
        ctx.arc(0, 0, 16, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(60, 0, 0, 0.9)";
        ctx.strokeStyle = "rgba(255,0,0,0.7)";
        ctx.lineWidth = 2;
        ctx.fill();
        ctx.stroke();

        // === V·∫Ω v√≤ng tr√≤n trong ƒë·ªè nh·∫°t, trong su·ªët h∆°n ===
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255, 80, 80, 0.05)"; // üìç ƒê·ªè r·∫•t nh·∫°t, trong su·ªët
        ctx.fill();
        ctx.restore();

        // === Icon ü©∏ ch√≠nh gi·ªØa ===
        ctx.font = "1rem Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "white";
        ctx.fillText("ü©∏", o.x, o.y);

        // === Beam nh·ªãp tim ===
        if (!o.target) return;
        const z = o.target;
        ctx.beginPath();
        ctx.moveTo(o.x, o.y);
        const segments = 16;
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const x = o.x + (z.x - o.x) * t;
            const y = o.y + (z.y - o.y) * t + Math.sin(t * 6 * Math.PI + frame / 8) * 5;
            ctx.lineTo(x, y);
        }
        ctx.strokeStyle = "rgba(255,0,0,0.6)";
        ctx.lineWidth = 2;
        ctx.shadowBlur = 4;
        ctx.shadowColor = "red";
        ctx.stroke();
        ctx.shadowBlur = 0;
    });
}
/**
 * T·∫°o hi·ªáu ·ª©ng ch·ªØ "+EXP" bay l√™n khi nh·∫≠n ƒë∆∞·ª£c kinh nghi·ªám.
 * @param {object} target - ƒê·ªëi t∆∞·ª£ng b·ªã ti√™u di·ªát (th∆∞·ªùng l√† zombie).
 * @param {number} amount - L∆∞·ª£ng EXP nh·∫≠n ƒë∆∞·ª£c.
 */
function createExpGainEffect(target, amount) {
    // Ch·ªâ t·∫°o hi·ªáu ·ª©ng n·∫øu nh·∫≠n ƒë∆∞·ª£c EXP
    if (amount <= 0) return;

    // T·∫°o popup s·ªë EXP nh·∫≠n ƒë∆∞·ª£c
    const radius = target.radius || target.size || 15;
    healEffects.push({
        x: target.x + 36 + (Math.random() - 0.5) * 10, // L·ªách sang ph·∫£i
        y: target.y - radius,
        life: 120,
        maxLife: 120,
        text: `+${amount} exp`,
        delay: 0,
        color: 'gold' // M√†u v√†ng
    });
}
/**
 * T·∫°o hi·ªáu ·ª©ng h·ªìi m√°u.
 * @param {object} target - ƒê·ªëi t∆∞·ª£ng ƒë∆∞·ª£c h·ªìi m√°u (player).
 * @param {number} amount - L∆∞·ª£ng m√°u ƒë∆∞·ª£c h·ªìi.
 */
function createHealImpactEffect(target, amount) {
    // T·∫°o popup s·ªë m√°u h·ªìi m√†u xanh l√°
    const radius = target.radius || target.size || 15;
    healEffects.push({
        x: target.x + (Math.random() - 0.5) * 10,
        y: target.y - radius * 2,
        life: 120,
        maxLife: 120,
        text: `+${amount}`,
        delay: 0,
        color: 'lime'
    });
}
/**
 * T·∫°o hi·ªáu ·ª©ng khi m·ªôt m·ª•c ti√™u b·ªã d√≠nh s√°t th∆∞∆°ng.
 * @param {object} target - ƒê·ªëi t∆∞·ª£ng b·ªã d√≠nh s√°t th∆∞∆°ng (player ho·∫∑c zombie).
 * @param {number} amount - L∆∞·ª£ng s√°t th∆∞∆°ng.
 */
function createDamageImpactEffect(target, amount) {
    // N·∫øu ƒë·ªëi t∆∞·ª£ng ch·ªãu s√°t th∆∞∆°ng l√† ng∆∞·ªùi ch∆°i, ph√°t √¢m thanh "hurt"
    if (target === player && amount > 0) {
        playSound('sfx-player-hurt', 0.3); // Ph√°t ·ªü 30% √¢m l∆∞·ª£ng
    }
    let effectColor, particleColor;

    if (target === player) {
        // N·∫øu l√† ng∆∞·ªùi ch∆°i, m√°u v·∫´n m√†u ƒë·ªè
        effectColor = '#ff4c4c';
        particleColor = 'rgba(255, 0, 0, 0.7)';
    } else {
        // N·∫øu l√† zombie, m√°u s·∫Ω m√†u t√≠m
        effectColor = 'violet';                      // M√†u cho ch·ªØ -HP
        particleColor = 'rgba(190, 80, 220, 0.7)'; // M√†u cho h·∫°t "m√°u"
    }

    // T·∫°o popup s·ªë s√°t th∆∞∆°ng (d√πng m√†u ƒë√£ ch·ªçn)
    const radius = target.radius || target.size || 15;
    healEffects.push({
        x: target.x + (Math.random() - 0.5) * 10,
        y: target.y - radius * 2,
        life: 120,
        maxLife: 120,
        text: `-${amount}`,
        delay: 0,
        color: effectColor
    });

    // T·∫°o hi·ªáu ·ª©ng v·ªát m√°u (d√πng m√†u ƒë√£ ch·ªçn)
    for (let i = 0; i < 2; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 1.5 + 0.5;
        particles.push({
            x: target.x, y: target.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 2 + 1,
            color: particleColor,
            alpha: 1,
            fastFade: 0.012
        });
    }
}
// h√†m hi·ªáu ·ª©ng ch·∫∑n ƒë·∫°n
function createShieldImpactEffect(x, y) {
    // T·∫°o ra 5 tia l·ª≠a nh·ªè bay ra ng·∫´u nhi√™n
    for (let i = 0; i < 3; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 1.5 + 0.5;
        particles.push({
            x: x, y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 2 + 1,
            color: `rgba(0, 255, 255, ${Math.random() * 0.5 + 0.5})`, // M√†u xanh cyan
            alpha: 1,
            fastFade: true // Tan bi·∫øn nhanh
        });
    }
}

function createBloodOrbParticleOnBeam(orb) {
    if (!orb.target) return;

    // Random v·ªã tr√≠ d·ªçc theo beam t·ª´ qu·∫£ c·∫ßu t·ªõi zombie
    const t = Math.random(); // T·ª´ 0 ƒë·∫øn 1
    const x = orb.x + (orb.target.x - orb.x) * t;
    const y = orb.y + (orb.target.y - orb.y) * t;

    const dx = orb.x - x;
    const dy = orb.y - y;
    const speed = 0.5 + Math.random() * 0.5;

    particles.push({
        x: x,
        y: y,
        vx: dx * 0.02 * speed,
        vy: dy * 0.02 * speed,
        alpha: 1,
        size: 1 + Math.random() * 1,
        color: 'rgba(255, 0, 0, 0.6)',
        fastFade: true // ƒê√°nh d·∫•u h·∫°t tan nhanh
    });
}
// V·∫Ω Fairy v√† hi·ªáu ·ª©ng h·∫°t
function createFairyParticle(x, y) {
    particles.push({
        // Lo·∫°i h·∫°t n√†y kh√¥ng c·∫ßn type v√¨ d√πng logic m·∫∑c ƒë·ªãnh
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        size: Math.random() * 0.5 + 0.5,
        color: 'rgba(0, 255, 255, 0.7)', // M√†u xanh cyan ph√°t s√°ng
        alpha: 1,
        fastFade: true // M·ªù nhanh
    });
}
// T·∫°o 1 h·∫°t nh·ªè bay ng∆∞·ª£c v√†o qu·∫£ c·∫ßu m·ªói khi h√∫t m√°u
function createBloodOrbParticle(orb) {
  createSuctionDust(orb.x, orb.y, 40, "rgba(255,0,0,0.6)", true);
}
/**
 * Sinh 1 h·∫°t b·ª•i bay v√†o (cx, cy)
 * @param {number} cx, cy   ‚Äì to·∫° ƒë·ªô t√¢m c·∫ßn h√∫t
 * @param {number} spread   ‚Äì kho·∫£ng ƒë·∫∑t h·∫°t (m·∫∑c ƒë·ªãnh 250-300 px)
 * @param {string} color    ‚Äì m√†u/ƒë·ªô m·ªù h·∫°t
 * @param {boolean} fast    ‚Äì tan nhanh (d√πng cho tia m√°u)
 */
function createSuctionDust(cx, cy, spread = 250,
                           color = "rgba(200,200,200,0.5)",
                           fast = false) {
  const a      = Math.random() * Math.PI * 2;
  const r      = spread + Math.random() * 50;
  const px     = cx + Math.cos(a) * r;
  const py     = cy + Math.sin(a) * r;
  const speed  = 0.02;

  particles.push({
    x : px,          y : py,
    vx: (cx - px) * speed,
    vy: (cy - py) * speed,
    size  : 1 + Math.random() * 2,
    alpha : 1,
    color ,
    fastFade: fast // N·∫øu true, h·∫°t s·∫Ω tan bi·∫øn nhanh
  });
}
// H√†m m·ªõi t·∫°o h·∫°t l·ªëc xo√°y cho c·ªïng kh√¥ng gian
function createGateOrbitParticle(gate) {
    const angle = Math.random() * Math.PI * 2;
    // B√°n k√≠nh qu·ªπ ƒë·∫°o s·∫Ω h∆°i l·ªõn h∆°n b√°n k√≠nh c·ªßa c·ªïng m·ªôt ch√∫t
    const orbitRadius = gate.radius * (1.1 + Math.random() * 0.2);

    particles.push({
        type: 'gate_orbit', // Lo·∫°i h·∫°t m·ªõi ƒë·ªÉ x·ª≠ l√Ω ri√™ng
        cx: gate.x,
        cy: gate.y,
        orbitRadius: orbitRadius,
        angle: angle,
        orbitSpeed: 0.01 + Math.random() * 0.015, // T·ªëc ƒë·ªô xoay ng·∫´u nhi√™n
        size: 1 + Math.random() * 1.5,
        alpha: 0.9,
        life: 60 + Math.floor(Math.random() * 30), // Tu·ªïi th·ªç c·ªßa h·∫°t (frame)
        color: 'rgba(255, 220, 0, 0.8)' // M√†u v√†ng
    });
}
// H√†m m·ªõi t·∫°o h·∫°t l·ªëc xo√°y cho h·ªë ƒëen
function createVortexParticle(cx, cy, spawnRadius) {
    const angle = Math.random() * Math.PI * 2;
    // T·∫°o h·∫°t ·ªü m·ªôt kho·∫£ng ng·∫´u nhi√™n b√™n ngo√†i r√¨a
    const radius = spawnRadius * (0.8 + Math.random() * 0.4);

    particles.push({
        type: 'blackhole_vortex', // ƒê√°nh d·∫•u ƒë√¢y l√† h·∫°t l·ªëc xo√°y
        cx: cx,                   // L∆∞u t·ªça ƒë·ªô t√¢m ƒë·ªÉ xoay quanh
        cy: cy,
        orbitRadius: radius,      // Kho·∫£ng c√°ch ban ƒë·∫ßu t·ªõi t√¢m
        angle: angle,             // G√≥c ban ƒë·∫ßu
        pullSpeed: 0.5 + Math.random() * 0.5, // T·ªëc ƒë·ªô b·ªã h√∫t v√†o
        orbitSpeed: 0.02 + Math.random() * 0.001, // T·ªëc ƒë·ªô xoay
        size: 1.5 + Math.random() * 1.5,
        alpha: 0.8,
        color: 'rgba(10, 10, 20, 0.7)' // M√†u t√≠m ƒë·∫≠m v≈© tr·ª•
    });
}
function triggerPlayerDyingEffect() {
  playSound('sfx-player-explode', 0.2); // Ph√°t √¢m thanh n·ªï
    // T·∫°o m·ªôt v·ª• n·ªï c√°c h·∫°t m√†u ƒë·ªè t·∫°i v·ªã tr√≠ ng∆∞·ªùi ch∆°i
    for (let i = 0; i < 150; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 6 + 2; // T·ªëc ƒë·ªô h·∫°t ng·∫´u nhi√™n
        const color = `rgba(255, ${Math.random() * 100}, ${Math.random() * 50}, ${Math.random() * 0.5 + 0.5})`;

        particles.push({
            x: player.x,
            y: player.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: Math.random() * 4 + 2,
            color: color,
            alpha: 1,
            fastFade: true 
        });
    }
}
function handlePlayerDeath() {
      // Ki·ªÉm tra xem k·ªπ nƒÉng Fairy c√≥ th·ªÉ c·ª©u m·∫°ng kh√¥ng
    if (fairyActive && fairyDeathDefyAvailable) {
        fairyDeathDefyAvailable = false; // D√πng h·∫øt 1 l·∫ßn c·ª©u m·∫°ng
        player.hearts = 1000; // H·ªìi l·∫°i 10 HP
        player.hitTimer = 180; // B·∫•t t·ª≠ 3 gi√¢y
        showWarning("ü¶ã Fairy ƒë√£ c·ª©u b·∫°n!");
        
        return; 
    }

    if (player.isDying) return; // NgƒÉn vi·ªác g·ªçi l·∫°i nhi·ªÅu l·∫ßn    
    // D·ª´ng t·∫•t c·∫£ nh·∫°c n·ªÅn ƒëang ph√°t
    stopAllMusic();
    
    // Ph√°t √¢m thanh thua cu·ªôc
    playSound('sfx-game-over');
    player.isDying = true;
    triggerPlayerDyingEffect();

    // Sau 2 gi√¢y, hi·ªán m√†n h√¨nh Game Over
    setTimeout(() => {
        gameOver = true;
        document.getElementById("gameOverPanel").classList.add("visible");
    }, 1500); // 1.5 gi√¢y ƒë·ªÉ hi·ªáu ·ª©ng k·ªãp di·ªÖn ra
}
// C·∫≠p nh·∫≠t tr·∫°ng th√°i c·ªßa t·∫•t c·∫£ c√°c h·∫°t hi·ªáu ·ª©ng trong m·ªói khung h√¨nh
function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];

// LOGIC C·∫¢I TI·∫æN: Di chuy·ªÉn v√† x·ª≠ l√Ω va ch·∫°m cho icon l·ª≠a/bƒÉng
        if (p.type === 'fire_spark' || p.type === 'ice_shard') {
            if (!p.target || !p.target.active) {
                particles.splice(i, 1);
                continue;
            }
            
            const angle = Math.atan2(p.target.y - p.y, p.target.x - p.x);
            p.rotation = angle;
            p.x += Math.cos(angle) * p.speed;
            p.y += Math.sin(angle) * p.speed;

            // N·∫øu icon ƒë√£ bay t·ªõi g·∫ßn m·ª•c ti√™u
            if (distance(p, p.target) < p.speed) {
                // G√¢y s√°t th∆∞∆°ng v√† hi·ªáu ·ª©ng T·∫†I ƒê√ÇY
                if (p.target.active) {
                    dealDamageToZombie(p.target, p.damage);
                    if (p.type === 'fire_spark') {
                        p.target.burnEndTime = Date.now() + 3000;
                        // Th√™m hi·ªáu ·ª©ng h√¨nh ·∫£nh b·ªëc ch√°y
                        p.target.onFireUntil = Date.now() + 400;
                    } else { // 'ice_shard'
                        p.target.slowEndTime = Date.now() + 3000;
                        // Th√™m hi·ªáu ·ª©ng h√¨nh ·∫£nh ƒë√≥ng bƒÉng
                        p.target.onIceUntil = Date.now() + 400;
                    }
                }
                particles.splice(i, 1); // X√≥a icon sau khi ƒë√£ tr√∫ng
            }
            continue;
        }
        // C√°c logic x·ª≠ l√Ω h·∫°t
        if (p.type === 'blackhole_vortex') {
            p.orbitRadius -= p.pullSpeed;
            p.angle += p.orbitSpeed;
            p.x = p.cx + Math.cos(p.angle) * p.orbitRadius;
            p.y = p.cy + Math.sin(p.angle) * p.orbitRadius;
            p.alpha -= 0.015;
            if (p.orbitRadius <= 1 || p.alpha <= 0) {
                particles.splice(i, 1);
                continue;
            }
        } else if (p.type === 'fairy_status_effect') {
            if (p.target && p.target.active) {
                p.angle += 0.1;
                p.x = p.target.x + Math.cos(p.angle) * p.orbitRadius;
                p.y = p.target.y + Math.sin(p.angle) * p.orbitRadius;
                p.life--;
            } else {
                p.life -= 5;
            }
            p.alpha = p.life / p.maxLife;
            if (p.life <= 0) {
                particles.splice(i, 1);
                continue;
            }
        } else if (p.type === 'gate_orbit') {
            p.angle += p.orbitSpeed;
            p.x = p.cx + Math.cos(p.angle) * p.orbitRadius;
            p.y = p.cy + Math.sin(p.angle) * p.orbitRadius;
            p.life--;
            p.alpha = p.life / 90;
            if (p.life <= 0) {
                particles.splice(i, 1);
                continue;
            }
        } else if (p.type === 'aura_particle') {
            p.x += p.vx;
            p.y += p.vy;
            p.alpha -= p.alphaDecay;
        } else {
            if (p.maxDistance !== undefined) {
                const distSq = (p.x - p.originX) ** 2 + (p.y - p.originY) ** 2;
                if (distSq > p.maxDistance ** 2) {
                    p.alpha -= 0.1;
                }
            }
            p.x += p.vx;
            p.y += p.vy;
            if (typeof p.fastFade === 'number') {
                p.alpha -= p.fastFade;
            } else if (p.fastFade === true) {
                p.alpha -= 0.006;
            } else {
                p.alpha -= 0.0006;
            }
        }
        if (p.alpha <= 0) {
            if (particles[i] === p) {
                particles.splice(i, 1);
            }
        }
    }
}
// V·∫Ω t·∫•t c·∫£ c√°c h·∫°t hi·ªáu ·ª©ng l√™n canvas
function drawParticles(ctx) {
    particles.forEach(p => {
        // LOGIC V·∫º M·ªöI: V·∫Ω ƒë·ªëm l·ª≠a v√† m·∫£nh bƒÉng t√πy ch·ªânh
        if (p.type === 'fire_spark' || p.type === 'ice_shard') {
            ctx.save();
            // Di chuy·ªÉn v√† xoay canvas ƒë·∫øn v·ªã tr√≠ v√† h∆∞·ªõng c·ªßa vi√™n ƒë·∫°n
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation || 0);

            if (p.type === 'fire_spark') {
                // V·∫Ω ƒë·ªëm l·ª≠a: G·ªìm m·ªôt "ƒëu√¥i" m√†u cam v√† m·ªôt "ƒë·∫ßu" m√†u v√†ng s√°ng
                // ƒêu√¥i l·ª≠a (m·ªù h∆°n)
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = '#ff8c00'; // DarkOrange
                ctx.beginPath();
                ctx.arc(-3, 0, 5, 0, Math.PI * 2); // V√≤ng tr√≤n l·ªõn h∆°n ·ªü ph√≠a sau
                ctx.fill();

                // ƒê·∫ßu l·ª≠a (s√°ng r√µ)
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = '#ffd700'; // Gold
                ctx.beginPath();
                ctx.arc(2, 0, 4, 0, Math.PI * 2); // V√≤ng tr√≤n nh·ªè h∆°n ·ªü ph√≠a tr∆∞·ªõc
                ctx.fill();
            } else { // 'ice_shard'
                // V·∫Ω m·∫£nh bƒÉng: m·ªôt h√¨nh thoi d√†i, s·∫Øc nh·ªçn
                ctx.fillStyle = '#afeeee'; // PaleTurquoise
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(8, 0);   // M≈©i nh·ªçn
                ctx.lineTo(-4, -4); // C·∫°nh tr√™n
                ctx.lineTo(-8, 0);  // ƒêu√¥i
                ctx.lineTo(-4, 4);  // C·∫°nh d∆∞·ªõi
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            ctx.restore();
            return; // B·ªè qua, kh√¥ng v·∫Ω h·∫°t tr√≤n m·∫∑c ƒë·ªãnh
        }

        // Logic v·∫Ω c√°c h·∫°t m·∫∑c ƒë·ªãnh (gi·ªØ nguy√™n)
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.color;
        ctx.shadowColor = 'purple';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    });
    // Reset ƒë·ªô trong su·ªët v·ªÅ m·∫∑c ƒë·ªãnh
    ctx.globalAlpha = 1;
}
// === üåó NG√ÄY ƒê√äM ===
function updateDayNight() {
    const now = Date.now();
    const deltaTime = (now - lastUpdateTime) / 1000;
    lastUpdateTime = now;

    dayTime += deltaTime / dayDuration;
    if (dayTime >= 1) {
        dayTime -= 1; // Reset v·ªÅ 0 li√™n t·ª•c
        currentDay++; // TƒÉng s·ªë ng√†y khi m·ªôt ng√†y m·ªõi b·∫Øt ƒë·∫ßu        
    }
    // L∆∞u l·∫°i ƒë·ªÉ ch·ªó kh√°c d√πng
    globalDeltaTime = deltaTime;
}

function drawBackgroundByTime(ctx) {
    const w = canvas.width;
    const h = canvas.height;

    // üïí T√≠nh gi·ªù 0 - 23
    const hour = Math.floor(dayTime * 24) % 24;
    // --- B·∫ÆT ƒê·∫¶U LOGIC M·ªöI ---
// N·∫øu l√† 9h s√°ng v√† s·ª± ki·ªán ch∆∞a ƒë∆∞·ª£c k√≠ch ho·∫°t trong ng√†y h√¥m nay
if (hour === 9 && !morningDropTriggered) {
    triggerSupplyDrop();
    morningDropTriggered = true; // ƒê√°nh d·∫•u ƒë√£ k√≠ch ho·∫°t 9h
}
// N·∫øu l√† 12h tr∆∞a v√† s·ª± ki·ªán ch∆∞a ƒë∆∞·ª£c k√≠ch ho·∫°t trong ng√†y h√¥m nay
else if (hour === 12 && !morningDropTriggered12h) {
    triggerSupplyDrop();
    morningDropTriggered12h = true; // ƒê√°nh d·∫•u ƒë√£ k√≠ch ho·∫°t 12h
}
// N·∫øu l√† 15h chi·ªÅu v√† s·ª± ki·ªán ch∆∞a ƒë∆∞·ª£c k√≠ch ho·∫°t trong ng√†y h√¥m nay
else if (hour === 15 && !morningDropTriggered15h) {
    triggerSupplyDrop();
    morningDropTriggered15h = true; // ƒê√°nh d·∫•u ƒë√£ k√≠ch ho·∫°t 15h
}
// Reset l·∫°i c√°c c·ªù khi qua ng√†y m·ªõi (v√≠ d·ª•: l√∫c 0h)
else if (hour === 0) {
    morningDropTriggered = false;
    morningDropTriggered12h = false;
    morningDropTriggered15h = false;
}
    // --- K·∫æT TH√öC LOGIC M·ªöI ---

    // üåó X√°c ƒë·ªãnh ƒë·ªô t·ªëi / s√°ng theo th·ª±c t·∫ø
    let darkness = 0;

    if (hour >= 0 && hour < 4) {
        darkness = 0.6;
    } else if (hour >= 4 && hour < 6) {
        darkness = (6 - hour) / 2 * 0.6; // t·ª´ 0.6 -> 0
    } else if (hour >= 6 && hour < 11) {
        darkness = 0;
    } else if (hour >= 11 && hour < 13) {
        darkness = -0.1; // s√°ng h∆°n b√¨nh th∆∞·ªùng
    } else if (hour >= 13 && hour < 17) {
        darkness = 0;
    } else if (hour >= 17 && hour < 19) {
        darkness = (hour - 17) / 2 * 0.4; // t·ª´ 0 -> 0.4
    } else if (hour >= 19 && hour <= 23) {
        darkness = 0.6;
    }

    // üåì Ph·ªß t·ªëi ho·∫∑c l√†m s√°ng h∆°n
    if (darkness > 0) {
        ctx.fillStyle = `rgba(0, 0, 0, ${darkness})`;
        ctx.fillRect(0, 0, w, h);
    } else if (darkness < 0) {
        ctx.fillStyle = `rgba(255, 255, 255, ${-darkness})`;
        ctx.fillRect(0, 0, w, h);
    }

    // ‚òÄÔ∏è / üåô V·∫Ω bi·ªÉu t∆∞·ª£ng b√°o ng√†y / ƒë√™m
    const iconX = 28;
    const iconY = 82; // V·ªã tr√≠ m·∫∑t tr·ªùi

    if (hour >= 6 && hour < 18) {
        ctx.beginPath();
        ctx.arc(iconX, iconY, 14, 0, Math.PI * 2);
        ctx.fillStyle = '#FFD966';
        ctx.fill();
        ctx.strokeStyle = '#CC9900';
        ctx.stroke();
    } else {
        ctx.beginPath();
        ctx.arc(iconX, iconY, 12, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(200, 200, 255, 0.8)`;
        ctx.fill();
        ctx.beginPath();
        ctx.arc(iconX - 4, iconY - 2, 10, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(0,0,0,0.6)`;
        ctx.fill();
    }

    // üïí S·ªë gi·ªù 0-23
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(`${hour}`, iconX + 20, iconY);
}
const balloonColors = ['#f87171', '#fbbf24', '#34d399', '#60a5fa', '#c084fc'];
function randomizeBackground() {
    backgroundStars = [];
    backgroundBirds = [];
    backgroundTrees = [];
    backgroundClouds = [];
    backgroundPlanes = [];
    backgroundMushrooms = [];
    backgroundRocks = [];
    backgroundBalloons = [];
    backgroundSeeds = [];
    backgroundBigStars = [];

const bigStarCount = isNight() ? 10 : 3;
for (let i = 0; i < bigStarCount; i++) {
    backgroundBigStars.push([
        Math.random() * worldWidth,
        Math.random() * (worldHeight / 2)
    ]);
}
    // ‚≠ê Ng√¥i sao nh·ªè, tr·∫£i d√†i n·ª≠a tr√™n map
const starCount = isNight() ? 300 : 50; // Ban ƒë√™m nhi·ªÅu h∆°n, ban ng√†y √≠t h∆°n
for (let i = 0; i < starCount; i++) {
    backgroundStars.push([
        Math.random() * worldWidth,
        Math.random() * (worldHeight / 2)
    ]);
}
    // üïäÔ∏è Chim, bay ·ªü cao trung b√¨nh
    for (let i = 0; i < 15; i++) {
        backgroundBirds.push([
            Math.random() * worldWidth,
            50 + Math.random() * 100
        ]);
    }

    // üå≥ C√¢y ph√≠a xa d∆∞·ªõi m·∫∑t ƒë·∫•t
    for (let i = 0; i < 50; i++) {
        backgroundTrees.push([
            Math.random() * worldWidth,
            worldHeight - 150 + Math.random() * 20
        ]);
    }

    // ‚òÅÔ∏è M√¢y ƒë∆°n gi·∫£n ph√≠a tr√™n c√¢y
for (let i = 0; i < 5; i++) {
    backgroundClouds.push({
        x: Math.random() * worldWidth,
        y: worldHeight - 250 - Math.random() * 200,
        size: 0.5 + Math.random() * 1.5,
        speed: 0.05 + Math.random() * 0.1,
        isDark: Math.random() < 0.2 // 20% l√† m√¢y x√°m
    });
}
    // ‚úàÔ∏è üõ©Ô∏èM√°y bay ƒë∆°n gi·∫£n ph√≠a tr√™n m√¢y
const planeIcons = ['‚úàÔ∏è', 'üõ©Ô∏è', 'üöÄ'];
// Nh√≥m 1: D·ªçc r√¨a tr√°i world map
for (let i = 0; i < 1; i++) {
    backgroundPlanes.push({
        x: -200 - Math.random() * 200,  // r√¨a tr√°i ngo√†i map
        y: worldHeight / 2 + Math.random() * (worldHeight / 2), // gi·ªØa xu·ªëng d∆∞·ªõi
        vx: 0.5 + Math.random() * 0.3,
        vy: -0.3 - Math.random() * 0.2,
        size: 0.8 + Math.random() * 1.5,
        opacity: 0.4 + Math.random() * 0.5,
        icon: planeIcons[Math.floor(Math.random() * planeIcons.length)]
    });
}
// Nh√≥m 2: Tr·∫£i d√†i ph√≠a d∆∞·ªõi to√†n b·∫£n ƒë·ªì
for (let i = 0; i < 2; i++) {
    backgroundPlanes.push({
        x: Math.random() * worldWidth,
        y: worldHeight - 100 - Math.random() * 100,
        vx: 0.5 + Math.random() * 0.3,
        vy: -0.3 - Math.random() * 0.2,
        size: 0.8 + Math.random() * 1.5,
        opacity: 0.4 + Math.random() * 0.5,
        icon: planeIcons[Math.floor(Math.random() * planeIcons.length)]
    });
}
    // üçÑ N·∫•m d∆∞·ªõi ƒë·∫•t
    for (let i = 0; i < 30; i++) {
        backgroundMushrooms.push([
            Math.random() * worldWidth,
            worldHeight - 70 + Math.random() * 10
        ]);
    }

    // ü™® ƒê√° nh·ªè d∆∞·ªõi ƒë·∫•t
    for (let i = 0; i < 30; i++) {
        backgroundRocks.push([
            Math.random() * worldWidth,
            worldHeight - 70 + Math.random() * 10
        ]);
    }

    // üéà B√≥ng bay m√†u ng·∫´u nhi√™n gi·ªØa map
for (let i = 0; i < 5; i++) {
    backgroundBalloons.push({
        x: Math.random() * worldWidth,
        y: worldHeight - 300 - Math.random() * 100,
        vx: -0.05 + Math.random() * 0.1, // bay nh·∫π tr√°i/ph·∫£i
        speed: 0.15 + Math.random() * 0.1, // bay l√™n ch·∫≠m
        color: balloonColors[Math.floor(Math.random() * balloonColors.length)]
    });
}
    // üåº Hoa b·ªì c√¥ng anh xu·∫•t hi·ªán th·∫•p, bay l√™n cao
for (let i = 0; i < 15; i++) {
    backgroundSeeds.push({
        x: Math.random() * worldWidth,
        y: worldHeight - 300 - Math.random() * 100,
        vx: -0.1 + Math.random() * 0.2, // ng·∫´u nhi√™n t·ª´ -0.1 (tr√°i) -> +0.1 (ph·∫£i)
        speed: 0.02 + Math.random() * 0.05
    });
}
}
function drawCuteCloud(ctx, x, y, scale = 1, isDark = false) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    const gradient = ctx.createLinearGradient(0, -20, 0, 20);
    if (isDark) {
        gradient.addColorStop(0, 'rgba(150, 150, 150, 0.5)');
        gradient.addColorStop(1, 'rgba(100, 100, 100, 0.4)');
    } else {
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
        gradient.addColorStop(1, 'rgba(230, 230, 230, 0.7)');
    }
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(-30, 0, 20, Math.PI * 0.5, Math.PI * 1.5);
    ctx.arc(0, -20, 35, Math.PI, 0);
    ctx.arc(30, 0, 20, Math.PI * 1.5, Math.PI * 0.5);
    ctx.closePath();
    ctx.shadowColor = 'rgba(0,0,0,0.1)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetY = 4;
    ctx.fill();
    ctx.restore();
}
if (prevIsNight !== isNight()) {
    randomizeBackground();
    prevIsNight = isNight();
}

function isNight() {
    const hour = Math.floor(dayTime * 24) % 24;
    return hour >= 19 || hour < 6;
}
// H√¨nh n·ªÅn
function drawBackground() {
    // ===== B·∫¶U TR·ªúI =====
    const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    skyGradient.addColorStop(0, '#0f172a');
    skyGradient.addColorStop(0.6, '#1e3a8a');
    skyGradient.addColorStop(1, '#60a5fa');
    ctx.fillStyle = skyGradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

// ===== SAO NH·ªé =====
backgroundStars.forEach(([x, y], index) => {
    const flicker = (Math.sin(performance.now() / 1000 + index) + 1) / 2; // 0 ~ 1 ch·∫≠m, nh·∫•p nh√°y nh·∫π
    const alpha = isNight() ? 0.5 + flicker * 0.5 : 0.1; // ƒê√™m s√°ng 0.5-1, ng√†y m·ªù nh·∫π
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.fillRect(x - camera.x, y - camera.y, 1, 1);
});

// ===== SAO L·ªöN =====
backgroundBigStars.forEach(([x, y], index) => {
    const flicker = (Math.sin(performance.now() / 1500 + index) + 1) / 2; // ch·∫≠m h∆°n sao nh·ªè
    const alpha = isNight() ? 0.7 + flicker * 0.3 : 0.1;
    ctx.fillStyle = `rgba(255, 214, 64, ${alpha})`; // M√†u v√†ng nh·∫°t gi·ªëng sao th·∫≠t

    ctx.fillRect(x - 2 - camera.x, y - camera.y, 4, 1);
    ctx.fillRect(x - camera.x, y - 2 - camera.y, 1, 4);
});

    // ===== CHIM =====
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.beginPath();
    backgroundBirds.forEach(([x, y]) => {
        ctx.moveTo(x - camera.x, y - camera.y);
        ctx.lineTo(x + 4 - camera.x, y - 3 - camera.y);
        ctx.lineTo(x + 8 - camera.x, y - camera.y);
    });
    ctx.stroke();

    // ===== C√ÇY XA =====
    ctx.fillStyle = '#14532d';
    backgroundTrees.forEach(([x, y]) => {
        ctx.fillRect(x - camera.x, y - camera.y, 4, 40);
        ctx.beginPath();
        ctx.arc(x + 2 - camera.x, y - 10 - camera.y, 10, 0, Math.PI * 2);
        ctx.fill();
    });

    // ===== C√ÇY L·ªöN =====
    ctx.fillStyle = '#14532d';
    ctx.fillRect(120 - camera.x, worldHeight - 180 - camera.y, 10, 100);
    ctx.beginPath();
    ctx.arc(125 - camera.x, worldHeight - 180 - camera.y, 30, 0, Math.PI * 2);
    ctx.fill();
    for (let i = 0; i < 3; i++) {
        let x = 160 + i * 20;
        ctx.fillRect(x - camera.x, worldHeight - 130 - camera.y, 5, 50);
        ctx.beginPath();
        ctx.arc(x + 2.5 - camera.x, worldHeight - 130 - camera.y, 10, 0, Math.PI * 2);
        ctx.fill();
    }

    // ===== M√ÇY CUTE =====
backgroundClouds.forEach((cloud) => {
    cloud.x += cloud.speed;
    if (cloud.x - camera.x > canvas.width + 150) {
        cloud.x = camera.x - 200;
    }
    drawCuteCloud(ctx, cloud.x - camera.x, cloud.y - camera.y, cloud.size, cloud.isDark);
});
    // ===== M√ÅY BAY =====
backgroundPlanes.forEach(plane => {
    plane.x += plane.vx;
    plane.y += plane.vy;

    if (plane.x > worldWidth + 300 || plane.y < camera.y - 300) {
        if (Math.random() < 0.5) {
            // Reset ki·ªÉu d·ªçc r√¨a tr√°i
            plane.x = -200 - Math.random() * 200;
            plane.y = worldHeight / 2 + Math.random() * (worldHeight / 2);
        } else {
            // Reset ki·ªÉu d∆∞·ªõi map tr·∫£i ngang
            plane.x = Math.random() * worldWidth;
            plane.y = worldHeight - 100 - Math.random() * 100;
        }
        plane.vx = 0.5 + Math.random() * 0.3;
        plane.vy = -0.3 - Math.random() * 0.2;
    }

    const posX = plane.x - camera.x;
    const posY = plane.y - camera.y;

    ctx.save();
    ctx.globalAlpha = plane.opacity;
    ctx.font = `${18 * plane.size}px Arial`;
    ctx.fillText(plane.icon, posX, posY);
    ctx.restore();
});
    // ===== C·ªé =====
    ctx.fillStyle = '#16a34a';
    ctx.beginPath();
    ctx.moveTo(0 - camera.x, worldHeight - 80 - camera.y);
    for (let i = 0; i <= worldWidth; i += 30) {
        ctx.lineTo(i + 15 - camera.x, worldHeight - 100 + (i % 60 ? -10 : 10) - camera.y);
    }
    ctx.lineTo(worldWidth - camera.x, worldHeight - 80 - camera.y);
    ctx.lineTo(worldWidth - camera.x, worldHeight - camera.y);
    ctx.lineTo(0 - camera.x, worldHeight - camera.y);
    ctx.closePath();
    ctx.fill();

    // ===== ƒê·∫§T =====
    ctx.fillStyle = '#fbd38d';
    ctx.fillRect(0 - camera.x, worldHeight - 80 - camera.y, worldWidth, 40);
    ctx.fillStyle = '#d97706';
    ctx.fillRect(0 - camera.x, worldHeight - 40 - camera.y, worldWidth, 4);

    // ===== N·∫§M =====
    backgroundMushrooms.forEach(([x, y]) => {
        ctx.fillStyle = '#b91c1c';
        ctx.beginPath();
        ctx.arc(x - camera.x, y - camera.y, 4, 0, Math.PI);
        ctx.fill();
        ctx.fillStyle = '#92400e';
        ctx.fillRect(x - 1 - camera.x, y - camera.y, 2, 5);
    });

    // ===== ƒê√Å =====
    ctx.fillStyle = '#444';
    backgroundRocks.forEach(([x, y]) => {
        ctx.beginPath();
        ctx.ellipse(x - camera.x, y - camera.y, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
    });

    // ===== B√ìNG BAY =====
backgroundBalloons.forEach(balloon => {
    balloon.x += balloon.vx;
    balloon.y -= balloon.speed;

    // Khi bay qu√° cao so v·ªõi camera th√¨ reset v·ªÅ d∆∞·ªõi th·∫•p
    if (balloon.y < camera.y + 100) {
        balloon.x = Math.random() * worldWidth;
        balloon.y = worldHeight - 300 - Math.random() * 100;
        balloon.vx = -0.05 + Math.random() * 0.1;
        balloon.speed = 0.15 + Math.random() * 0.1;
    }

    // V·∫Ω d√¢y nh·ªè
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.beginPath();
    ctx.moveTo(balloon.x - camera.x, balloon.y + 20 - camera.y);
    ctx.lineTo(balloon.x - camera.x, balloon.y + 30 - camera.y);
    ctx.stroke();

    // V·∫Ω b√≥ng bay
    ctx.fillStyle = balloon.color;
    ctx.beginPath();
    ctx.ellipse(balloon.x - camera.x, balloon.y - camera.y, 10, 15, 0, 0, Math.PI * 2);
    ctx.fill();

    // Hi·ªáu ·ª©ng s√°ng nh·∫π
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.beginPath();
    ctx.ellipse(balloon.x - 4 - camera.x, balloon.y - 6 - camera.y, 2, 4, 0, 0, Math.PI * 2);
    ctx.fill();
});
    // ===== HOA B·ªí C√îNG ANH =====
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.lineWidth = 0.5;
    backgroundSeeds.forEach((seed) => {
        seed.x += seed.vx;
        seed.y -= seed.speed;

        if (seed.y < camera.y + 100) {
            seed.x = Math.random() * worldWidth;
            seed.y = worldHeight - 300 - Math.random() * 100;
            seed.vx = -0.1 + Math.random() * 0.2;
            seed.speed = 0.02 + Math.random() * 0.05;
        }

        let posX = seed.x - camera.x;
        let posY = seed.y - camera.y;

        ctx.beginPath();
        ctx.moveTo(posX, posY);
        ctx.lineTo(posX, posY + 6);
        ctx.stroke();

        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            let angle = (Math.PI * 2 / 8) * i;
            let endX = posX + Math.cos(angle) * 4;
            let endY = posY + Math.sin(angle) * 2;
            ctx.moveTo(posX, posY);
            ctx.lineTo(endX, endY);
        }
        ctx.stroke();
    });
}
/**
 * V·∫Ω hi·ªáu ·ª©ng H√†o quang H·ªó tr·ª£ d∆∞·ªõi ch√¢n ng∆∞·ªùi ch∆°i
 */
function drawSupportAura(ctx) {
    if (!supportAuraActive) return;

    const centerX = player.x;
    const centerY = player.y + player.size - 5;
    const rotationInner = Date.now() / 4000; // T·ªëc ƒë·ªô xoay c·ªßa hoa vƒÉn b√™n trong
    const rotationOuter = -Date.now() / 5000; // T·ªëc ƒë·ªô xoay ng∆∞·ª£c chi·ªÅu c·ªßa v√≤ng ngo√†i

    // --- B·∫Øt ƒë·∫ßu v·∫Ω v√≤ng tr√≤n b√™n trong (GI·ªÆ NGUY√äN) ---
    const radiusXInner = 50;
    const radiusYInner = 25;
    
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(centerX, centerY, radiusXInner, radiusYInner, 0, 0, Math.PI * 2);
    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radiusXInner);
    gradient.addColorStop(0, 'rgba(100, 80, 20, 0.5)');
    gradient.addColorStop(1, 'rgba(50, 40, 0, 0.4)');
    ctx.fillStyle = gradient;
    ctx.fill();
    ctx.clip(); 
    
    ctx.strokeStyle = `rgba(255, 215, 0, 0.7)`;
    ctx.lineWidth = 1.5;
    ctx.shadowColor = "gold";
    ctx.shadowBlur = 10;
    
    auraCrackLines.forEach(line => {
        const r_x1 = line.x1 * Math.cos(rotationInner) - line.y1 * Math.sin(rotationInner);
        const r_y1 = line.x1 * Math.sin(rotationInner) + line.y1 * Math.cos(rotationInner);
        const r_x2 = line.x2 * Math.cos(rotationInner) - line.y2 * Math.sin(rotationInner);
        const r_y2 = line.x2 * Math.sin(rotationInner) + line.y2 * Math.cos(rotationInner);
        ctx.beginPath();
        ctx.moveTo(centerX + r_x1, centerY + r_y1 * 0.5);
        ctx.lineTo(centerX + r_x2, centerY + r_y2 * 0.5);
        ctx.stroke();
    });
    ctx.restore();
    // --- K·∫øt th√∫c v·∫Ω v√≤ng tr√≤n b√™n trong ---


    // --- (M·ªöI) V·∫Ω v√≤ng tr√≤n b√™n ngo√†i c√≥ hoa vƒÉn v√† xoay ng∆∞·ª£c chi·ªÅu ---
    const radiusXOuter = 52; // B√°n k√≠nh v√≤ng ngo√†i l·ªõn h∆°n
    const radiusYOuter = 26;

    ctx.save();
    // 1. V·∫Ω vi·ªÅn ph√°t s√°ng
    ctx.beginPath();
    ctx.ellipse(centerX, centerY, radiusXOuter, radiusYOuter, 0, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255, 230, 150, 0.3)`;
    ctx.lineWidth = 2;
    ctx.shadowColor = "gold";
    ctx.shadowBlur = 10;
    ctx.stroke();

    // 2. V·∫Ω hoa vƒÉn l√† c√°c ch·∫•m nh·ªè xoay ng∆∞·ª£c chi·ªÅu
    const numDots = 40;
    for (let i = 0; i < numDots; i++) {
        const angle = (Math.PI * 2 / numDots) * i + rotationOuter;
        const dotRadius = 0.5;
        const dotX = centerX + Math.cos(angle) * radiusXOuter;
        const dotY = centerY + Math.sin(angle) * radiusYOuter;

        ctx.beginPath();
        ctx.arc(dotX, dotY, dotRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 230, 150, 0.8)';
        ctx.fill();
    }
    ctx.restore();
}
function drawAuraLightBeams(ctx) {
    if (!supportAuraActive) return;

    ctx.save();
    auraLightBeams.forEach(beam => {
        const groundY = player.y + player.size - 5;
        const height = 100; // Chi·ªÅu cao c·ªßa c·ªôt s√°ng

        // T·∫°o gradient m·ªù d·∫ßn v·ªÅ ph√≠a tr√™n
        const gradient = ctx.createLinearGradient(beam.x, groundY, beam.x, groundY - height);
        gradient.addColorStop(0, `rgba(255, 215, 0, ${beam.alpha * 0.5})`);
        gradient.addColorStop(1, `rgba(255, 215, 0, 0)`);
        
        ctx.fillStyle = gradient;
        ctx.fillRect(beam.x - beam.width / 2, groundY - height, beam.width, height);
    });
    ctx.restore();
}
// H√†m con ƒë·ªÉ v·∫Ω 2 ƒë√≥m s√°ng cho m·ªôt hi·ªáu ·ª©ng buff c·ª• th·ªÉ
function drawSingleBuffEffect(effect) {
    const centerX = player.x;
    const centerY = player.y;
    const baseRadius = player.size + 15;

    // --- T√≠nh to√°n v·ªã tr√≠ v√† v·∫Ω v·ªát s√°ng (Trail) ---
    const trailLength = 5;
    for (let i = 1; i <= trailLength; i++) {
        const trailAngle = effect.angle - (0.05 * i);
        const radiusX = baseRadius + Math.sin(trailAngle / 2) * 8;
        const radiusY = baseRadius * 0.6;
        const x1 = centerX + Math.cos(trailAngle) * radiusX;
        const y1 = centerY + Math.sin(trailAngle * 2) * radiusY;
        const x2 = centerX - Math.cos(trailAngle) * radiusX;
        const y2 = centerY - Math.sin(trailAngle * 2) * radiusY;

        const alpha = 1.0 - (i / trailLength);
        ctx.globalAlpha = alpha * 0.5;
        ctx.fillStyle = effect.color;

        ctx.beginPath();
        ctx.arc(x1, y1, 3 - i * 0.5, 0, Math.PI * 2); // K√≠ch th∆∞·ªõc ƒë√≥m s√°ng
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x2, y2, 3 - i * 0.5, 0, Math.PI * 2);
        ctx.fill();
    }

    // --- V·∫Ω ƒê√≥m s√°ng ch√≠nh ---
    ctx.globalAlpha = 1.0;
    const currentRadiusX = baseRadius + Math.sin(effect.angle / 2) * 8;
    const currentRadiusY = baseRadius * 0.6;
    const currentX1 = centerX + Math.cos(effect.angle) * currentRadiusX;
    const currentY1 = centerY + Math.sin(effect.angle * 2) * currentRadiusY;
    const currentX2 = centerX - Math.cos(effect.angle) * currentRadiusX;
    const currentY2 = centerY - Math.sin(effect.angle * 2) * currentRadiusY;

    ctx.fillStyle = effect.color;
    ctx.beginPath();
    ctx.arc(currentX1, currentY1, 3, 0, Math.PI * 2); // K√≠ch th∆∞·ªõc ƒë√≥m s√°ng
    ctx.fill();
    ctx.beginPath();
    ctx.arc(currentX2, currentY2, 3, 0, Math.PI * 2);
    ctx.fill();
}
//üé® 9. V·∫Ω khung h√¨nh (draw canvas)
function draw() {
  const now = Date.now(); // d√πng cho c√°c so s√°nh buff, crit, v.v.
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBackground();
  drawBackgroundByTime(ctx);
  ctx.save();
  ctx.translate(-camera.x, -camera.y); // d·ªãch to√†n b·ªô h·ªá t·ªça ƒë·ªô theo camera
// --- V·∫º T·∫§T C·∫¢ C√ÅC M√ÅI V√íM AN TO√ÄN ---
    safeZones.forEach(zone => {
        if (zone.active) { // <-- Ch·ªâ v·∫Ω zone ƒëang active
            ctx.save();
            const pulse = Math.sin(Date.now() / 400 + zone.id) * 5;
            ctx.beginPath();
            ctx.arc(zone.x, zone.y, zone.radius + pulse, 0, Math.PI * 2);

            const gradient = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, zone.radius + pulse);
            gradient.addColorStop(0, "rgba(0, 255, 255, 0)");
            gradient.addColorStop(0.8, "rgba(0, 255, 255, 0.2)");
            gradient.addColorStop(1, "rgba(0, 255, 255, 0.5)");

            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.strokeStyle = "rgba(0, 255, 255, 0.8)";
            ctx.lineWidth = 2;
            ctx.shadowColor = "#00ffff";
            ctx.shadowBlur = 15;
            ctx.stroke();
            
            ctx.font = "bold 24px Segoe UI";
            ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.shadowBlur = 10;
            ctx.shadowColor = "#00ffff";
            ctx.fillText(zone.name, zone.x, zone.y);

            ctx.restore();
        }
    });
    
    // D√≤ng n√†y s·∫Ω t·ª± ƒë·ªông v·∫Ω c√°c shop ƒëang active
    drawShopNPC(ctx);
// --- K·∫æT TH√öC V·∫º M√ÅI V√íM ---

// üß± V·∫Ω t∆∞·ªùng d√†y c√≥ s·ªçc ch√©o
ctx.fillStyle = "#123"; // n·ªÅn t·ªëi
ctx.fillRect(0, 0, worldWidth, wallThickness); // Tr√™n
ctx.fillRect(0, worldHeight - wallThickness, worldWidth, wallThickness); // D∆∞·ªõi
ctx.fillRect(0, 0, wallThickness, worldHeight); // Tr√°i
ctx.fillRect(worldWidth - wallThickness, 0, wallThickness, worldHeight); // Ph·∫£i

// üé® V·∫Ω s·ªçc ch√©o l√™n t·ª´ng c·∫°nh
drawDiagonalStripes(ctx, 0, 0, worldWidth, wallThickness); // Tr√™n
drawDiagonalStripes(ctx, 0, worldHeight - wallThickness, worldWidth, wallThickness); // D∆∞·ªõi
drawDiagonalStripes(ctx, 0, 0, wallThickness, worldHeight); // Tr√°i
drawDiagonalStripes(ctx, worldWidth - wallThickness, 0, wallThickness, worldHeight); // Ph·∫£i
// (M·ªöI) V·∫Ω H√†o quang H·ªó tr·ª£ d∆∞·ªõi ch√¢n
drawSupportAura(ctx);
drawAuraLightBeams(ctx);
  // 1. V·∫º C√ÅC ƒê√ìM S√ÅNG ·ªû PH√çA SAU PLAYER
  for (const buff in buffEffects) {
      const effect = buffEffects[buff];
      // Ki·ªÉm tra xem ƒë√≥m s√°ng c√≥ ƒëang ·ªü n·ª≠a tr√™n qu·ªπ ƒë·∫°o kh√¥ng
      if (effect.active && Math.sin(effect.angle * 2) < 0) {
          ctx.save();
          ctx.shadowColor = effect.color;
          ctx.shadowBlur = 15;
          drawSingleBuffEffect(effect);
          ctx.restore();
      }
  }
  // 2. V·∫º PLAYER
if (!player.isDying && player.size > 0.1) {
// üéØ V·∫Ω t√™n ng∆∞·ªùi ch∆°i tr√™n ƒë·∫ßu
ctx.font = "1rem sans-serif";
ctx.fillStyle = "#00ccff"; // üíô M√†u xanh d∆∞∆°ng
ctx.shadowColor = "#00ccff";
ctx.shadowBlur = 8;
ctx.textAlign = "center";
ctx.textBaseline = "bottom";
ctx.fillText(player.name, player.x, player.y - player.size - 4); // V·∫Ω t√™n tr√™n ƒë·∫ßu player
// --- B·∫ÆT ƒê·∫¶U: V·∫Ω ch·ªØ hi·ªáu ·ª©ng tr√™n ƒë·∫ßu player ---
/*    let buffTextYOffset = player.y - player.size - 20;
    ctx.font = "0.8rem sans-serif";
    ctx.textAlign = "center";
    
    const now = Date.now();
    const isExpActive = now < expBuffEndTime;
    const isCrazyActive = now < crazyBuffEndTime;
    const isPowerActive = now < powerBuffEndTime;
    const isLuckyActive = now < luckyBuffEndTime;
    const isCrazyMadnessActive = now < crazyMadnessTimeEndTime;
    // V·∫º CRAZYMADNESSTIME
    if (now < crazyMadnessTimeEndTime) {
        ctx.fillStyle = "#0613c5"; // M√†u xanh d∆∞∆°ng
        ctx.shadowColor = "white";
        ctx.shadowBlur = 2;
        ctx.fillText("üí¢ CrazyMadnessTime", player.x, buffTextYOffset);
        buffTextYOffset -= 18; // D·ªãch ch·ªØ ti·∫øp theo l√™n tr√™n
    }
    // V·∫Ω ExpUp (M·ªöI)
    if (isExpActive) {
        ctx.fillStyle = "#ffeb3b"; // M√†u v√†ng
        ctx.shadowColor = "white";
        ctx.shadowBlur = 2;
        ctx.fillText("üåø ExpUp", player.x, buffTextYOffset);
        buffTextYOffset -= 18; // D·ªãch ch·ªØ ti·∫øp theo l√™n tr√™n
    }
    
    // V·∫Ω Crazy
    if (isCrazyActive) {
        ctx.fillStyle = "#f59e0b";
        ctx.shadowColor = "white";
        ctx.shadowBlur = 2;
        ctx.fillText("üçÇ CrazyUp", player.x, buffTextYOffset);
        buffTextYOffset -= 18;
    }
    
    // V·∫Ω Power
    if (isPowerActive) {
        ctx.fillStyle = "#ef4444";
        ctx.shadowColor = "white";
        ctx.shadowBlur = 2;
        ctx.fillText("üçÅ PowerUp", player.x, buffTextYOffset);
        buffTextYOffset -= 18;
    }

    // V·∫Ω Lucky
    if (isLuckyActive) {
        ctx.fillStyle = "#22c55e";
        ctx.shadowColor = "white";
        ctx.shadowBlur = 2;
        ctx.fillText("üçÄ LuckyUp", player.x, buffTextYOffset);
    }

    ctx.shadowBlur = 0; // Reset hi·ªáu ·ª©ng */
    // --- K·∫æT TH√öC: V·∫Ω ch·ªØ hi·ªáu ·ª©ng tr√™n ƒë·∫ßu player ---
ctx.shadowBlur = 0; // reset sau khi v·∫Ω
ctx.shadowColor = "transparent";
// V·∫Ω h√¨nh tr√≤n player
if (disguiseActive) {
    // --- (M·ªöI) LOGIC C·∫¢NH B√ÅO NH·∫§P NH√ÅY ---
    const remainingTime = disguiseEndTime - Date.now();
    let shouldDraw = true;

    // N·∫øu th·ªùi gian c√≤n l·∫°i d∆∞·ªõi 2 gi√¢y
    if (remainingTime < 3000 && remainingTime > 0) {
        // Nh·∫•p nh√°y m·ªói 150 mili gi√¢y
        if (Math.floor(Date.now() / 150) % 2 === 0) {
            shouldDraw = false;
        }
    }
    
    // Ch·ªâ v·∫Ω n·∫øu kh√¥ng trong giai ƒëo·∫°n "t·∫Øt" c·ªßa hi·ªáu ·ª©ng
    if (shouldDraw) {
        // üê∏ V·∫Ω ·∫øch thay cho player
        ctx.save();
        ctx.font = "2rem serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "lime";
        ctx.shadowBlur = 8;
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = "white";
        ctx.fillText("üê∏", player.x, player.y);
        ctx.restore();
    }
} else {
  // üßç V·∫Ω player b√¨nh th∆∞·ªùng
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);

  if (levelUpGlowTime > 0) {
    ctx.shadowBlur = 4;
    ctx.shadowColor = "gold";
    ctx.fillStyle = "gold";
  } else {
    ctx.shadowBlur = 0;
    ctx.shadowColor = "transparent";
    ctx.fillStyle = (player.hitTimer % 10 < 5) ? "#ff4c4c" : "#00ff00";
  }
}
  ctx.fill();
  ctx.lineWidth = 2.2;
  ctx.strokeStyle = "rgba(0, 255, 255, 0.4)";
  ctx.shadowColor = "rgba(0, 255, 255, 0.25)";
  ctx.stroke();
  drawPlayerHealthBar(ctx);
  drawPlayerStaminaBar(ctx)
    // 3. V·∫º C√ÅC ƒê√ìM S√ÅNG ·ªû PH√çA TR∆Ø·ªöC PLAYER
  for (const buff in buffEffects) {
      const effect = buffEffects[buff];
      // Ki·ªÉm tra xem ƒë√≥m s√°ng c√≥ ƒëang ·ªü n·ª≠a d∆∞·ªõi qu·ªπ ƒë·∫°o kh√¥ng
      if (effect.active && Math.sin(effect.angle * 2) >= 0) {
          ctx.save();
          ctx.shadowColor = effect.color;
          ctx.shadowBlur = 15;
          drawSingleBuffEffect(effect);
          ctx.restore();
      }
  }
      // ‚ú®‚ú® D·ªúI TO√ÄN B·ªò KH·ªêI V·∫º M·∫ÆT V√Ä MI·ªÜNG V√ÄO ƒê√ÇY ‚ú®‚ú®
    if (zombies.length > 0) {
        const target = zombies.reduce((a, b) => distance(a, player) < distance(b, player) ? a : b);
        const angle = Math.atan2(target.y - player.y, target.x - player.x);
        const eyeOffsetX = Math.cos(angle) * (player.size * 0.3); // ƒêi·ªÅu ch·ªânh theo size
        const eyeOffsetY = Math.sin(angle) * (player.size * 0.3);
        const mouthOffsetX = Math.cos(angle) * (player.size * 0.5);
        const mouthOffsetY = Math.sin(angle) * (player.size * 0.5);

        // M·∫Øt tr√°i
        ctx.beginPath();
        ctx.arc(player.x + eyeOffsetX - (player.size * 0.2), player.y + eyeOffsetY - (player.size * 0.2), 2, 0, Math.PI * 2);
        ctx.fillStyle = "white";
        ctx.fill();

        // M·∫Øt ph·∫£i
        ctx.beginPath();
        ctx.arc(player.x + eyeOffsetX + (player.size * 0.2), player.y + eyeOffsetY - (player.size * 0.2), 2, 0, Math.PI * 2);
        ctx.fill();

        // Mi·ªáng
        ctx.beginPath();
        ctx.arc(player.x + mouthOffsetX, player.y + mouthOffsetY + (player.size * 0.15), 2, 0, Math.PI);
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1;
        ctx.stroke();
    }
}
if (playerTeleportState.isTeleporting || playerTeleportState.alpha < 1) {
    ctx.restore();
}

// üé≠ V·∫Ω c√°c ·∫£o ·∫£nh ph√¢n th√¢n
clones.forEach((c,i) => {
  ctx.save();
  ctx.beginPath();
  ctx.arc(c.x, c.y, player.size * 0.75, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
  ctx.shadowBlur = 8;
  ctx.shadowColor = "#aaaaff";
  ctx.fill();
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = "rgba(0,255,255,0.6)";
  ctx.stroke();
  ctx.restore();

  // üëÅÔ∏è M·∫Øt c·ªßa clone
  ctx.beginPath();
  ctx.arc(c.x - 3, c.y - 5, 1.5, 0, Math.PI * 2);
  ctx.arc(c.x + 3, c.y - 5, 1.5, 0, Math.PI * 2);
  ctx.fillStyle = "white";
  ctx.fill();
// üëÑ Mi·ªáng clone
  ctx.beginPath();
  ctx.arc(c.x, c.y + 4, 5, 0, Math.PI); // n·ª≠a cung tr√≤n h∆∞·ªõng l√™n (mi·ªáng c∆∞·ªùi)
  ctx.strokeStyle = "rgba(0, 100, 200, 0.6)";
  ctx.lineWidth = 1.2;
  ctx.stroke();
   // üè∑Ô∏è T√™n clone (Clone 1, 2, ...)
  ctx.font = "bold 12px Segoe UI";
  ctx.fillStyle = "#00ccff"; // M√†u xanh d∆∞∆°ng
  ctx.textAlign = "center";
  ctx.fillText(`Clone ${i + 1}`, c.x, c.y - 22);
});

  bullets.forEach(b => {
  if (!b.active) return; // üõ° b·ªè qua ƒë·∫°n ƒë√£ b·ªã g·ª°
ctx.save();
ctx.translate(b.x, b.y);
    // N·∫øu l√† ƒë·∫°n c·ªßa Fairy, v·∫Ω n√≥ theo ki·ªÉu kh√°c
    if (b.isFairyBullet) {
        ctx.fillStyle = 'rgba(100, 255, 150, 0.9)';
        ctx.shadowColor = 'lime';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(0, 0, 5, 0, Math.PI * 2);
        ctx.fill();
    }
    // 2. N·∫øu l√† ƒë·∫°n C√† r·ªët c·ªßa Pet
    else if (b.isPetBullet) {
        ctx.font = "1.2rem serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(b.icon, 0, 0); // V·∫Ω icon c√† r·ªët ü•ï
    }
      else if (b.isIceArrow) {
    // üèπ V·∫º M≈®I T√äN BƒÇNG KH√îNG ROTATE/SHADOW (√≠t r√°c, nhanh)
    // D·ª±a v√†o h∆∞·ªõng bay ƒë√£ c√≥ s·∫µn trong b.dx, b.dy
    const vx = b.dx, vy = b.dy;           // vector d·ªçc th√¢n
    const nx = -vy, ny = vx;              // vector vu√¥ng g√≥c (tr√°i/ph·∫£i)

    // Tham s·ªë h√¨nh h·ªçc (c√≥ th·ªÉ tinh ch·ªânh)
    const shaftHalf  = 8;   // n·ª≠a chi·ªÅu d√†i th√¢n
    const headLen    = 6;   // ƒë·ªô d√†i ƒë·∫ßu nh·ªçn
    const headWidth  = 4;   // b·ªÅ ngang ƒë·∫ßu nh·ªçn
    const tailLen    = 6;   // ƒë·ªô l·ªìi c·ªßa l√¥ng ƒëu√¥i
    const tailWidth  = 3;   // b·ªÅ ngang l√¥ng ƒëu√¥i

    // T√¢m ƒëang ·ªü (0,0) v√¨ ƒë√£ translate(b.x, b.y)
    const cx = 0, cy = 0;

    // C√°c ƒëi·ªÉm ch√≠nh
    const shaftStartX = cx - vx * shaftHalf;
    const shaftStartY = cy - vy * shaftHalf;
    const shaftEndX   = cx + vx * shaftHalf;
    const shaftEndY   = cy + vy * shaftHalf;

    const tipX  = cx + vx * (shaftHalf + headLen);
    const tipY  = cy + vy * (shaftHalf + headLen);

    const leftHeadX  = tipX - vx * headLen + nx * headWidth;
    const leftHeadY  = tipY - vy * headLen + ny * headWidth;
    const rightHeadX = tipX - vx * headLen - nx * headWidth;
    const rightHeadY = tipY - vy * headLen - ny * headWidth;

    const tailX = cx - vx * (shaftHalf + tailLen);
    const tailY = cy - vy * (shaftHalf + tailLen);
    const leftTailX  = tailX + nx * tailWidth;
    const leftTailY  = tailY + ny * tailWidth;
    const rightTailX = tailX - nx * tailWidth;
    const rightTailY = tailY - ny * tailWidth;

    // V·∫Ω b·∫±ng line (kh√¥ng path ph·ª©c t·∫°p, kh√¥ng rotate, kh√¥ng shadowBlur)
    ctx.beginPath();
    // th√¢n
    ctx.moveTo(shaftStartX, shaftStartY);
    ctx.lineTo(shaftEndX,   shaftEndY);
    // ƒë·∫ßu nh·ªçn
    ctx.moveTo(tipX, tipY); ctx.lineTo(leftHeadX,  leftHeadY);
    ctx.moveTo(tipX, tipY); ctx.lineTo(rightHeadX, rightHeadY);
    // l√¥ng ƒëu√¥i
    ctx.moveTo(shaftStartX, shaftStartY); ctx.lineTo(leftTailX,  leftTailY);
    ctx.moveTo(shaftStartX, shaftStartY); ctx.lineTo(rightTailX, rightTailY);

    ctx.lineWidth = 2;
    ctx.strokeStyle = "#aef";
    ctx.stroke();
      }
    // 3. C√°c lo·∫°i ƒë·∫°n c√≤n l·∫°i (c·ªßa ng∆∞·ªùi ch∆°i, clone...)
    else {
        if (b.piercing) {
            b.rotation = (b.rotation || 0) + 0.3;
            ctx.rotate(b.rotation);
            ctx.fillStyle = b.color || "cyan";
            ctx.beginPath();
            ctx.moveTo(-6, -3);
            ctx.lineTo(6, 0);
            ctx.lineTo(-6, 3);
            ctx.closePath();
            ctx.shadowBlur = 4;
            ctx.shadowColor = b.color || "cyan";
            ctx.fill();
        } else {
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI * 2);
            ctx.fillStyle = b.color || "yellow";
            ctx.fill();
        }
    }
    ctx.restore();
});
// V·∫Ω tia laze c·ªßa ng∆∞·ªùi ch∆°i
  const eyeOffsetDistance = player.size * 0.4; 

  playerLasers.forEach(laser => {
      // 1. T√≠nh to√°n vector vu√¥ng g√≥c v·ªõi h∆∞·ªõng b·∫Øn ƒë·ªÉ x√°c ƒë·ªãnh v·ªã tr√≠ 2 m·∫Øt
      const perpAngle = laser.angle + Math.PI / 2;
      const offsetX = Math.cos(perpAngle) * eyeOffsetDistance;
      const offsetY = Math.sin(perpAngle) * eyeOffsetDistance;

      let startX, startY;

      // 2. X√°c ƒë·ªãnh ƒëi·ªÉm b·∫Øt ƒë·∫ßu c·ªßa tia lazer d·ª±a tr√™n l√† m·∫Øt 'tr√°i' hay 'ph·∫£i'
      if (laser.eye === 'left') {
          startX = player.x - offsetX;
          startY = player.y - offsetY;
      } else { // 'right'
          startX = player.x + offsetX;
          startY = player.y + offsetY;
      }

      // 3. ƒêi·ªÉm k·∫øt th√∫c c·ªßa tia lazer (r·∫•t xa)
      const endX = startX + Math.cos(laser.angle) * 2000;
      const endY = startY + Math.sin(laser.angle) * 2000;

      // 4. B·∫Øt ƒë·∫ßu v·∫Ω tia lazer (logic style gi·ªØ nguy√™n)
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      
      ctx.strokeStyle = "cyan";
      ctx.lineWidth = 4;
      ctx.shadowColor = "cyan";
      ctx.shadowBlur = 10;
      ctx.globalAlpha = laser.life / 20; // M·ªù d·∫ßn

      ctx.stroke();
      ctx.restore();
  });

// üî´ V·∫Ω ƒë·∫°n t·ª´ boss & mini boss
enemyBullets.forEach(b => {
  ctx.beginPath();
  ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
  ctx.fillStyle = "red";
  ctx.fill();
});
function fmtAbbr(n) {
  n = Math.max(0, Math.floor(n));
  if (n >= 1e9) return (n/1e9).toFixed(1).replace(/\.0$/,'') + 'B';
  if (n >= 1e6) return (n/1e6).toFixed(1).replace(/\.0$/,'') + 'M';
  if (n >= 1e3) return (n/1e3).toFixed(1).replace(/\.0$/,'') + 'k';
  return String(n);
}

// V·∫Ω bigboss
function drawBigBoss(ctx, z) {
    const { x, y, radius, hp } = z; // L·∫•y c√°c thu·ªôc t√≠nh t·ª´ 'z' ƒë·ªÉ d√πng b√™n d∆∞·ªõi
    ctx.save();
    ctx.translate(x, y);

    // √Ånh s√°ng n·ªÅn
    ctx.beginPath();
    ctx.arc(0, 0, radius + 20, 0, Math.PI * 2);
    ctx.fillStyle = "#123";
    ctx.shadowColor = "#a445f5";
    ctx.shadowBlur = 20;
    ctx.fill();
    ctx.shadowBlur = 0;
    // Hi·ªáu ·ª©ng v√≤ng xo√°y b√™n trong boss
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = "#a445f5";
    ctx.lineWidth = 1;

    const numCircles = 6;
    for (let i = 0; i < numCircles; i++) {
        ctx.beginPath();
        ctx.arc(0, 0, (radius / 6) * (i + 1), 0, Math.PI * 2);
        ctx.stroke();
    }

    ctx.globalAlpha = 1;
    ctx.restore();

    // Tay tr√°i
    ctx.beginPath();
    ctx.moveTo(-radius * 0.55, -radius * 0.1);
    ctx.quadraticCurveTo(-radius, 0, -radius * 0.9, radius * 0.3);
    ctx.quadraticCurveTo(-radius * 0.8, radius * 0.1, -radius * 0.5, 0);
    ctx.closePath();
    ctx.fillStyle = "#4e2d6d";
    ctx.fill();

    // Tay ph·∫£i
    ctx.beginPath();
    ctx.moveTo(radius * 0.55, -radius * 0.1);
    ctx.quadraticCurveTo(radius, 0, radius * 0.9, radius * 0.3);
    ctx.quadraticCurveTo(radius * 0.8, radius * 0.1, radius * 0.5, 0);
    ctx.closePath();
    ctx.fill();

    // Ch√¢n tr√°i (d√†i h∆°n)
    ctx.beginPath();
    ctx.moveTo(-20, radius * 0.4);
    ctx.lineTo(-30, radius * 0.8);
    ctx.lineTo(-10, radius * 0.8);
    ctx.lineTo(0, radius * 0.4);
    ctx.closePath();
    ctx.fill();

    // Ch√¢n ph·∫£i (d√†i h∆°n)
    ctx.beginPath();
    ctx.moveTo(20, radius * 0.4);
    ctx.lineTo(30, radius * 0.8);
    ctx.lineTo(10, radius * 0.8);
    ctx.lineTo(0, radius * 0.4);
    ctx.closePath();
    ctx.fill();

    // C∆° th·ªÉ
    ctx.beginPath();
    ctx.moveTo(-radius * 0.6, -radius * 0.1);
    ctx.bezierCurveTo(-radius * 0.75, radius * 0.3, -30, radius * 0.6, 0, radius * 0.5);
    ctx.bezierCurveTo(30, radius * 0.6, radius * 0.75, radius * 0.3, radius * 0.6, -radius * 0.1);
    ctx.closePath();
    ctx.fillStyle = "#4e2d6d";
    ctx.fill();

    // B·ª•ng r√°ch
    ctx.beginPath();
    ctx.moveTo(-15, 20);
    ctx.lineTo(0, 30);
    ctx.lineTo(15, 20);
    ctx.lineTo(0, 40);
    ctx.closePath();
    ctx.fillStyle = "#8b1f1f";
    ctx.fill();

    // ƒê·∫ßu
    ctx.beginPath();
    ctx.ellipse(0, -radius * 0.35, 45, 60, 0, 0, Math.PI * 2);
    ctx.fillStyle = "#6f3c9c";
    ctx.fill();
    ctx.strokeStyle = "#26142e";
    ctx.lineWidth = 3;
    ctx.stroke();

    // M·∫Øt ƒë·ªè glow
    function eye(x, y) {
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fillStyle = "#ff3333";
        ctx.shadowColor = "#ff0000";
        ctx.shadowBlur = 12;
        ctx.fill();
        ctx.shadowBlur = 0;
    }
    eye(-18, -radius * 0.4);
    eye(18, -radius * 0.4);

    // L√¥ng m√†y
    ctx.strokeStyle = "#2e163a";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-28, -radius * 0.47);
    ctx.lineTo(-8, -radius * 0.5);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(28, -radius * 0.47);
    ctx.lineTo(8, -radius * 0.5);
    ctx.stroke();

    // T√≥c
    ctx.beginPath();
    ctx.arc(0, -radius * 0.6, 30, Math.PI, 0);
    ctx.fillStyle = "#1e0f2a";
    ctx.fill();

    // M≈©i
    ctx.beginPath();
    ctx.moveTo(-5, -radius * 0.2);
    ctx.lineTo(0, -radius * 0.15);
    ctx.lineTo(5, -radius * 0.2);
    ctx.fillStyle = "#3a1f4d";
    ctx.fill();

    // Mi·ªáng ƒëen + rƒÉng nanh ƒëen
    ctx.beginPath();
    ctx.moveTo(-18, -radius * 0.1);
    ctx.quadraticCurveTo(0, 0, 18, -radius * 0.1);
    ctx.quadraticCurveTo(0, 10, -18, -radius * 0.1);
    ctx.closePath();
    ctx.fillStyle = "#120000";
    ctx.fill();

    // RƒÉng nanh ƒëen nh·ªè
    ctx.fillStyle = "#120000";
    function fang(x, y, h, flip = 1) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + 3 * flip, y + h);
        ctx.lineTo(x - 3 * flip, y + h);
        ctx.closePath();
        ctx.fill();
    }
    fang(-8, -radius * 0.1 + 5, 6);
    fang(8, -radius * 0.1 + 5, 6);

    // V·∫øt n·ª©t ƒë·∫ßu
    ctx.beginPath();
    ctx.moveTo(-10, -radius * 0.6);
    ctx.lineTo(-5, -radius * 0.5);
    ctx.lineTo(-15, -radius * 0.4);
    ctx.lineTo(-5, -radius * 0.3);
    ctx.strokeStyle = "#4b2b60";
    ctx.lineWidth = 2;
    ctx.stroke();

    // S·∫πo m·∫∑t
    ctx.beginPath();
    ctx.moveTo(22, -8);
    ctx.lineTo(18, 3);
    ctx.lineTo(28, 6);
    ctx.strokeStyle = "#8a477e";
    ctx.stroke();

    // S·∫πo ng·ª±c
    ctx.beginPath();
    ctx.moveTo(-18, 28);
    ctx.lineTo(-8, 38);
    ctx.lineTo(-22, 48);
    ctx.stroke();

    // Gi√°p vai
    ctx.fillStyle = "#2b2b2b";
    ctx.beginPath();
    ctx.moveTo(-55, -5);
    ctx.quadraticCurveTo(-90, 10, -70, 35);
    ctx.quadraticCurveTo(-40, 20, -35, 25);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(55, -5);
    ctx.quadraticCurveTo(90, 10, 70, 35);
    ctx.quadraticCurveTo(40, 20, 35, 25);
    ctx.closePath();
    ctx.fill();

    // S·ª´ng v·ª°
    function horn(x, y, flip = 1) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.bezierCurveTo(x + 15 * flip, y - 35, x + 25 * flip, y - 55, x + 10 * flip, y);
        ctx.lineTo(x + 4 * flip, y);
        ctx.closePath();
        ctx.fillStyle = "#444";
        ctx.fill();
        ctx.strokeStyle = "#222";
        ctx.stroke();
    }
    horn(-30, -radius * 0.6, -1);
    horn(30, -radius * 0.6, 1);

    /*// BOSS + HP
    ctx.font = `${radius * 0.3}px sans-serif`;
    ctx.fillStyle = "violet";
    ctx.textAlign = "center";
    ctx.strokeStyle = "#bb99ff";
    ctx.lineWidth = 2;
    ctx.strokeText(`BOSS ${hp}`, 0, -radius - 30); // Th√™m vi·ªÅn ch·ªØ
    ctx.fillText(`BOSS ${hp}`, 0, -radius - 30); // T√™n boss */
    // --- th√™m t√™n v√† level c·ªßa boss (theo local coords) ---
    const lvl = (z.level ?? 1);
const title = `${z.style || 'Boss'} Lv${lvl}`;
/*ctx.font = `${Math.max(12, Math.floor(radius * 0.22))}px sans-serif`;*/
ctx.font = `${radius * 0.3}px sans-serif`;
ctx.fillStyle = "violet";
ctx.textAlign = "center";
ctx.strokeStyle = "#bb99ff";
ctx.lineWidth = 2;
ctx.strokeText(title, 0, -radius - 30);
ctx.fillText(title,   0, -radius - 30);

// --- th√™m thanh HP c·ªßa boss (theo local coords) ---
const maxHp = z.baseHp || z.maxHp || z.hp || 1;
const pct   = Math.max(0, Math.min(1, z.hp / maxHp));
const barW  = Math.max(90, Math.floor(radius * 2)); // chi·ªÅu r·ªông thanh HP
const barH  = Math.max(6,  Math.floor(radius * 0.12)); // chi·ªÅu cao thanh HP
const bx = Math.round(-barW / 2), by = Math.round(radius + 24); // v·ªã tr√≠ thanh HP

// khung
ctx.fillStyle = "rgba(255,255,255,0.15)";
ctx.fillRect(bx, by, barW, barH);
// n·ªÅn
ctx.fillStyle = "rgba(0,0,0,0.4)";
ctx.fillRect(bx + 1, by + 1, barW - 2, barH - 2);
// fill
let color;
if (pct > 0.6) color = "#a855f7"; // m√†u t√≠m
else if (pct > 0.3) color = "#ffca28";
else color = "#f44336";
const fw = Math.max(0, Math.round((barW - 2) * pct));
ctx.fillStyle = color;
ctx.fillRect(bx + 1, by + 1, fw, barH - 2);
// highlight
ctx.fillStyle = "rgba(255,255,255,0.12)";
ctx.fillRect(bx + 1, by + 1, fw, 1);
// vi·ªÅn
ctx.strokeStyle = "rgba(255,255,255,0.2)";
ctx.lineWidth = 1;
ctx.strokeRect(bx + 0.5, by + 0.5, barW - 1, barH - 1);
// --- HP text inside the bar ---
const hpText = `${fmtAbbr(z.hp)} / ${fmtAbbr(maxHp)}`;
ctx.save();
ctx.font = `${Math.max(12, Math.floor(barH * 1))}px sans-serif`; // k√≠ch th∆∞·ªõc ch·ªØ d·ª±a tr√™n chi·ªÅu cao thanh HP
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';

// vi·ªÅn ch·ªØ ƒë·ªÉ d·ªÖ ƒë·ªçc tr√™n n·ªÅn t√≠m
ctx.lineWidth = 1;
ctx.strokeStyle = 'rgba(0,0,0,0.6)';
ctx.strokeText(hpText, bx + barW / 2, by + barH / 2);

// ch·ªØ tr·∫Øng n·ªïi b·∫≠t
ctx.fillStyle = '#fff';
ctx.fillText(hpText, bx + barW / 2, by + barH / 2);
ctx.restore();

    // ‚ú® TH√äM HI·ªÜU ·ª®NG C·∫¢NH B√ÅO KHI BOSS ƒêANG NG·∫ÆM B·∫ÆN
    if (z.isChargingLazer) {
        // V·∫Ω m·ªôt tia laser m·ªèng, m·ªù, m√†u ƒë·ªè t·ª´ boss ƒë·∫øn ng∆∞·ªùi ch∆°i
        const chargeProgress = z.lazerTimer / 2; // 2 l√† CHARGE_TIME
        const alpha = 0.3 + chargeProgress * 0.4; // ƒê·ªô m·ªù tƒÉng d·∫ßn
        
        ctx.save();
        ctx.beginPath();
        // ƒêi·ªÉm b·∫Øt ƒë·∫ßu l√† gi·ªØa 2 m·∫Øt c·ªßa boss
        ctx.moveTo(0, -z.radius * 0.4); 
        // ƒêi·ªÉm k·∫øt th√∫c l√† v·ªã tr√≠ c·ªßa ng∆∞·ªùi ch∆°i (t√≠nh t∆∞∆°ng ƒë·ªëi)
        const relativePlayerX = player.x - z.x;
        const relativePlayerY = player.y - z.y;
        ctx.lineTo(relativePlayerX, relativePlayerY);
        
        ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
        ctx.lineWidth = 1;
        ctx.shadowColor = 'red';
        ctx.shadowBlur = 10;
        ctx.stroke();
        ctx.restore();
        }
        ctx.restore();
}
function drawBigBossLazer(ctx, z) {
    if (!z.isBigBoss || !z.isLazerAttacking || z.lazerAngle === undefined) return;

    ctx.save();
    ctx.translate(z.x, z.y);

    // V·∫Ω v√≤ng tr√≤n ph√°t s√°ng ·ªü t√¢m b·∫Øn
    ctx.save();
    ctx.beginPath();
    ctx.arc(0, 0, 28, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(200,100,255,0.18)";
    ctx.shadowColor = "violet";
    ctx.shadowBlur = 20;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();

    // V·∫Ω v√≤ng tr√≤n nh·ªè h∆°n, ƒë·∫≠m h∆°n ·ªü t√¢m
    ctx.save();
    ctx.beginPath();
    ctx.arc(0, 0, 12, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(200,100,255,0.45)";
    ctx.shadowColor = "violet";
    ctx.shadowBlur = 12;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();

    // V·∫Ω tia lazer
    ctx.rotate(z.lazerAngle);
    ctx.strokeStyle = "rgba(200, 100, 255, 0.7)";
    ctx.lineWidth = 8;
    ctx.shadowColor = "violet";
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    const lazerRange = 600; // ƒê·∫£m b·∫£o bi·∫øn n√†y c√≥ t·ªìn t·∫°i
    ctx.lineTo(lazerRange, 0);
    ctx.stroke();
    ctx.restore();

    // S·ª≠ d·ª•ng 'z' thay v√¨ 'bigBoss'
    const endX = z.x + Math.cos(z.lazerAngle) * lazerRange;
    const endY = z.y + Math.sin(z.lazerAngle) * lazerRange;
    const glowRadius = 30;

    const glow = ctx.createRadialGradient(endX, endY, 0, endX, endY, glowRadius);
    glow.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
    glow.addColorStop(0.4, 'rgba(128, 0, 128, 0.5)');
    glow.addColorStop(1, 'rgba(128, 0, 128, 0)');

    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(endX, endY, glowRadius, 0, Math.PI * 2);
    ctx.fill();
}

// V·∫Ω to√†n b·ªô zombie ho·∫°t ƒë·ªông k√®m icon, HP, tr·∫°ng th√°i, bi·ªÉu c·∫£m (t·ªëi ∆∞u fillText)
// V√≤ng l·∫∑p zombie
zombies.forEach(z => { 
    // ‚ú® B·∫ÆT ƒê·∫¶U ƒêO·∫†N M√É TƒÇNG HP M·ªöI ‚ú®
    // Ki·ªÉm tra xem zombie c√≥ s·ªëng s√≥t qua ng√†y m·ªõi kh√¥ng
    if (currentDay > z.lastDayBuffed) {
        const hpIncreaseMultiplier = 1.1; // TƒÉng 10% HP m·ªói ng√†y
        // TƒÉng c·∫£ HP hi·ªán t·∫°i v√† HP g·ªëc ƒë·ªÉ buff c√≥ hi·ªáu l·ª±c vƒ©nh vi·ªÖn
        z.hp = Math.round(z.hp * hpIncreaseMultiplier);
        z.baseHp = Math.round(z.baseHp * hpIncreaseMultiplier);
        z.lastDayBuffed = currentDay; // C·∫≠p nh·∫≠t ng√†y ƒë√£ ƒë∆∞·ª£c buff
        z.isBuffed = true; // T·∫°o hi·ªáu ·ª©ng nh·∫•p nh√°y trong 60 frame (kho·∫£ng 1 gi√¢y)
    }
    // ‚ú® K·∫æT TH√öC ƒêO·∫†N M√É TƒÇNG HP M·ªöI ‚ú®
  if (!z.active) return;
  // üÜï V·∫Ω BigBoss gi·ªëng Boss nh∆∞ng ri√™ng block ƒë·ªÉ d·ªÖ qu·∫£n l√Ω
  if (z.isBigBoss) {
    drawBigBoss(ctx, z);
    drawBigBossLazer(ctx, z);
    return;
  }
ctx.save();

// ‚ú® Glow cho Boss ho·∫∑c MiniBoss
if (z.isBoss || z.type === "miniBoss") {
  ctx.shadowColor = z.color || "#ffffff";
  ctx.shadowBlur = z.isBoss ? 8 : 4;
} else {
  ctx.shadowColor = "transparent";
  ctx.shadowBlur = 0;
}

// üîµ N·∫øu zombie b·ªã stun b·ªüi l√¥i
if (z.stunned && Date.now() < z.stunnedUntil) {
  ctx.shadowColor = "#00e5ff";
  ctx.shadowBlur = 8;
  ctx.fillStyle = "#b3f0ff";
}
// üî• N·∫øu zombie b·ªã tr√∫ng l·ª≠a
else if (z.onFireUntil && Date.now() < z.onFireUntil) {
  ctx.shadowColor = "orange";
  ctx.shadowBlur = 8;
  ctx.fillStyle = "#ffb347";
}
// ‚ùÑÔ∏è N·∫øu zombie b·ªã tr√∫ng bƒÉng
else if (z.onIceUntil && Date.now() < z.onIceUntil) {
  ctx.shadowColor = "#00e5ff";
  ctx.shadowBlur = 8;
  ctx.fillStyle = "#b3e0ff";
}
else {
  ctx.fillStyle = z.color || "#ff69b4";
}

// üéØ V·∫Ω h√¨nh tr√≤n zombie
ctx.beginPath();
ctx.arc(z.x, z.y, z.radius, 0, Math.PI * 2);
ctx.fill();
ctx.restore();

// V·∫Ω chi ti·∫øt d·ª±a tr√™n style c·ªßa zombie
switch (z.style) {
    case "Walker": // Zombie ƒëi b·ªô th√¥ng th∆∞·ªùng
        ctx.fillStyle = "#333";
        ctx.fillRect(z.x - 5, z.y - 10, 10, 4); // V·∫øt n·ª©t tr√™n ƒë·∫ßu
        break;

    case "Brute": // Zombie to kh·ªèe, tr√¢u b√≤
        ctx.fillStyle = "#4a4a4a"; // Gi√°p vai
        ctx.fillRect(z.x - 15, z.y - 8, 30, 8);
        ctx.fillStyle = "darkred"; // M·∫Øt ƒë·ªè
        ctx.beginPath();
        ctx.arc(z.x, z.y, 4, 0, Math.PI * 2);
        ctx.fill();
        break;

    case "Spitter": // Zombie phun ƒë·ªôc
        ctx.fillStyle = "yellow"; // T√∫i ƒë·ªôc
        ctx.beginPath();
        ctx.arc(z.x, z.y + 4, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "orange";
        ctx.stroke();
        break;

    case "Mutant": // Zombie ƒë·ªôt bi·∫øn
        ctx.fillStyle = "purple"; // C√°c kh·ªëi u
        ctx.beginPath();
        ctx.arc(z.x - 8, z.y - 8, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(z.x + 10, z.y, 8, 0, Math.PI * 2);
        ctx.fill();
        break;
    case "Cyber":
      ctx.fillStyle = "#00ffff";
      ctx.fillRect(z.x - 10, z.y - 3, 20, 6);
      break;
    case "Hunter":
      ctx.fillStyle = "#654321";
      ctx.fillRect(z.x - 4, z.y - 8, 8, 16);
      ctx.fillStyle = "#432";
      ctx.fillRect(z.x - 6, z.y + 6, 12, 4);
      break;
    case "Shadow":
      ctx.fillStyle = "#333";
      ctx.fillRect(z.x - 10, z.y - 4, 20, 8);
      ctx.fillStyle = "red";
      ctx.fillRect(z.x - 5, z.y - 2, 10, 4);
      break;
    case "Arcanist":
      ctx.fillStyle = "purple";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 12, Math.PI, 2 * Math.PI);
      ctx.fill();
      ctx.fillStyle = "#ff0";
      ctx.fillRect(z.x - 3, z.y - 5, 6, 10);
      break;
    case "Soldier":
      ctx.fillStyle = "green";
      ctx.fillRect(z.x - 10, z.y - 8, 20, 5);
      ctx.fillStyle = "#444";
      ctx.fillRect(z.x - 3, z.y, 6, 12);
      break;
    case "Robot":
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 3, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#888";
      ctx.fillRect(z.x - 8, z.y + 4, 16, 4);
      break;
    case "Knight":
      ctx.fillStyle = "#999";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 4, 10, 0, Math.PI);
      ctx.fill();
      ctx.fillStyle = "#555";
      ctx.fillRect(z.x - 6, z.y, 12, 4);
      break;
    case "Rogue":
      ctx.strokeStyle = "orange";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(z.x, z.y, 6, 0, Math.PI * 2);
      ctx.stroke();
      break;
    case "Wraith":
      ctx.fillStyle = "#333";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "aqua";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 4, 2.5, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Astronaut":
      ctx.strokeStyle = "#ccc";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(z.x, z.y, 14, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillStyle = "#999";
      ctx.fillRect(z.x - 4, z.y + 2, 8, 4);
      break;
    case "Beast":
      ctx.fillStyle = "brown";
      ctx.fillRect(z.x - 5, z.y + 5, 10, 6);
      ctx.fillStyle = "#333";
      ctx.fillRect(z.x - 3, z.y - 6, 6, 3);
      break;
    case "Spectre":
      ctx.fillStyle = "lime";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#0f0";
      ctx.stroke();
      break;
    case "Ninja":
      ctx.fillStyle = "#111";
      ctx.fillRect(z.x - 8, z.y - 8, 16, 16);
      ctx.fillStyle = "red";
      ctx.fillRect(z.x - 4, z.y - 2, 8, 4);
      break;
    case "Samurai":
      ctx.fillStyle = "#444";
      ctx.fillRect(z.x - 10, z.y - 6, 20, 12);
      ctx.strokeStyle = "#c00";
      ctx.strokeRect(z.x - 10, z.y - 6, 20, 12);
      break;
    case "Alien":
      ctx.fillStyle = "lime";
      ctx.beginPath();
      ctx.ellipse(z.x, z.y, 10, 14, 0, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Skeleton":
      ctx.fillStyle = "#ddd";
      ctx.fillRect(z.x - 6, z.y - 10, 12, 20);
      ctx.strokeStyle = "#000";
      ctx.strokeRect(z.x - 6, z.y - 10, 12, 20);
      break;
    case "Mage":
      ctx.fillStyle = "violet";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 4, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "yellow";
      ctx.fillRect(z.x - 2, z.y + 2, 4, 10);
      break;
    case "Ghost":
      ctx.fillStyle = "#aaa";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 14, 0, Math.PI);
      ctx.fill();
      ctx.fillRect(z.x - 14, z.y, 28, 10);
      break;
    case "Monk":
      ctx.fillStyle = "#964B00";
      ctx.fillRect(z.x - 6, z.y - 8, 12, 16);
      ctx.fillStyle = "gold";
      ctx.fillRect(z.x - 3, z.y, 6, 10);
      break;
    case "Cyborg":
      ctx.fillStyle = "#999";
      ctx.fillRect(z.x - 10, z.y - 6, 20, 12);
      ctx.fillStyle = "red";
      ctx.fillRect(z.x + 6, z.y - 2, 4, 4);
      break;
    case "Shaman":
      ctx.fillStyle = "green";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "white";
      ctx.fillRect(z.x - 2, z.y - 8, 4, 16);
      break;
    case "Demon":
      ctx.fillStyle = "darkred";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#444";
      ctx.fillRect(z.x - 6, z.y, 12, 8);
      break;
    case "Angel":
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "gold";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 14, 4, 0, Math.PI * 2);
      ctx.stroke();
      break;
    case "Guardian":
      ctx.fillStyle = "#555";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.strokeStyle = "yellow";
      ctx.strokeRect(z.x - 10, z.y - 10, 20, 20);
      break;
    case "Pilot":
      ctx.fillStyle = "#005588";
      ctx.fillRect(z.x - 8, z.y - 8, 16, 16);
      ctx.fillStyle = "#eee";
      ctx.fillRect(z.x - 4, z.y - 4, 8, 4);
      break;
    case "Engineer":
      ctx.fillStyle = "#b8860b";
      ctx.fillRect(z.x - 10, z.y - 6, 20, 12);
      ctx.fillStyle = "#222";
      ctx.fillRect(z.x - 2, z.y - 2, 4, 4);
      break;
    case "Android":
      ctx.fillStyle = "#666";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "blue";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 5, 3, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Starfighter":
      ctx.fillStyle = "#800080";
      ctx.beginPath();
      ctx.moveTo(z.x - 10, z.y + 10);
      ctx.lineTo(z.x, z.y - 10);
      ctx.lineTo(z.x + 10, z.y + 10);
      ctx.closePath();
      ctx.fill();
      break;
    case "Commander":
      ctx.fillStyle = "#333366";
      ctx.fillRect(z.x - 12, z.y - 8, 24, 16);
      ctx.fillStyle = "gold";
      ctx.fillRect(z.x - 8, z.y - 4, 16, 8);
      break;
    case "Medic":
      ctx.fillStyle = "#fff";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "red";
      ctx.fillRect(z.x - 8, z.y - 2, 16, 4);
      ctx.fillRect(z.x - 2, z.y - 8, 4, 16);
      break;
    case "Barbarian":
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(z.x - 8, z.y - 10, 16, 20);
      ctx.fillStyle = "#555";
      ctx.fillRect(z.x - 10, z.y - 12, 20, 4);
      break;
    case "Paladin":
      ctx.fillStyle = "#ffd700";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "#4682B4";
      ctx.fillRect(z.x - 6, z.y - 6, 12, 12);
      break;
    case "Druid":
      ctx.fillStyle = "#228B22";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "brown";
      ctx.fillRect(z.x - 4, z.y - 12, 8, 4);
      break;
    case "Necromancer":
      ctx.fillStyle = "#000";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "darkgreen";
      ctx.beginPath();
      ctx.arc(z.x, z.y - 4, 6, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Archer":
      ctx.fillStyle = "#556B2F";
      ctx.fillRect(z.x - 8, z.y - 8, 16, 16);
      ctx.strokeStyle = "brown";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(z.x + 5, z.y - 10);
      ctx.lineTo(z.x + 15, z.y);
      ctx.stroke();
      break;
    case "Sorcerer":
      ctx.fillStyle = "#8A2BE2";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#ffff00";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 5, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Bard":
      ctx.fillStyle = "#DC143C";
      ctx.fillRect(z.x - 8, z.y - 8, 16, 16);
      ctx.fillStyle = "#DAA520";
      ctx.beginPath();
      ctx.arc(z.x, z.y + 8, 6, 0, Math.PI * 2);
      ctx.fill();
      break;
    case "Cleric":
      ctx.fillStyle = "#F8F8FF";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "#B22222";
      ctx.fillRect(z.x - 2, z.y - 10, 4, 20);
      break;
    case "Vampire":
      ctx.fillStyle = "#8B0000";
      ctx.beginPath();
      ctx.ellipse(z.x, z.y, 12, 18, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.fillRect(z.x - 2, z.y + 8, 4, 4);
      break;
    case "Werewolf":
      ctx.fillStyle = "#696969";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 16, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "brown";
      ctx.beginPath();
      ctx.moveTo(z.x - 8, z.y - 10);
      ctx.lineTo(z.x - 4, z.y - 16);
      ctx.lineTo(z.x, z.y - 10);
      ctx.fill();
      break;
    case "Goblin":
      ctx.fillStyle = "#3CB371";
      ctx.beginPath();
      ctx.ellipse(z.x, z.y, 10, 15, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#8B4513";
      ctx.beginPath();
      ctx.moveTo(z.x + 6, z.y - 8);
      ctx.lineTo(z.x + 10, z.y - 12);
      ctx.lineTo(z.x + 12, z.y - 8);
      ctx.fill();
      break;
    case "Elf":
      ctx.fillStyle = "#008000";
      ctx.beginPath();
      ctx.ellipse(z.x, z.y, 10, 16, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "lightgoldenrodyellow";
      ctx.beginPath();
      ctx.moveTo(z.x + 8, z.y - 10);
      ctx.lineTo(z.x + 14, z.y - 6);
      ctx.lineTo(z.x + 8, z.y - 2);
      ctx.fill();
      break;
    case "Dwarf":
      ctx.fillStyle = "#A52A2A";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(z.x - 8, z.y + 6, 16, 8);
      break;
    case "Orc":
      ctx.fillStyle = "#4B0082";
      ctx.beginPath();
      ctx.arc(z.x, z.y, 16, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#00FF7F";
      ctx.beginPath();
      ctx.moveTo(z.x + 5, z.y + 5);
      ctx.lineTo(z.x + 10, z.y + 10);
      ctx.lineTo(z.x + 5, z.y + 15);
      ctx.fill();
      break;
    case "Detective":
      ctx.fillStyle = "#4682B4";
      ctx.fillRect(z.x - 8, z.y - 10, 16, 20);
      ctx.fillStyle = "#333";
      ctx.fillRect(z.x - 10, z.y - 12, 20, 4);
      break;
    case "Swat":
      ctx.fillStyle = "#2F4F4F";
      ctx.fillRect(z.x - 12, z.y - 12, 24, 24);
      ctx.fillStyle = "#808080";
      ctx.fillRect(z.x - 4, z.y - 10, 8, 4);
      break;
    case "Firefighter":
      ctx.fillStyle = "#FF4500";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "#8B0000";
      ctx.fillRect(z.x - 4, z.y - 12, 8, 4);
      break;
    case "Doctor":
      ctx.fillStyle = "#ADD8E6";
      ctx.fillRect(z.x - 10, z.y - 10, 20, 20);
      ctx.fillStyle = "red";
      ctx.fillRect(z.x - 8, z.y - 2, 16, 4);
      ctx.fillRect(z.x - 2, z.y - 8, 4, 16);
      break;
      
case "Wastelander":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#A9A9A9";
  ctx.fillRect(z.x - 5, z.y - 2.5, 10, 2.5);
  ctx.fillStyle = "black";
  ctx.fillRect(z.x - 2.5, z.y - 6, 5, 1);
  break;
case "Scavenger":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#D2B48C";
  ctx.fillRect(z.x - 5, z.y + 2.5, 10, 2.5);
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.arc(z.x - 2.5, z.y - 6, 1, 0, Math.PI * 2);
  ctx.arc(z.x + 2.5, z.y - 6, 1, 0, Math.PI * 2);
  ctx.fill();
  break;
case "Hunter":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#6B8E23";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 10);
  ctx.fillStyle = "#8B4513";
  ctx.fillRect(z.x - 2.5, z.y - 10, 5, 5);
  break;
case "Plaguebearer":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#800080";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#FF00FF";
  ctx.fillRect(z.x - 4, z.y, 8, 2.5);
  break;
case "Gravekeeper":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#555";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#000";
  ctx.fillRect(z.x - 5, z.y + 10, 10, 2.5);
  ctx.fillStyle = "white";
  ctx.fillRect(z.x - 2.5, z.y - 7.5, 1, 2.5);
  ctx.fillRect(z.x + 1.5, z.y - 7.5, 1, 2.5);
  break;
case "Revenant":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#ADD8E6";
  ctx.beginPath();
  ctx.arc(z.x - 2.5, z.y - 6, 1, 0, Math.PI * 2);
  ctx.arc(z.x + 2.5, z.y - 6, 1, 0, Math.PI * 2);
  ctx.fill();
  break;
case "Stalker":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#2F4F4F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#B22222";
  ctx.fillRect(z.x - 5, z.y, 10, 2.5);
  ctx.fillStyle = "black";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 6, 2.5, 0, Math.PI * 2);
  ctx.fill();
  break;
case "Abomination":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#FF4500";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#8B0000";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 10);
  ctx.fillRect(z.x, z.y - 10, 2.5, 5);
  break;
case "Wraith":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "rgba(173, 216, 230, 0.7)";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "black";
  ctx.fillRect(z.x - 2.5, z.y - 6, 5, 1);
  break;
case "Butcher":
  ctx.fillStyle = "#556B2F";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#BDB76B";
  ctx.beginPath();
  ctx.arc(z.x, z.y - 5, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#BDB76B";
  ctx.fillRect(z.x - 9, z.y, 4, 7.5);
  ctx.fillRect(z.x + 5, z.y, 4, 7.5);
  ctx.fillStyle = "#4B0082";
  ctx.fillRect(z.x - 5, z.y + 10, 4, 7.5);
  ctx.fillRect(z.x + 1, z.y + 10, 4, 7.5);
  ctx.fillStyle = "#DCDCDC";
  ctx.fillRect(z.x - 5, z.y - 5, 10, 15);
  ctx.fillStyle = "#B22222";
  ctx.fillRect(z.x - 5, z.y + 2.5, 10, 5);
  ctx.fillStyle = "black";
  ctx.fillRect(z.x - 2.5, z.y - 7.5, 5, 2.5);
  break;
}

// ‚ö° Hi·ªáu ·ª©ng ƒëi·ªán ƒë·ªông khi b·ªã stun b·ªüi l√¥i
if (z.stunnedByThunder && Date.now() < z.stunnedThunderUntil) {
    // Hi·ªáu ·ª©ng tia ƒëi·ªán ƒë·ªông
    ctx.save();
    ctx.strokeStyle = "#00ffff"; // Xanh ƒëi·ªán s√°ng h∆°n
    ctx.lineWidth = 1;
    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = 8;
    for (let i = 0; i < 2; i++) {
        const angle = Math.random() * Math.PI * 2;
        const r1 = z.radius + 2;
        const r2 = z.radius + 4 + Math.random() * 4;
        ctx.beginPath();
        ctx.moveTo(z.x + Math.cos(angle) * r1, z.y + Math.sin(angle) * r1);
        ctx.lineTo(z.x + Math.cos(angle) * r2, z.y + Math.sin(angle) * r2);
        ctx.stroke();
    }
    ctx.restore();
}

// üî• Hi·ªáu ·ª©ng l·ª≠a ƒë·ªông khi b·ªã tr√∫ng l·ª≠a
if (z.onFireUntil && Date.now() < z.onFireUntil) {
    ctx.save();
    // L·ªõp s√°ng cam ph·ªß ngo√†i (ch·ªâ 1 l·∫ßn shadowBlur)
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    ctx.arc(z.x, z.y, z.radius + 2, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(255,120,0,0.25)";
    ctx.shadowColor = "orange";
    ctx.shadowBlur = 8;
    ctx.fill();
    ctx.shadowBlur = 0;

    // V·∫Ω 2 ng·ªçn l·ª≠a ƒë·ªông (fill, kh√¥ng blur)
    for (let i = 0; i < 2; i++) {
        const angle = (Math.PI * 2 / 2) * i + frame / 15;
        const len = 10 + Math.sin(frame / 7 + i + frame / 10) * 3;
        ctx.save();
        ctx.translate(z.x + Math.cos(angle) * (z.radius - 2), z.y + Math.sin(angle) * (z.radius - 2));
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(2, -len / 2, 0, -len);
        ctx.quadraticCurveTo(-2, -len / 2, 0, 0);
        ctx.fillStyle = "rgba(255,140,0,0.85)";
        ctx.globalAlpha = 0.8;
        ctx.fill();
        ctx.restore();
    }
    ctx.restore();
}

// ‚ùÑÔ∏è Hi·ªáu ·ª©ng bƒÉng ƒë·ªông khi b·ªã tr√∫ng bƒÉng
if (z.onIceUntil && Date.now() < z.onIceUntil) {
    ctx.save();
    // L·ªõp bƒÉng ph·ªß ngo√†i (ch·ªâ 1 l·∫ßn shadowBlur)
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.arc(z.x, z.y, z.radius + 2, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(180,220,255,0.45)";
    ctx.shadowColor = "#b3e0ff";
    ctx.shadowBlur = 8;
    ctx.fill();
    ctx.shadowBlur = 0;

    // V·∫Ω 2 tinh th·ªÉ bƒÉng nh·ªè (fill, kh√¥ng blur)
    for (let i = 0; i < 2; i++) {
        const angle = (Math.PI * 2 / 2) * i + frame / 30;
        const len = 7 + Math.sin(frame / 8 + i) * 1.5;
        ctx.save();
        ctx.translate(z.x + Math.cos(angle) * (z.radius + 4), z.y + Math.sin(angle) * (z.radius + 4));
        ctx.rotate(angle + frame / 40);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(2, -len / 2);
        ctx.lineTo(0, -len);
        ctx.lineTo(-2, -len / 2);
        ctx.closePath();
        ctx.fillStyle = "#e0f7fa";
        ctx.globalAlpha = 0.7;
        ctx.fill();
        ctx.restore();
    }
    ctx.restore();
}
// --- V·∫Ω ch·ªØ hi·ªáu ·ª©ng tr√™n ƒë·∫ßu zombie ---
let yOffset = 0;

// V·∫Ω ch·ªØ "CHO√ÅNG"
if (z.stunnedByThunder && Date.now() < z.stunnedThunderUntil) {
    ctx.save();
    ctx.font = "0.8rem Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.fillStyle = "#00ffff";
    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = 12;
    ctx.globalAlpha = 0.92;
    ctx.fillText("Cho√°ng", z.x, z.y - z.radius - 18 - yOffset);
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
    ctx.restore();
    yOffset += 20;
}

// V·∫Ω ch·ªØ "Ch√°y"
if (z.burnEndTime && Date.now() < z.burnEndTime) {
    ctx.save();
    ctx.font = "0.8rem Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.fillStyle = "orange";
    ctx.shadowColor = "red";
    ctx.shadowBlur = 10;
    ctx.fillText("Ch√°y", z.x, z.y - z.radius - 18 - yOffset);
    ctx.restore();
    yOffset += 20;
}
// V·∫Ω ch·ªØ "Ch√°y" cho burn t·ª´ v≈© kh√≠
if (z.weaponBurnUntil && now < z.weaponBurnUntil) {
  ctx.save();
  ctx.font = "0.8rem Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillStyle = "orange";
  ctx.shadowColor = "red";
  ctx.shadowBlur = 10;
  ctx.fillText("Ch√°y", z.x, z.y - z.radius - 18 - (yOffset || 0));
  ctx.restore();
  yOffset = (yOffset || 0) + 20;
}

// V·∫Ω ch·ªØ "Ch·∫≠m"
if (z.slowEndTime && Date.now() < z.slowEndTime) {
    ctx.save();
    ctx.font = "0.8rem Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.fillStyle = "#87ceeb";
    ctx.shadowColor = "blue";
    ctx.shadowBlur = 10;
    ctx.fillText("Ch·∫≠m", z.x, z.y - z.radius - 18 - yOffset);
    ctx.restore();
    yOffset += 20;
}
// Burn t·ª´ SPECIAL v≈© kh√≠
if (z.weaponBurnUntil && now < z.weaponBurnUntil) {
  if (!z._wburnTick || now - z._wburnTick >= 1000) {
    z._wburnTick = now;
    const d = Math.max(1, Math.round((playerUpgrades.damageBoost || 1) * (z.weaponBurnDpsMul || 0.15)));
    dealDamageToZombie(z, d);
  }
} else if (z.weaponBurnUntil && now >= z.weaponBurnUntil) {
  z.weaponBurnUntil = 0; z._wburnTick = 0;
}

drawZombieNameAndHP(ctx, z);
// V·∫Ω t√™n zombie b√™n d∆∞·ªõi
// Ch·ªçn m√†u ch·ªØ: n·∫øu l√† Tinh Anh th√¨ m√†u ƒë·ªè, kh√¥ng th√¨ m√†u tr·∫Øng
ctx.fillStyle = z.isElite ? "#ff4c4c" : "#fff"; 
ctx.font = "12px Arial";
ctx.textAlign = "center";
ctx.shadowBlur = 0;
/*ctx.fillText(z.style || 'Normal', z.x, z.y + z.radius + 16); // V·∫Ω t√™n zombie b√™n d∆∞·ªõi*/

// === üÜï fillText g·ªôp to√†n b·ªô th√¥ng tin ===
ctx.save();

// üß† Font chung
ctx.fillStyle = "#fff";
ctx.textAlign = "center";
ctx.textBaseline = "middle";

/*// üÖ∞Ô∏è V·∫Ω c·∫•p + HP tr√™n ƒë·∫ßu zombie
let levelChar = "";
if (z.isBoss) levelChar = "SS";
else if (z.type === "miniBoss") levelChar = "S";
else levelChar = String.fromCharCode(96 + (z.level || 1));

// ‚ú® Gi·∫£m k√≠ch th∆∞·ªõc font n·∫øu l√† boss ho·∫∑c mini boss
let levelFontSize = z.radius * 0.9; // m·∫∑c ƒë·ªãnh cho zombie th∆∞·ªùng
if (z.type === "miniBoss") levelFontSize = z.radius * 0.6;
if (z.isBoss) levelFontSize = z.radius * 0.5;

ctx.font = `${levelFontSize}px sans-serif`;
ctx.textAlign = "center";
ctx.textBaseline = "middle"; // V·ªã tr√≠ icon zombie
ctx.fillStyle = z.color || "#fff";
// 1. T·∫°o chu·ªói HP c∆° b·∫£n
let hpText = `${levelChar}-${z.hp}`;
// 2. N·∫øu zombie v·ª´a ƒë∆∞·ª£c buff, th√™m d·∫•u "+" v√†o chu·ªói
if (z.isBuffed) {
    hpText += "*";
}
// 3. V·∫Ω chu·ªói text cu·ªëi c√πng l√™n m√†n h√¨nh
ctx.fillText(hpText, z.x, z.y - z.radius - 8);*/

// üßü V·∫Ω icon zombie ·ªü gi·ªØa th√¢n
ctx.font = `${z.radius * 1.5}px sans-serif`;
const iconChar = z.isBoss ? "üíÄ" : "";
ctx.fillText(iconChar, z.x, z.y);

// üò¥ Tr·∫°ng th√°i (ch·ªâ zombie th∆∞·ªùng & c√≥ icon)
// üéØ Hi·ªÉn th·ªã icon h√†nh vi: üò° khi chasing, üò´/üí§Zzz khi wandering (30%)
let behaviorIcon = null;
// Boss s·∫Ω kh√¥ng c√≥ icon tr·∫°ng th√°i
if (!z.isBoss && z.state === "chasing" && z.showStatusIcon) {
  behaviorIcon = "üò°";
} else if (!z.isBoss && z.type !== "miniBoss" && z.state === "wandering") {
  const isSleeping = z.wanderBehavior === "pause";

  // üí§ ƒêang lang thang & ƒë·ª©ng im
  if (isSleeping && isNight()) {
    behaviorIcon = "üí§"; // üíØ lu√¥n hi·ªÉn th·ªã khi ban ƒë√™m
  } else if (z.showStatusIcon) {
    behaviorIcon = isSleeping ? "üí§" : "üò´"; // Ng√†y th∆∞·ªùng theo 30%
  }
}
    // V·∫Ω icon Suy y·∫øu n·∫øu c√≥
if (z.isWeakened && Date.now() < z.weakenEndTime) {
  ctx.font = `${z.radius * 0.8}px sans-serif`; // nh·ªè h∆°n
  ctx.textAlign = "center";                     // canh gi·ªØa
  ctx.textBaseline = "top";
  ctx.fillStyle = "#ff4c4c";
  ctx.fillText("weaken", z.x, z.y - z.radius * 3); // ngay tr√™n ƒë·∫ßu
}

if (behaviorIcon) {
  ctx.font = `${z.radius}px sans-serif`;
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillStyle = "#fff";
  ctx.fillText(behaviorIcon, z.x + z.radius * 0.6, z.y - z.radius * 1.2);
}
ctx.restore();

  // üí¨ Bi·ªÉu c·∫£m (ch·ªâ zombie th∆∞·ªùng m·ªõi c√≥)
  if (!z.isBoss && z.iconToDraw) {
    ctx.save();
    ctx.font = `${z.radius}px sans-serif`;
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillStyle = "#fff";
    ctx.fillText(z.iconToDraw, z.x + z.radius * 0.6, z.y - z.radius * 1.2);
    ctx.restore();
}
});

// V·∫Ω l·ªõp khi√™n n·∫øu ƒëang ho·∫°t ƒë·ªông
function drawHex3D(ctx, x, y, size) {
  const gradient = ctx.createRadialGradient(x, y, size * 0.3, x, y, size);
  gradient.addColorStop(0, "rgba(0,255,255,0.25)");
  gradient.addColorStop(1, "rgba(0,200,255,0.05)");

  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    const angle = Math.PI / 3 * i;
    const px = x + size * Math.cos(angle);
    const py = y + size * Math.sin(angle);
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fillStyle = gradient;
  ctx.strokeStyle = "rgba(0,255,255,0.1)";
  ctx.lineWidth = 0.8;
  ctx.fill();
  ctx.stroke();
}

if (player.shieldActive) {
// V√≤ng tr√≤n ngo√†i c√πng
  const pulse = Math.sin(Date.now() / 200) * 2;
  ctx.save();
  ctx.globalAlpha = 0.6;
  ctx.beginPath();
  ctx.arc(player.x, player.y, 48 + pulse, 0, Math.PI * 2);
  ctx.strokeStyle = "rgba(0,200,255,0.7)";
  ctx.lineWidth = 4;
  ctx.shadowColor = "#00eaff";
  ctx.shadowBlur = 10;
  ctx.stroke();
  ctx.restore();

// V·∫Ω m·∫°ng l∆∞·ªõi l·ª•c gi√°c ƒë·ªÅu trong khi√™n
const hexSize = 10;
const spacingX = hexSize * Math.sqrt(3);
const spacingY = hexSize * 1.5;
const radius = 45;
const angleOffset = Date.now() / 3000; // G√≥c xoay theo th·ªùi gian

for (let row = -5; row <= 5; row++) {
  for (let col = -5; col <= 5; col++) {
    const offsetX = (row % 2 === 0) ? 0 : spacingX / 2;
    const x0 = col * spacingX + offsetX;
    const y0 = row * spacingY;

    const dx = x0;
    const dy = y0;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < radius) {
// üëâ Xoay ƒëi·ªÉm quanh t√¢m player
      const angle = angleOffset;
      const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
      const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);
      const px = player.x + rotatedX;
      const py = player.y + rotatedY;
      drawHex3D(ctx, px, py, hexSize);
}
}
}
}

// V·∫Ω v·ªá tinh laze üõ∞Ô∏è
satellites.forEach(sat => {
  ctx.save();
  ctx.translate(sat.x, sat.y);
  ctx.shadowBlur = 10;
  ctx.shadowColor = "cyan";
  ctx.fillStyle = "white";
  ctx.font = "1.2rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("üõ∞Ô∏è", 0, 0);
  ctx.restore();
});

explosions.forEach(e => {
  ctx.beginPath();
  ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
  ctx.fillStyle = `rgba(255, 200, 0, ${e.life / 20})`;
  ctx.fill();
});
// V·∫Ω tia laze cho t·ª´ng v·ªá tinh
satellites.forEach(sat => {
  if (sat.laserBeam && sat.laserBeam.life > 0) {
    const x1 = sat.x, y1 = sat.y;
    const angle = sat.laserBeam.angle;
    const x2 = x1 + Math.cos(angle) * 500;
    const y2 = y1 + Math.sin(angle) * 500;

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = "rgba(0, 255, 255, 0.8)";
    ctx.lineWidth = 3;
    ctx.shadowColor = "cyan";
    ctx.shadowBlur = 12;
    ctx.stroke();
    ctx.restore();
  }
});
// V·∫Ω UFO
if (ufoActive) {
ufos.forEach(ufo => {
    // Logic ki·ªÉm tra v√† ƒë·ªïi h∆∞·ªõng bay
    if (Date.now() > ufo.nextDirectionChangeTime) {
        // H·∫øt gi·ªù, t·∫°o t·ªëc ƒë·ªô ng·∫´u nhi√™n m·ªõi
        ufo.speedX = (Math.random() - 0.5) * 2;
        ufo.speedY = (Math.random() - 0.5) * 0.5;

        // ƒê·∫∑t l·∫°i m·ªëc th·ªùi gian cho l·∫ßn ƒë·ªïi h∆∞·ªõng ti·∫øp theo
        ufo.nextDirectionChangeTime = Date.now() + ufo.directionChangeInterval;
    }

    // --- Di chuy·ªÉn UFO ---
    ufo.relativeX += ufo.speedX;
    ufo.relativeY += ufo.speedY;

        // --- Gi·ªØ UFO trong khung h√¨nh (hi·ªáu ·ª©ng "d·ªôi t∆∞·ªùng") ---
        // D·ªôi c·∫°nh tr√°i/ph·∫£i
        if (ufo.relativeX < 0 || ufo.relativeX > canvas.width) {
            ufo.speedX *= -1;
        }
        // D·ªôi c·∫°nh tr√™n/d∆∞·ªõi (trong m·ªôt kho·∫£ng gi·ªõi h·∫°n)
        if (ufo.relativeY < 120 || ufo.relativeY > 360) {
            ufo.speedY *= -1;
        }

        // --- Logic t·∫•n c√¥ng ---
        if (Date.now() > ufo.laserCooldown) {
            // T·ªça ƒë·ªô th·ª±c c·ªßa UFO tr√™n b·∫£n ƒë·ªì
            const ufoWorldX = camera.x + ufo.relativeX;
            const ufoWorldY = camera.y + ufo.relativeY;
            
            // T√¨m zombie g·∫ßn nh·∫•t ƒë·ªÉ b·∫Øn
            const target = zombies.find(z => z.active && distance({x: ufoWorldX, y: ufoWorldY}, z) < 400);

            if (target) {
              playSound('sfx-laser', 0.5);
                const angle = Math.atan2(target.y - ufoWorldY, target.x - ufoWorldX);
                ufo.angle = angle; // L∆∞u g√≥c b·∫Øn ƒë·ªÉ v·∫Ω tia laser
                ufo.laserLife = 30; // Tia laser t·ªìn t·∫°i trong 0.5 gi√¢y

                // G√¢y s√°t th∆∞∆°ng cho t·∫•t c·∫£ zombie tr√™n ƒë∆∞·ªùng b·∫Øn
                zombies.forEach(z => {
                    if (!z.active) return;
                    const dx = Math.cos(angle), dy = Math.sin(angle);
                    const proj = (z.x - ufoWorldX) * dx + (z.y - ufoWorldY) * dy;
                    const perp = Math.abs((z.x - ufoWorldX) * dy - (z.y - ufoWorldY) * dx);
                    if (proj > 0 && proj < 1200 && perp < 20) {
                        dealDamageToZombie(z, ufo.damage);
                    }
                });
            }
            // ƒê·∫∑t l·∫°i th·ªùi gian h·ªìi chi√™u
            ufo.laserCooldown = Date.now() + 1500; // B·∫Øn m·ªói 1.5 gi√¢y
        }
        
        if (ufo.laserLife > 0) ufo.laserLife--;
    });
}
ufos.forEach(ufo => {
    // T√≠nh to√°n t·ªça ƒë·ªô v·∫Ω th·ª±c t·∫ø d·ª±a tr√™n camera v√† v·ªã tr√≠ t∆∞∆°ng ƒë·ªëi
    const drawX = camera.x + ufo.relativeX;
    const drawY = camera.y + ufo.relativeY;

    // UFO icon
    ctx.save();
    ctx.translate(drawX, drawY); // <-- D√πng t·ªça ƒë·ªô m·ªõi
    ctx.shadowBlur = 10;
    ctx.shadowColor = "red";
    ctx.fillStyle = "white";
    ctx.font = "1.4rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("üõ∏", 0, 0);
    ctx.restore();

    // Tia laser ƒë·ªè
    if (ufo.laserLife > 0) {
        const x1 = drawX; // <-- D√πng t·ªça ƒë·ªô m·ªõi
        const y1 = drawY; // <-- D√πng t·ªça ƒë·ªô m·ªõi
        const laserLength = 1200;
        const x2 = x1 + Math.cos(ufo.angle) * laserLength;
        const y2 = y1 + Math.sin(ufo.angle) * laserLength;

        ctx.save();
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = "rgba(255, 0, 0, 0.8)";
        ctx.lineWidth = 3;
        ctx.shadowColor = "red";
        ctx.shadowBlur = 15;
        ctx.stroke();
        ctx.restore();
    }
});
// V·∫Ω c√°c v√≤ng n·ªï ph·ª• c·ªßa bom h·∫°t nh√¢n
extraShockwaves.forEach(sw => {
  ctx.save();
  ctx.beginPath();
  ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2);
  ctx.strokeStyle = sw.color;
  ctx.globalAlpha = sw.alpha;
  ctx.lineWidth = 3;
  ctx.shadowColor = sw.color;
  ctx.shadowBlur = 12;
  ctx.stroke();
  ctx.restore();
});

drawItems();
drawSupplyDrops();
drawEffects();
window.EquipmentDropAPI && EquipmentDropAPI.drawEquipDrops(ctx);

// üé® V·∫Ω v·∫≠t ph·∫©m hi·ªán c√≥ tr√™n m√†n h√¨nh
function drawItems() {
  items.forEach(it => {
    if (!it.active) return;
    ctx.save();

    // C√†i ƒë·∫∑t font ch·ªØ v√† cƒÉn ch·ªânh cho v·∫≠t ph·∫©m
    ctx.font = "0.9rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    let icon, color;

    // Ch·ªçn icon v√† m√†u s·∫Øc ph√π h·ª£p v·ªõi t·ª´ng v·∫≠t ph·∫©m
    switch (it.type) {
      case 'potion':
        icon = "üíä";
        color = "red";
        break;
      case 'lucky':
        icon = "üçÄ";
        color = "#22c55e";
        break;
      case 'power':
        icon = "üçÅ";
        color = "#ef4444";
        break;
      case 'crazy': 
        icon = "üçÇ";
        color = "#f59e0b";
        break;
      case 'exp': 
        icon = "üåø";
        color = "#ffeb3b";
        break;
      case 'magnet':
        icon = "üß≤";
        color = "#8b5cf6"; // M√†u t√≠m
        break;
      case 'secret':
        icon = "‚ùì";
        color = "#ffeb3b"; // M√†u v√†ng
        break;
      case 'expBonus':
        icon = "üåü";
        color = "#ffeb3b"; // M√†u v√†ng
        break;
      case 'crazymadnesstime':
        icon = "üí¢";
        color = "#0613c5"; // M√†u xanh d∆∞∆°ng ƒë·ªìng b·ªô v·ªõi halo v√† UI
        break;
      case 'critRateBuff':
        icon = "‚ú®";
        color = "orange";
        break;
      case 'critDmgBuff':
        icon = "üí•";
        color = "#c084fc"; // D√πng m√†u t√≠m nh·∫°t gi·ªëng m√†u h√†o quang
        break;
      case 'coin':
        icon = "ü™ô";
        color = "gold";
        break;
      case 'energy':
        icon = "‚ö°";
        color = "gold";
        break;
      case 'mana':
        icon = "üí†";
        color = "cyan";
        break;
      case 'hp':
        icon = "‚ù§Ô∏è";
        color = "red";
        break;
      case 'box':
        icon = "üì¶";
        color = "#fff";
        break;
    }

    // T·∫°o hi·ªáu ·ª©ng nh·∫π (b√≥ng ƒë·ªï v√† chuy·ªÉn ƒë·ªông nh·∫π nh√†ng)
    if (icon) {
        ctx.shadowBlur = 3;
        ctx.shadowColor = color;
        ctx.fillStyle = color;
        const bob = Math.sin(frame / 10 + it.x + it.y) * 1; // Hi·ªáu ·ª©ng bobbing nh·∫π
        ctx.fillText(icon, it.x, it.y + bob);
    }
    ctx.restore();
  });
}
// üå©Ô∏è V·∫Ω tia s√©t
function drawLightningBolts() {
    // Ch·ªâ ch·∫°y n·∫øu m·ªôt trong hai k·ªπ nƒÉng (B√£o s√©t ho·∫∑c L√¥i) ƒëang ho·∫°t ƒë·ªông
    if (!lightningActive && !thunderActive) return;
    
    ctx.save();
    
    // V·∫Ω c√°c ƒë√°m m√¢y c·ªßa B√£o s√©t (n·∫øu c√≥)
    if (lightningActive) {
        lightningBolts.forEach(bolt => {
            ctx.font = "2rem serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "yellow";
            ctx.shadowColor = "gold";
            ctx.shadowBlur = 8;
            ctx.fillText("üå©Ô∏è", bolt.x, bolt.y);
        });
    }

    // V·∫Ω c√°c tia s√©t ƒëang ho·∫°t ƒë·ªông (cho c·∫£ hai k·ªπ nƒÉng)
    activeLightningStrikes.forEach(strike => {
        if (strike.type === 'chain') {
            const path = strike.path;
            const alpha = strike.life / 30;
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.lineWidth = 1.5;
            ctx.shadowColor = "white";
            ctx.shadowBlur = 10;
            ctx.stroke();
        } else {
            // --- V·∫Ω S√âT CH√çNH (v√†ng, d√†y, t·ª´ tr√™n tr·ªùi) ---
            const path = strike.path;
            if (path.length < 2) return;
            const endPoint = path[path.length - 1];
            const alpha = strike.life / 60;

            if (strike.life > 35) { 
                ctx.beginPath();
                ctx.arc(endPoint.x, endPoint.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 200, ${alpha * 0.8})`;
                ctx.shadowColor = "yellow"; ctx.shadowBlur = 20;
                ctx.fill(); ctx.shadowBlur = 0;
            }
            
            ctx.shadowColor = "yellow"; ctx.shadowBlur = 20;
            for (let i = 1; i < path.length; i++) {
                const p = i / (path.length - 1);
                const lw = 4 * (1 - p);
                ctx.beginPath();
                ctx.moveTo(path[i-1].x, path[i-1].y);
                ctx.lineTo(path[i].x, path[i].y);
                ctx.strokeStyle = `rgba(255, 255, 0, ${alpha * 0.6})`;
                ctx.lineWidth = lw;
                ctx.stroke();
            }
            
            ctx.shadowBlur = 0;
            for (let i = 1; i < path.length; i++) {
                const p = i / (path.length - 1);
                const lw = 1.5 * (1 - p);
                ctx.beginPath();
                ctx.moveTo(path[i-1].x, path[i-1].y);
                ctx.lineTo(path[i].x, path[i].y);
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.lineWidth = lw;
                ctx.stroke();
            }
        }
    });

    ctx.restore();
}

function drawBlackHole() {
    let sumY = 0;
    let planeCount = 0;
    const BLACK_HOLE_X = worldWidth - 100;
    const FILTER_X = worldWidth - 200;
    // Duy·ªát qua m·ªôt l·∫ßn ƒë·ªÉ v·ª´a l·ªçc m√°y bay v·ª´a t√≠nh t·ªïng v·ªã tr√≠ Y
    for (const p of activePlanes) {
        if (p.x > FILTER_X) {
            sumY += p.y;
            planeCount++;
        }
    }
    // ‚ùå Kh√¥ng c√≥ m√°y bay n√†o g·∫ßn h·ªë ƒëen th√¨ kh√¥ng v·∫Ω
    if (planeCount === 0) return;
    // üéØ T√≠nh trung b√¨nh ƒë·ªô cao
    const blackHoleY = sumY / planeCount;
    // üîµ Hi·ªáu ·ª©ng ph·ªìng nh·∫π
    const pulse = Math.sin(Date.now() / 300);
    const radius = 40 + pulse * 5;
    // üé® V·∫Ω h·ªë ƒëen
    ctx.save();
    ctx.beginPath();
    ctx.arc(BLACK_HOLE_X, blackHoleY, radius, 0, Math.PI * 2);
    ctx.fillStyle = "black";
    ctx.shadowColor = "purple";
    ctx.shadowBlur = 20;
    ctx.fill();
    ctx.restore();
}
if (petRabbit && petActive) {
  const { x, y, radius } = petRabbit;

  /* ‚Äî th√¢n ‚Äî */
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fillStyle   = "#fff0fa";   // th√¢n tr·∫Øng-h·ªìng
  ctx.fill();
  ctx.strokeStyle = "#ff7ad9";   // vi·ªÅn h·ªìng nh·∫°t
  ctx.lineWidth   = 2;
  ctx.stroke();

  /* ‚Äî tai ‚Äî */
  ctx.beginPath();
  ctx.ellipse(x - 6, y - 18, 3, 6, 0, 0, Math.PI * 2);
  ctx.ellipse(x + 6, y - 18, 3, 6, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  /* ‚Äî m·∫Øt ‚Äî */
  ctx.beginPath();
  ctx.arc(x - 4, y - 3, 1.5, 0, Math.PI * 2);
  ctx.arc(x + 4, y - 3, 1.5, 0, Math.PI * 2);
  ctx.fillStyle = "#000";
  ctx.fill();

  /* ‚Äî mi·ªáng ‚Äî */
  ctx.beginPath();
  ctx.arc(x, y + 4, 2, 0, Math.PI);
  ctx.strokeStyle = "#000";
  ctx.stroke();

  /* ‚Äî t√™n ‚ÄúTh·ªè‚Äù ‚Äî */
  ctx.font         = "0.8rem sans-serif";
  ctx.fillStyle    = "#ff7ad9";   // c√πng m√†u vi·ªÅn
  ctx.shadowColor  = "#ff7ad9";
  ctx.shadowBlur   = 8;
  ctx.textAlign    = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText("Th·ªè", x, y - radius - 10);
  ctx.shadowBlur   = 0;
  ctx.shadowColor  = "transparent";
}

// ================== V·∫º C·ªîNG KH√îNG GIAN ==================
if (spaceGateActive && spaceGate && spaceGate.radius > 0.1) { // S·ª≠ d·ª•ng radius > 0.1
    ctx.save();
    // √Åp d·ª•ng hi·ªáu ·ª©ng m·ªù d·∫ßn khi c·ªïng m·ªõi xu·∫•t hi·ªán
    ctx.globalAlpha = spaceGate.alpha;

    const x = spaceGate.x;
    const y = spaceGate.y;
    const radius = spaceGate.radius;

    // L·ªõp h√†o quang b√™n ngo√†i
// L·ªõp h√†o quang b√™n ngo√†i
const pulse = Math.sin(frame * 0.1) * 5;
ctx.beginPath();
// ‚ú® S·ª¨A L·ªñI: D√πng Math.max ƒë·ªÉ ƒë·∫£m b·∫£o b√°n k√≠nh kh√¥ng bao gi·ªù √¢m
ctx.arc(x, y, Math.max(0, radius + pulse), 0, Math.PI * 2); 
ctx.fillStyle = `rgba(255, 100, 0, 0.2)`;
ctx.fill();

    // V√≤ng xo√°y l·ª≠a trung t√¢m
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
    gradient.addColorStop(0, 'rgba(255, 255, 180, 0.9)');
    gradient.addColorStop(0.5, 'rgba(255, 180, 0, 0.8)');
    gradient.addColorStop(1, 'rgba(200, 50, 0, 0.5)');
    
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.fill();

    // Vi·ªÅn ngo√†i ph√°t s√°ng
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.strokeStyle = "gold";
    ctx.lineWidth = 3;
    ctx.shadowColor = "orange";
    ctx.shadowBlur = 15;
    ctx.stroke();

    // C√°c tia l·ª≠a xo√°y b√™n trong
    ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
    ctx.lineWidth = 1.5;
    ctx.shadowColor = "yellow";
    ctx.shadowBlur = 15;
    for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        const startAngle = spaceGate.rotation + (i * Math.PI / 2);
        const endAngle = startAngle + Math.PI * 0.8;
        ctx.arc(x, y, radius * (0.3 + (i * 0.15)), startAngle, endAngle);
        ctx.stroke();
    }
    
    ctx.restore();
}

// ƒêo·∫°n n√†y x·ª≠ l√Ω vi·ªác l√†m m·ªù ng∆∞·ªùi ch∆°i khi d·ªãch chuy·ªÉn, gi·ªØ nguy√™n
if (playerTeleportState.isTeleporting || playerTeleportState.alpha < 1) {
    ctx.save();
    ctx.globalAlpha = playerTeleportState.alpha;
}

drawParticles(ctx);

drawBloodOrb(ctx);
drawBlackHole();
drawLightningBolts(); // üå©Ô∏è V·∫Ω tia s√©t
updateAndDrawHealEffects();
ctx.restore(); // k·∫øt th√∫c d·ªãch chuy·ªÉn camera
drawMiniMap();
// üé® V·∫Ω b·∫£n ƒë·ªì thu nh·ªè
}
/**
 * TH√äM M·ªöI: H√†m v·∫Ω thanh HP cho ng∆∞·ªùi ch∆°i.
 * @param {CanvasRenderingContext2D} ctx - B·ªëi c·∫£nh v·∫Ω c·ªßa canvas.
 */
function drawPlayerHealthBar(ctx) {
    // Kh√¥ng c·∫ßn v·∫Ω n·∫øu kh√¥ng c√≥ m√°u ho·∫∑c m√°u t·ªëi ƒëa
    if (player.hearts <= 0 || !player.maxHearts) {
        return;
    }

    // 1. T√≠nh to√°n c√°c gi√° tr·ªã c·∫ßn thi·∫øt
    const hpPercent = player.hearts / player.maxHearts;
    const barWidth = 50; // Chi·ªÅu r·ªông thanh m√°u
    const barHeight = 3; // Chi·ªÅu cao thanh m√°u
    const barX = player.x - barWidth / 2;
    const barY = player.y + player.size + 5;

    // 2. Ch·ªçn m√†u cho thanh m√°u d·ª±a tr√™n t·ª∑ l·ªá HP
    let barColor;
    if (hpPercent < 0.25) {
        barColor = '#ff4c4c'; // ƒê·ªè khi d∆∞·ªõi 25%
    } else if (hpPercent < 0.75) {
        barColor = '#ffcc00'; // V√†ng khi t·ª´ 25% - 75%
    } else {
        barColor = '#00ff00'; // Xanh l√° khi ƒë·∫ßy m√°u
    }

    // 3. B·∫Øt ƒë·∫ßu v·∫Ω
    ctx.save();

    // V·∫Ω ph·∫ßn n·ªÅn (m√†u x√°m, th·ªÉ hi·ªán l∆∞·ª£ng m√°u ƒë√£ m·∫•t)
    ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
    ctx.fillRect(barX, barY, barWidth, barHeight);

    // V·∫Ω ph·∫ßn m√°u hi·ªán t·∫°i (c√≥ m√†u)
    ctx.fillStyle = barColor;
    ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);

    // (T√πy ch·ªçn) C√≥ th·ªÉ th√™m vi·ªÅn m·ªèng ƒë·ªÉ thanh m√°u n·ªïi b·∫≠t h∆°n
    // ctx.strokeStyle = '#000';
    // ctx.lineWidth = 1;
    // ctx.strokeRect(barX, barY, barWidth, barHeight);

    ctx.restore();
}
function drawPlayerStaminaBar(ctx) {
    if (player.stamina < 0 || !player.staminaMax) {
        return;
    }

    const staminaPercent = player.stamina / player.staminaMax;
    const barWidth = 50;
    const barHeight = 3;
    const barX = player.x - barWidth / 2;
    // T·ªça ƒë·ªô Y c·ªßa thanh stamina, c√°ch thanh HP m·ªôt kho·∫£ng c·ªë ƒë·ªãnh
    const barY = player.y + player.size + 5 + 3; // 3 l√† chi·ªÅu cao c·ªßa thanh HP

    // V·∫Ω n·ªÅn thanh stamina
    ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
    ctx.fillRect(barX, barY, barWidth, barHeight);

    // V·∫Ω ph·∫ßn stamina hi·ªán t·∫°i
    const staminaColor = '#36a2eb'; // M√†u xanh d∆∞∆°ng
    ctx.fillStyle = staminaColor;
    ctx.fillRect(barX, barY, barWidth * staminaPercent, barHeight);
}
// V·∫Ω t√™n v√† thanh HP c·ªßa zombie
function drawZombieNameAndHP(ctx, z) {
  // ====== T√äN + LEVEL TR√äN ƒê·∫¶U ======
  const lvl = (z.level ?? 1);
  const name = `${z.style || 'Zombie'} Lv${lvl}`;
  ctx.save();
  ctx.font = `${Math.max(11, Math.floor(z.radius * 0.8))}px Arial`;
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillStyle = z.isElite ? "#ff4c4c" : "#fff";
  ctx.shadowColor = z.isElite ? "#ff4c4c" : "transparent";
  ctx.shadowBlur = z.isElite ? 6 : 0;
  ctx.fillText(name, z.x, z.y - z.radius - 4);
  ctx.restore();

  // ====== THANH HP D∆Ø·ªöI CH√ÇN ======
  const maxHp = z.baseHp || z.maxHp || z.hp || 1;
  const pct   = Math.max(0, Math.min(1, z.hp / maxHp));

  const barW = Math.max(28, Math.min(64, Math.floor(z.radius * 2))); // Gi·ªõi h·∫°n chi·ªÅu r·ªông
  const barH = Math.max(4,  Math.floor(z.radius * 0.3)); // Chi·ªÅu cao thanh m√°u
  const barX = Math.round(z.x - barW / 2);
  const barY = Math.round(z.y + z.radius + 4);

  ctx.save();
  // vi·ªÅn ngo√†i m·ªù nh·∫π
  ctx.fillStyle = "rgba(255,255,255,0.15)";
  ctx.fillRect(barX, barY, barW, barH);

  // n·ªÅn trong
  ctx.fillStyle = "rgba(0,0,0,0.4)";
  ctx.fillRect(barX + 1, barY + 1, barW - 2, barH - 2);

  // m√†u theo % m√°u
  let color;
  if (pct > 0.6) color = "#a855f7"; // t√≠m (violet-500)
  else if (pct > 0.3) color = "#ffca28";
  else color = "#f44336";

  const fillW = Math.max(0, Math.round((barW - 2) * pct));
  ctx.fillStyle = color;
  ctx.fillRect(barX + 1, barY + 1, fillW, barH - 2);

  // highlight m·ªèng tr√™n ƒë·ªânh thanh ƒë·ªÉ gi·ªëng player
  ctx.fillStyle = "rgba(255,255,255,0.12)";
  ctx.fillRect(barX + 1, barY + 1, fillW, 1);

  // vi·ªÅn m·∫£nh
  ctx.strokeStyle = "rgba(255,255,255,0.2)";
  ctx.lineWidth = 1;
  ctx.strokeRect(barX + 0.5, barY + 0.5, barW - 1, barH - 1);
  ctx.restore();
}

// üé® V·∫Ω t·∫•t c·∫£ hi·ªáu ·ª©ng k·ªπ nƒÉng g·ªçn l·∫°i
function drawEffects() {
  // === V·∫º ƒê√ÅM M√ÇY C·ª¶A M∆ØA KI·∫æM ===
    swordRainClouds.forEach(cloud => {
        ctx.save();
        // V·ªã tr√≠ v·∫Ω = v·ªã tr√≠ camera + v·ªã tr√≠ t∆∞∆°ng ƒë·ªëi c·ªßa m√¢y
        const drawX = camera.x + cloud.relativeX;
        const drawY = camera.y + cloud.relativeY;
        
        ctx.font = "2rem serif";
        ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
        ctx.shadowColor = "rgba(0, 0, 0, 0.3)";
        ctx.shadowBlur = 2;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("‚òÅÔ∏è", drawX, drawY);
        ctx.restore();
    });
    // v·∫Ω c√°c Fairy
    fairies.forEach(fairy => {
        ctx.save();
        ctx.font = "1.2rem serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "cyan";
        ctx.shadowBlur = 8;
        ctx.fillStyle = 'white'; 
        ctx.fillText("ü¶ã", fairy.x, fairy.y);
        ctx.restore();
    });
    
  fireballs.forEach(f => {
    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.shadowBlur = 8;
    ctx.shadowColor = "orange";
    ctx.fillStyle = "orange";
    ctx.font = "1.3rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("üî•", 0, 0);
    ctx.restore();
  });

  iceballs.forEach(f => {
    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.shadowBlur = 8;
    ctx.shadowColor = "#00e5ff";
    ctx.fillStyle = "#00e5ff";
    ctx.font = "1.3rem serif";
// ctx.font = (f.radius * 0.9) + " serif"; K·ªπ nƒÉng to ra khi l√™n level
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("‚ùÑÔ∏è", 0, 0);
    ctx.restore();
  });
// V·∫Ω qu·∫£ c·∫ßu l√¥i
if (thunderActive) {
  thunderBalls.forEach(f => {
    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.shadowBlur = 8;
    ctx.shadowColor = "#00e5ff";
    ctx.fillStyle = "#00e5ff";
    ctx.font = "1rem serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("üîµ", 0, 0);
    // Hi·ªáu ·ª©ng ƒëi·ªán xung quanh
    for (let i = 0; i < 6; i++) {
      const angle = (Math.PI * 2 / 6) * i + frame / 10;
      ctx.beginPath();
      ctx.arc(Math.cos(angle) * 12, Math.sin(angle) * 12, 2, 0, Math.PI * 2);
      ctx.fillStyle = "#b3f0ff";
      ctx.fill();
    }
    ctx.restore();
  });
}

swords.forEach(s => {
    ctx.save();
    ctx.translate(s.x, s.y);
    if (s.state === 'charging') {
  ctx.shadowBlur = 8; // Hi·ªáu ·ª©ng b√≥ng m·ªù
  ctx.shadowColor = '#00ffff';
  ctx.fillStyle = '#00ffff';
} else {
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'white';
}
    ctx.font = "1.2rem serif";
//ctx.font = (s.radius * 0.9) + " serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("üî™", 0, 0);
    ctx.restore();
  });

downwardSwords.forEach(s => {
  ctx.save();
  ctx.translate(s.x, s.y);
  ctx.shadowBlur = 8;
  ctx.shadowColor = '#00ffff';
  ctx.fillStyle = 'white';
  ctx.font = "1.2rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("‚öîÔ∏è", 0, 0);
  ctx.restore();
});
// V·∫Ω t√™n l·ª≠a
missiles.forEach(m => {
  ctx.save();
  ctx.translate(m.x, m.y);
  ctx.shadowColor = m.state === "delay" ? "gray" : "orange";
  ctx.shadowBlur = 8;
  ctx.fillStyle = "white";
  ctx.font = "1.3rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("üöÄ", 0, 0);
  ctx.restore();
});

// üí£ B52 Bombs + üõ¨ M√°y bay
ctx.save();
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.font = "1.3rem serif";
ctx.shadowBlur = 8;
ctx.shadowColor = "black";

// üõ¨ V·∫Ω m√°y bay ƒëang ho·∫°t ƒë·ªông
activePlanes.forEach(plane => {
  ctx.fillStyle = "cyan";
ctx.save();
  ctx.shadowBlur = 4;
  ctx.shadowColor = "cyan";
ctx.translate(plane.x, plane.y);
ctx.scale(plane.scale ?? 1, plane.scale ?? 1);
ctx.globalAlpha = plane.opacity ?? 1;
ctx.fillText("üõ¨", 0, 0);
ctx.restore();
});

// üí£ V·∫Ω t·ª´ng qu·∫£ bom ƒëang r∆°i ho·∫∑c s·∫Øp n·ªï
bombsB52.forEach(bomb => {
  if (bomb.exploded) return;
  ctx.fillStyle = bomb.landed ? "orange" : "white";
  ctx.fillText("üí£", bomb.x, bomb.y);
});

ctx.restore();
// ‚ò¢Ô∏è V·∫Ω bom h·∫°t nh√¢n
nuclearBombs.forEach(bomb => {
// ----------- V·∫Ω bom h·∫°t nh√¢n khi ch∆∞a n·ªï -----------
if (!bomb.exploded) {
  let offsetX = 0, offsetY = 0;

  // üîî N·∫øu c√≤n ‚â§ 3 gi√¢y v√† ƒë√£ ch·∫°m ƒë·∫•t ‚Üí rung l·∫Øc
  if (bomb.landed && bomb.timerAfterLand <= 180) {
    offsetX = (Math.random() - 0.5) * 4;
    offsetY = (Math.random() - 0.5) * 4;
  }

  ctx.save();
  // V·∫Ω icon bom ‚ò¢Ô∏è to, s√°ng (c√≥ rung)
  ctx.font = "2.2rem serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.shadowBlur = 12;
  ctx.shadowColor = "orange";
  ctx.fillStyle = "white";
  ctx.fillText("‚ò¢Ô∏è", bomb.x + offsetX, bomb.y + offsetY);

  // -- N·∫øu ƒë√£ ch·∫°m ƒë·∫•t, v·∫Ω icon üí• v√† gi√¢y countdown n·∫±m ngang --
  if (bomb.landed) {
    const baseY = bomb.y - 35;
    const iconX = bomb.x - 1;
    const secX  = bomb.x + 1;

    // V·∫Ω icon üí• nh·ªè
    ctx.font = "1rem serif";
    ctx.shadowBlur = 2;
    ctx.textAlign = "right";
    ctx.fillStyle = "#ffb300";
    ctx.fillText("üí•", iconX, baseY);

    // V·∫Ω s·ªë gi√¢y nh·ªè, m√†u ƒë·ªè
    ctx.font = "1rem sans-serif";
    ctx.fillStyle = "#ff3333";
    ctx.textAlign = "left";
    let sec = Math.max(1, Math.ceil(bomb.timerAfterLand / 60));
    ctx.fillText(`${sec}`, secX, baseY - 2);
  }

  ctx.restore();
}

// ----------- V·∫Ω hi·ªáu ·ª©ng s√≥ng xung k√≠ch khi bom ph√°t n·ªï -----------
if (bomb.exploded && bomb.shockwave) {
// Hi·ªáu ·ª©ng v√≤ng n·ªï ch√≠nh ‚Äì n√©t to, v√†ng ƒë·∫≠m r√µ r√†ng
  ctx.save();
  ctx.beginPath();
  ctx.arc(bomb.x, bomb.y, bomb.shockwaveRadius, 0, Math.PI * 2);
  ctx.strokeStyle = "rgba(255, 222, 44, 0.88)";   // V√†ng t∆∞∆°i, g·∫ßn nh∆∞ v√†ng nguy√™n ch·∫•t
  ctx.lineWidth = 16;
  ctx.shadowBlur = 20;
  ctx.shadowColor = "#ffec70";
  ctx.globalAlpha = 0.58; // ƒê·∫≠m v√† r√µ
  ctx.stroke();
  ctx.restore();

  // Vi·ªÅn ngo√†i ph·ª• - v√†ng tr·∫Øng, r√µ h∆°n, t·∫°o c·∫£m gi√°c ‚Äúh√†o quang‚Äù
  ctx.save();
  ctx.beginPath();
  ctx.arc(bomb.x, bomb.y, bomb.shockwaveRadius + 8, 0, Math.PI * 2);
  ctx.strokeStyle = "rgba(255,255,180,0.73)";
  ctx.lineWidth = 7;
  ctx.shadowBlur = 20;
  ctx.shadowColor = "#fffbe2";
  ctx.globalAlpha = 0.45;
  ctx.stroke();
  ctx.restore();
}
});
blackHoles.forEach(h => {
  ctx.save();
  ctx.beginPath();
  ctx.arc(h.x, h.y, h.radius, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
  ctx.shadowColor = "purple";
  ctx.shadowBlur = 20;
  ctx.fill();
  ctx.closePath();

  // Icon gi·ªØa h·ªë ƒëen
  ctx.font = "2rem serif";
  ctx.fillStyle = "#fff";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("üï≥Ô∏è", h.x, h.y);
  ctx.restore();
});
// V·∫Ω lazer cho clone
activeCloneLasers.forEach(laser => {
    // T√¨m clone ƒë√£ b·∫Øn ra tia lazer n√†y b·∫±ng ID
    const firingClone = clones.find(c => c.id === laser.cloneId);

    // Ch·ªâ v·∫Ω tia lazer n·∫øu clone ƒë√≥ c√≤n t·ªìn t·∫°i
    if (firingClone) {
        ctx.save();
        ctx.beginPath();
        // ƒêi·ªÉm b·∫Øt ƒë·∫ßu c·ªßa lazer l√† v·ªã tr√≠ HI·ªÜN T·∫†I c·ªßa clone
        ctx.moveTo(firingClone.x, firingClone.y);
        ctx.lineTo(laser.endX, laser.endY);
        
        ctx.strokeStyle = `rgba(255, 100, 255, ${laser.life / 120})`;
        ctx.lineWidth = 6;
        ctx.shadowColor = "#ff00ff";
        ctx.shadowBlur = 20;
        
        ctx.stroke();
        ctx.restore();
    }

  });
}

//üîÅ 10. V√≤ng l·∫∑p ch√≠nh v√† kh·ªüi t·∫°o game
let fps = 0, lastFrameTime = performance.now(), frameCount = 0, lastFpsUpdate = performance.now(); // bi·∫øn c·∫≠p nh·∫≠t FPS

function loop() {
  updateDayNight(); // <-- ch·ªâ g·ªçi 1 l·∫ßn ·ªü ƒë√¢y tr√°nh l·∫∑p l·∫°i
  const now = performance.now();
  frameCount++;

// C·∫≠p nh·∫≠t FPS m·ªói 500ms
if (now - lastFpsUpdate >= 500) {
    fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
    const fpsText = `FPS: ${fps}`;
if (fpsText !== lastFpsText) {
  lastFpsText = fpsText;
  document.getElementById("fpsCounter").innerText = fpsText;
}
    frameCount = 0;
    lastFpsUpdate = now;
}

  update();
  draw();
  frame++;
  
if (frame % 60 === 0 && gameStarted) {
// Gi·ªõi h·∫°n zombie t·ªëi ƒëa l√† 200 - S·ªë l∆∞·ª£ng zombie hi·ªán t·∫°i
if (zombies.length < 200) {
    const spawnCount = Math.min(10, 200 - zombies.length);
    for (let i = 0; i < spawnCount; i++) {
    spawnZombie();
}
}
}
requestAnimationFrame(loop);
}

// ‚ñ∂Ô∏è Kh·ªüi ch·∫°y ban ƒë·∫ßu
spawnZombie();
loop();

//üßº 11. C√°c ƒëo·∫°n kh·ªüi t·∫°o UI sau canvas
// H√†m b·∫Øt ƒë·∫ßu game
function startGame() {
    // 1. X√≥a d·ªØ li·ªáu ƒë√£ l∆∞u khi b·∫Øt ƒë·∫ßu game m·ªõi
    localStorage.removeItem(SAVE_KEY);
    
    // 2. G·ªçi h√†m reset ƒë·ªÉ ƒë∆∞a m·ªçi th·ª© v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
    resetGame();
    
    // 3. C√°c logic b·∫Øt ƒë·∫ßu game nh∆∞ c≈©
    document.getElementById('statsOverlay')?.classList.remove('hidden');
    document.getElementById('skillsOverlay')?.classList.remove('hidden');
    playSound('sfx-game-start', 0.3);
    
    randomizeBackground();
    const nameInput = document.getElementById("playerNameInput");
    player.name = nameInput.value.trim() || "Player";
    document.getElementById("startMenu").style.display = "none";
    gameStarted = true;
    
    // ƒêo·∫°n n√†y ƒë√£ c√≥ trong resetGame n√™n c√≥ th·ªÉ b·ªè, nh∆∞ng ƒë·ªÉ l·∫°i cho ch·∫Øc ch·∫Øn
    waveTimer = waveTime; 
    lastWaveTime = Date.now();
     // B·∫Øt ƒë·∫ßu ch·∫°y b·∫£n tin sau 3 gi√¢y
    if (typeof NewsTicker !== 'undefined' && NewsTicker.start) {
        NewsTicker.start(3000);
    }
    playRandomNormalMusic();
    showUpgradePopup();
    pendingWave = wave;
    updateAmmoDisplay();
}
/**
 * Thi·∫øt l·∫≠p l·∫°i to√†n b·ªô tr·∫°ng th√°i c·ªßa game ƒë·ªÉ b·∫Øt ƒë·∫ßu m·ªôt l∆∞·ª£t ch∆°i m·ªõi.
 * H√†m n√†y kh√¥ng t·∫£i l·∫°i trang, gi√∫p ti·∫øt ki·ªám th·ªùi gian v√† t√†i nguy√™n.
 */
function resetGame() {
    localStorage.removeItem(SAVE_KEY); // X√≥a save c≈© khi ng∆∞·ªùi ch∆°i ch·ªçn ch∆°i l·∫°i
    console.log("Resetting game state...");

    // 1. ·∫®n c√°c giao di·ªán kh√¥ng c·∫ßn thi·∫øt
    document.getElementById('gameOverPanel').classList.remove('visible');
    document.getElementById('pauseMenu').classList.add('hidden');
    
    // 2. Reset c√°c bi·∫øn tr·∫°ng th√°i c·ªët l√µi c·ªßa game
    gameOver = false;
    isPaused = false;
    gameStarted = true; // Game ƒë∆∞·ª£c b·∫Øt ƒë·∫ßu ngay l·∫≠p t·ª©c
    wave = 1;
    waveTimer = waveTime;
    lastWaveTime = Date.now();
    frame = 0;
    currentDay = 1;
    dayTime = 0.25; // Reset l·∫°i th·ªùi gian trong ng√†y v·ªÅ 6h s√°ng
    zombieSpawnedCount = 0;
    bigBossRespawnTimer = 0;
    pendingWave = null;
    // 3. Reset to√†n b·ªô tr·∫°ng th√°i ng∆∞·ªùi ch∆°i v·ªÅ ban ƒë·∫ßu
    player.hearts = 10;
    player.maxHearts = 10;
    lastHpRegenTime = 0;
    player.statPoints = 3; // Cho 3 ƒëi·ªÉm k·ªπ nƒÉng ban ƒë·∫ßu
    // ‚úÖ Reset ƒë√∫ng: mutate c√πng object ƒëang ƒë∆∞·ª£c STAT_DEFS d√πng
if (!window.CharacterPanelState) window.CharacterPanelState = { baseline: null, spent: {} };
window.CharacterPanelState.baseline = null;
const spent = window.CharacterPanelState.spent || (window.CharacterPanelState.spent = {});
spent.damage = 0;
spent.crit = 0;
spent.hp = 0;
spent.stamina = 0;
spent.armor = 0;

// (khuy·∫øn ngh·ªã) ƒë·ªìng b·ªô core stat n·ªÅn ƒë·ªÉ panel ch·ª•p baseline m·ªõi ch√≠nh x√°c
playerUpgrades.damageBoost = 0;
baseCritRate = 0;
player.armor = 0;

// C·∫≠p nh·∫≠t UI
updateStatsOverlay?.();
window.CharacterPanel?.refresh?.();

    player.stamina = 10;
    player.staminaMax = 10;
    player.energy = 0;
    player.mana = 0;
    player.coins = 0;
    player.level = 1;
    player.speed = 1;
    player.exp = 0;
    player.armor = 0;
    player.currentLevelExp = 0;
    player.requiredExp = INITIAL_REQUIRED_EXP;
    player.score = 0;
    zombieKillCount = 0;
    player.isDying = false;
    player.ammo = { 0: 100, 1: 150, 2: 100, 3: 50, 4: 20 };
    player.x = canvas.width / 2; // ƒê∆∞a player v·ªÅ gi·ªØa m√†n h√¨nh
    player.y = canvas.height / 2;

    // 4. Reset c√°c ch·ªâ s·ªë n√¢ng c·∫•p c·ªßa ng∆∞·ªùi ch∆°i
    // QUAN TR·ªåNG: Xem l∆∞u √Ω ·ªü d∆∞·ªõi v·ªÅ c√°c n√¢ng c·∫•p vƒ©nh vi·ªÖn
    playerUpgrades.iceArrow = 1;
    playerUpgrades.damageBoost = 1;
    playerUpgrades.hpBoost = 0;
    playerUpgrades.bulletSpeed = 1;
    playerUpgrades.lineBulletCount = 1;
    // X√≥a c√°c n√¢ng c·∫•p mua trong Shop
    shopUpgrades.iceArrowSpeedLevel = 0; // x√≥a bonus t·ªëc ƒë·ªô m≈©i t√™n bƒÉng
    iceArrowRateShopSteps = 0;                 // x√≥a bonus t·ªëc ƒë·ªô mua trong Shop
    iceArrowDamageShop    = 0;                 // x√≥a bonus s√°t th∆∞∆°ng mua trong Shop
    window.manualShootCooldownBase = manualShootCooldown; // tr·∫£ cooldown g·ªëc 1x
    lastManualShootTime = 0;                   // cho ph√©p b·∫Øn ngay khi v√†o game
      // 4.z. Reset c√°c trang b·ªã ƒëang ƒëeo + reset applied ƒë·ªÉ tr√°nh b·ªã tr·ª´ √¢m ch·ªâ s·ªë
  if (window.Equip) {
    // B·∫£o ƒë·∫£m c·∫•u tr√∫c slots t·ªìn t·∫°i
    if (!Equip.slots) Equip.slots = {};

    // X√°c ƒë·ªãnh danh s√°ch slot
    const slots = (Array.isArray(window.EQUIP_SLOTS) && window.EQUIP_SLOTS.length)
      ? window.EQUIP_SLOTS
      : Object.keys(Equip.slots);

    // Xo√° s·∫°ch trang b·ªã ƒëang ƒëeo
    for (const s of slots) Equip.slots[s] = null;

    // R√ÄO CH·∫ÆN QUAN TR·ªåNG: reset applied v·ªÅ 0 ƒë·ªÉ applyEquipmentBonuses kh√¥ng tr·ª´ ‚Äúd∆∞‚Äù
    Equip.applied = {
      armor: 0,
      damageBoost: 0,
      bulletSpeed: 0,
      moveSpeed: 0,
      hearts: 0,
      iceArrow: 0,
      lineBulletCount: 0,
      critRate: 0,
      critDmg: 0,
      hpRegen: 0,
      spRegen: 0,
    };
  }

  // T√≠nh l·∫°i ch·ªâ s·ªë & refresh UI ngay sau khi reset trang b·ªã
  window.recalcEquipStats?.();
  window.CharacterPanel?.refresh?.();
    // 5. Reset c√°c n√¢ng c·∫•p k·ªπ nƒÉng
    skillUpgrades.bladeCount = 2;
    skillUpgrades.bladeDamage = 1;
    skillUpgrades.swordLevel = 1;
    skillUpgrades.swordDamage = 3;
    skillUpgrades.fireCount = 2;
    skillUpgrades.fireDamage = 1;
    skillUpgrades.iceCount = 2;
    skillUpgrades.iceDamage = 2;
    skillUpgrades.thunderCount = 2;
    skillUpgrades.thunderDamage = 3;
    skillUpgrades.auraHealLevel = 0;
    skillUpgrades.fairyCount = 1;
    skillUpgrades.fairyHealLevel = 0;
    skillUpgrades.fairyDamageLevel = 0;

    // 6. D·ªçn d·∫πp t·∫•t c·∫£ c√°c m·∫£ng ch·ª©a ƒë·ªëi t∆∞·ª£ng trong game
    // C√°ch .length = 0 l√† c√°ch x√≥a m·∫£ng hi·ªáu qu·∫£ nh·∫•t, kh√¥ng "g√¢y r√°c"
    zombies.length = 0;
    bullets.length = 0;
    enemyBullets.length = 0;
    items.length = 0;
    explosions.length = 0;
    particles.length = 0;
    swords.length = 0;
    downwardSwords.length = 0;
    fireballs.length = 0;
    iceballs.length = 0;
    thunderBalls.length = 0;
    fairies.length = 0;
    clones.length = 0;
    activeSkills.length = 0; // X√≥a c√°c k·ªπ nƒÉng ƒë√£ h·ªçc
    supplyDrops.length = 0;
    // --- D·ªçn d·∫πp c√°c m·∫£ng ch·ª©a ƒë·ªëi t∆∞·ª£ng c·ªßa k·ªπ nƒÉng ---
    satellites.length = 0;
    ufos.length = 0;
    lightningBolts.length = 0;
    activeLightningStrikes.length = 0;
    blackHoles.length = 0;
    bloodOrbs.length = 0;
    missiles.length = 0;
    nuclearBombs.length = 0;
    bombsB52.length = 0;
    activePlanes.length = 0;
    auraCrackLines.length = 0;
    auraLightBeams.length = 0;
// 7. Reset tr·∫°ng th√°i v√† th·ªùi gian h·ªìi c·ªßa c√°c k·ªπ nƒÉng/buff
    lastManualShootTime = 0; // Reset th·ªùi gian h·ªìi b·∫Øn tay
    lastAutoShootTime = 0;   // Reset th·ªùi gian h·ªìi auto-shoot
    autoBurstIndex = 0;      // Reset lo·∫°t ƒë·∫°n c·ªßa auto-shoot
    autoLastBurstTime = 0;
    levelUpGlowTime = 0;     // T·∫Øt hi·ªáu ·ª©ng s√°ng khi l√™n c·∫•p

    // D·ªçn d·∫πp c√°c b·ªô ƒë·ªám th√¥ng b√°o v·∫≠t ph·∫©m ƒë·ªÉ tr√°nh popup th·ª´a
    clearTimeout(playerLootTimer);
    clearTimeout(petLootTimer);
    Object.keys(playerLootBuffer).forEach(k => delete playerLootBuffer[k]);
    Object.keys(petLootBuffer).forEach(k => delete petLootBuffer[k]);

    // D·ªçn d·∫πp c√°c ƒë·ªëi t∆∞·ª£ng th·ªëng k√™
    // C√°ch n√†y s·∫Ω x√≥a s·∫°ch c√°c key trong object
    for (let key in zombieByLevel) {
        delete zombieByLevel[key];
    }
    for (let key in skillStats) {
        delete skillStats[key];
    }
    // --- Reset c√°c Buff nh·∫∑t ƒë∆∞·ª£c ---
    luckyBuffEndTime = 0;
    powerBuffEndTime = 0;
    isPowerBuffActive = false;
    powerBuffDamageBonus = 0;
    crazyBuffEndTime = 0;
    isCrazyBuffActive = false;
    crazyBuffStats = {};
    expBuffEndTime = 0;
    magnetBuffEndTime = 0;
    crazyMadnessTimeEndTime = 0;
    isCrazyMadnessTimeActive = false;
    crazyMadnessTimeBuffStats = {};
    _critRateBuffs.length = 0; // X√≥a t·∫•t c·∫£ buff c·ªông t·ªâ l·ªá ch√≠ m·∫°ng
    _critDmgBuffs.length = 0;  // X√≥a t·∫•t c·∫£ buff c·ªông s√°t th∆∞∆°ng ch√≠ m·∫°ng

    // --- Reset c√°c K·ªπ nƒÉng Passive (c√≥ n√∫t b·∫•m tr√™n UI) ---
    autoShoot = false; // T·∫Øt auto-shoot ƒë·ªÉ ng∆∞·ªùi ch∆°i t·ª± b·∫≠t l·∫°i
    
    swordActive = false;
    swordEndTime = 0;
    
    bladeActive = false;
    bladeEndTime = 0;
    
    fireActive = false;
    fireEndTime = 0;
    
    iceActive = false;
    iceEndTime = 0;
    
    thunderActive = false;
    thunderEndTime = 0;
    
    petActive = false;
    petEndTime = 0;
    petRabbit = null;
    
    supportAuraActive = false;
    supportAuraEndTime = 0;

    fairyActive = false;
    fairyEndTime = 0;
    fairyDeathDefyAvailable = false;
    fairyDamageBonus = 0;

    // --- Reset c√°c K·ªπ nƒÉng Active (h·ªçc khi l√™n c·∫•p) ---
    player.shieldActive = false;
    if (player.shieldEndTime) player.shieldEndTime = 0;

    satelliteActive = false;
    satelliteEndTime = 0;
    
    ufoActive = false;
    ufoEndTime = 0;

    lightningActive = false;
    lightningEndTime = 0;
    
    disguiseActive = false;
    disguiseEndTime = 0;

    clonesActive = false;
    clonesEndTime = 0;

    bloodOrbActive = false;
    bloodOrbEndTime = 0;

    spaceGateActive = false;
    spaceGateEndTime = 0;
    spaceGate = null;
    
    // 8. C·∫≠p nh·∫≠t l·∫°i to√†n b·ªô giao di·ªán (UI)
    updateUI();
    updateStatsOverlay();
    updateSkillsList(); // C·∫≠p nh·∫≠t l·∫°i b·∫£ng k·ªπ nƒÉng (s·∫Ω tr·ªëng)
    document.querySelectorAll('#ui button.active').forEach(btn => btn.classList.remove('active'));

    // 9. B·∫≠t l·∫°i nh·∫°c n·ªÅn m·∫∑c ƒë·ªãnh v√† sinh l·ª©a zombie ƒë·∫ßu ti√™n
    playRandomNormalMusic();
    spawnZombie();
    showUpgradePopup(); // Hi·ªÉn th·ªã n√¢ng c·∫•p cho l∆∞·ª£t ch∆°i m·ªõi
window.resetStarterEquip?.();
window.recalcEquipStats?.();
window.CharacterPanel?.refresh?.();
// Kh·ªüi t·∫°o: c·ªë ƒë·ªãnh Zone 2 l√†m v√πng an to√†n ƒë·∫ßu game
currentActiveSafeZoneId = 2;
lastSafeZoneChangeHour = Math.floor(dayTime * 24) % 24;
// ƒê·ªìng b·ªô c·ªù active ngay thay v√¨ ƒë·ª£i updateSafeZoneStatus()
safeZones.forEach(z => z.active = (z.id === currentActiveSafeZoneId));
console.log(`Initial Safe Zone set to: ${currentActiveSafeZoneId}`);
}

// H√†m b·∫≠t/t·∫Øt Shop
function toggleShop() {
    const shop = document.getElementById('shopOverlay');
    if (!shop) return;
    const isHidden = shop.classList.toggle('hidden');
    isPaused = !isHidden;

    if (!isHidden) {
        populateShop(); // Khi m·ªü shop, hi·ªÉn th·ªã c√°c v·∫≠t ph·∫©m
    }
}

// H√†m hi·ªÉn th·ªã c√°c v·∫≠t ph·∫©m trong Shop
function populateShop() {
    const container = document.getElementById('shopItemsContainer');
    container.innerHTML = '';
    document.getElementById('shopCoinBalance').innerText = player.coins;
    shopItems.forEach(item => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'shop-item';
        itemDiv.innerHTML = `
            <div class="icon">${item.icon}</div>
            <div class="name">${item.name}</div>
            <button onclick="purchaseShopItem('${item.id}')">${item.cost} ü™ô</button>`;
        container.appendChild(itemDiv);
    });
}

// H√†m x·ª≠ l√Ω khi mua m·ªôt v·∫≠t ph·∫©m
/**
 * X·ª≠ l√Ω logic khi ng∆∞·ªùi ch∆°i mua m·ªôt v·∫≠t ph·∫©m trong c·ª≠a h√†ng.
 * @param {string} itemId - ID c·ªßa v·∫≠t ph·∫©m ƒë∆∞·ª£c ch·ªçn mua.
 */
function purchaseShopItem(itemId) {
    // Ghi ch√∫: T√¨m to√†n b·ªô th√¥ng tin c·ªßa v·∫≠t ph·∫©m trong m·∫£ng `shopItems` d·ª±a v√†o ID.
    const item = shopItems.find(i => i.id === itemId);
    if (!item) return; // N·∫øu kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m, tho√°t kh·ªèi h√†m.

    // Ghi ch√∫: Ki·ªÉm tra xem ng∆∞·ªùi ch∆°i c√≥ ƒë·ªß xu ƒë·ªÉ mua kh√¥ng.
    if (player.coins >= item.cost) {

        // Ghi ch√∫: ƒê√¢y l√† b∆∞·ªõc ki·ªÉm tra ƒë·∫∑c bi·ªát. Tr∆∞·ªõc khi tr·ª´ ti·ªÅn, h√£y ch·∫Øc ch·∫Øn r·∫±ng
        // ng∆∞·ªùi ch∆°i ƒë√£ h·ªçc k·ªπ nƒÉng active tr∆∞·ªõc khi mua n√¢ng c·∫•p cho n√≥.
        if (item.type === 'active_skill_damage_upgrade') {
            // D√πng `some` ƒë·ªÉ ki·ªÉm tra xem trong m·∫£ng `activeSkills` c√≥ k·ªπ nƒÉng n√†o tr√πng t√™n kh√¥ng.
            const skillIsLearned = activeSkills.some(s => s.name === item.skillName);
            if (!skillIsLearned) {
                showWarning(`B·∫°n c·∫ßn h·ªçc k·ªπ nƒÉng "${item.skillName}" tr∆∞·ªõc!`);
                return; // D·ª´ng vi·ªác mua b√°n l·∫°i n·∫øu ch∆∞a h·ªçc.
            }
        }

        // Ghi ch√∫: Tr·ª´ s·ªë xu c·ªßa ng∆∞·ªùi ch∆°i, ph√°t √¢m thanh v√† hi·ªÉn th·ªã th√¥ng b√°o mua th√†nh c√¥ng.
        player.coins -= item.cost;
        playSound('sfx-powerup', 0.8);
        showWarning(`ƒê√£ mua: ${item.name}!`);

        // Ghi ch√∫: S·ª≠ d·ª•ng c·∫•u tr√∫c `switch` d·ª±a tr√™n `item.type` ƒë·ªÉ x·ª≠ l√Ω c√°c lo·∫°i v·∫≠t ph·∫©m kh√°c nhau.
        // C√°ch n√†y gi√∫p code g·ªçn g√†ng v√† d·ªÖ m·ªü r·ªông h∆°n.
        switch (item.type) {
            // Tr∆∞·ªùng h·ª£p mua t√†i nguy√™n (m√°u, mana, nƒÉng l∆∞·ª£ng).
            case 'resource':
                if (item.id.includes('mana')) player.mana += item.value;
                if (item.id.includes('energy')) player.energy += item.value;
                if (item.id.includes('hp')) player.hearts = Math.min(player.maxHearts, player.hearts + item.value); 
                break;
            case 'crit': {
                if (player.coins < item.cost) { showWarning('Kh√¥ng ƒë·ªß xu'); return; }
                player.coins -= item.cost;

                if (item.sub === 'rate') {
                  // Kh√¥ng c·ªông v∆∞·ª£t tr·∫ßn ngay t·∫°i ƒë√¢y; tr·∫ßn √°p ·ªü getCritRate()
                  addCritRateBuff(item.value, item.durationMs);
                  showWarning(`‚ú® Crit Rate +${Math.round(item.value*100)}% trong ${Math.round(item.durationMs/1000)}s`);
                } else if (item.sub === 'dmg') {
                  addCritDmgBuff(item.value, item.durationMs);
                  showWarning(`üí• Crit Dmg +${Math.round(item.value*100)}% trong ${Math.round(item.durationMs/1000)}s`);
                } else {
                  // n·∫øu sau n√†y c√≤n subtype kh√°c
                  showWarning('Crit item ch∆∞a h·ªó tr·ª£');
                  player.coins += item.cost; // ho√†n xu
                }}
                break;
            case 'ice': {
              if (item.id === 'buy_ice_rate') {
                // ch·∫∑n v∆∞·ª£t tr·∫ßn 3x
                if (getIceArrowRate() >= ICE_ARROW_RATE_MAX) {
                  showWarning('T·ªëc ƒë·ªô Ice Arrow ƒë√£ t·ªëi ƒëa!');
                  player.coins += item.cost; // ho√†n l·∫°i xu v√¨ kh√¥ng √°p d·ª•ng ƒë∆∞·ª£c
                } else {
                  iceArrowRateShopSteps += 1; // m·ªói l·∫ßn mua +0.5x
                }
              } else if (item.id === 'buy_ice_damage') {
                iceArrowDamageShop += item.value; // m·ªói l·∫ßn mua +dmg ri√™ng (vd +1)
              }
              break;
            }
           case 'ammo':
                if (player.ammo.hasOwnProperty(item.targetAmmoIndex)) {
                    player.ammo[item.targetAmmoIndex] += item.value;
                    // C·∫≠p nh·∫≠t hi·ªÉn th·ªã ngay l·∫≠p t·ª©c n·∫øu ng∆∞·ªùi ch∆°i ƒëang ch·ªçn lo·∫°i ƒë·∫°n ƒë√≥
                    if (clickShotMode === item.targetAmmoIndex) {
                        updateAmmoDisplay();
                    }
                }
                break;
            // Tr∆∞·ªùng h·ª£p mua n√¢ng c·∫•p vƒ©nh vi·ªÖn cho ch·ªâ s·ªë c∆° b·∫£n c·ªßa ng∆∞·ªùi ch∆°i.
            case 'permanent_upgrade': {
              if (item.id === 'buy_damage') {
                playerUpgrades.damageBoost += item.value;
                break;
              }
              if (item.id === 'buy_ice_arrow_speed') {
                // Ch·∫∑n mua khi ƒë√£ ƒë·∫°t tr·∫ßn 3.0
                if (getIceArrowSpeed() >= 3) {
                  showWarning("üèπ Ice Arrow speed ƒë√£ t·ªëi ƒëa!");
                  // Ho√†n xu n·∫øu tr∆∞·ªõc ƒë√≥ ƒë√£ b·ªã tr·ª´ b·ªüi logic ·ªü tr√™n (tu·ª≥ b·∫£n h√†m b·∫°n gi·ªØ)
                  player.coins += item.cost;
                  break;
                }
                // +0.5 m·ªói l·∫ßn
                shopUpgrades.iceArrowSpeedLevel = (shopUpgrades.iceArrowSpeedLevel || 0) + 1;

                showWarning(`üèπ Ice Arrow speed: x${getIceArrowSpeed().toFixed(1)}`);
                updateStatsOverlay();
                populateShop();
                break;
              }
              break;
            }
            // Tr∆∞·ªùng h·ª£p mua c√°c lo·∫°i buff t·∫°m th·ªùi.
            case 'buff':
                if (item.id === 'buy_lucky') luckyBuffEndTime = Date.now() + 45000;
                if (item.id === 'buy_power') powerBuffEndTime = Date.now() + 45000;
                if (item.id === 'buy_crazy') crazyBuffEndTime = Date.now() + 45000;
                if (item.id === 'buy_exp') expBuffEndTime = Date.now() + 45000;
                if (item.id === 'buy_magnet') magnetBuffEndTime = Date.now() + 30000;
                if (item.id === 'buy_madness') crazyMadnessTimeEndTime = Date.now() + 30000;
                break;
            
            // Tr∆∞·ªùng h·ª£p mua n√¢ng c·∫•p s√°t th∆∞∆°ng cho c√°c k·ªπ nƒÉng m·∫∑c ƒë·ªãnh (ƒêao, Ki·∫øm, L·ª≠a...).
            case 'skill_damage_upgrade':
                // `hasOwnProperty` ki·ªÉm tra xem `skillUpgrades` c√≥ thu·ªôc t√≠nh `item.skillTarget` kh√¥ng.
                if (item.skillTarget && skillUpgrades.hasOwnProperty(item.skillTarget)) {
                    // TƒÉng s√°t th∆∞∆°ng cho k·ªπ nƒÉng t∆∞∆°ng ·ª©ng. V√≠ d·ª•: skillUpgrades['bladeDamage'] += 0.2;
                    skillUpgrades[item.skillTarget] += item.value;
                }
                break;

            // Tr∆∞·ªùng h·ª£p mua n√¢ng c·∫•p s√°t th∆∞∆°ng cho c√°c k·ªπ nƒÉng Active (h·ªçc khi l√™n c·∫•p).
            case 'active_skill_damage_upgrade':
                // T√¨m k·ªπ nƒÉng ƒë√£ h·ªçc trong m·∫£ng `activeSkills`.
                const skillToUpgrade = activeSkills.find(s => s.name === item.skillName);
                if (skillToUpgrade) {
                    // N·∫øu t√¨m th·∫•y, c·ªông d·ªìn s√°t th∆∞∆°ng.
                    skillToUpgrade.baseDamage += item.value;
                    // C·∫≠p nh·∫≠t l·∫°i tooltip c·ªßa k·ªπ nƒÉng trong b·∫£ng (ph√≠m X) ƒë·ªÉ hi·ªÉn th·ªã s√°t th∆∞∆°ng m·ªõi.
                    updateSkillsList(); 
                }
                break;
        }

        // Ghi ch√∫: Sau khi mua th√†nh c√¥ng, c·∫≠p nh·∫≠t l·∫°i to√†n b·ªô giao di·ªán li√™n quan.
        populateShop();       // C·∫≠p nh·∫≠t l·∫°i s·ªë xu v√† c√°c v·∫≠t ph·∫©m trong c·ª≠a h√†ng.
        updateUI();           // C·∫≠p nh·∫≠t thanh tr·∫°ng th√°i ch√≠nh (HP, Mana, Xu...).
        updateStatsOverlay(); // C·∫≠p nh·∫≠t b·∫£ng th·ªëng k√™ (ph√≠m Z).

    } else {
        // Ghi ch√∫: N·∫øu kh√¥ng ƒë·ªß xu, ch·ªâ hi·ªÉn th·ªã th√¥ng b√°o.
        showWarning("Kh√¥ng ƒë·ªß xu!");
    }
}

// üåä Hi·ªán popup "Wave X b·∫Øt ƒë·∫ßu"
function showWavePopup() {
  const popup = document.getElementById("wavePopup");
  popup.innerText = `Wave ${wave} b·∫Øt ƒë·∫ßu!`;
  popup.style.animation = "none";
  void popup.offsetWidth; // force reflow ƒë·ªÉ reset animation
  popup.style.display = "block";
  popup.style.animation = "waveFade 1s ease-out forwards";
  setTimeout(() => {
    popup.style.display = "none";
  }, 2000); // ·∫©n sau 2 gi√¢y
}

// üéØ Gi√° tr·ªã theo c·∫•p ƒë·ªô k·ªπ nƒÉng (m·ªói c·∫•p tƒÉng d·∫ßn)
const UPGRADE_TIERS = {
  iceArrow: [1, 2, 3],
  damageBoost: [0.5, 1, 1.5],
  hpBoost: [5, 10, 15],            
  bulletSpeed: [0.25, 0.5, 1]
};

// üåü Hi·ªÉn th·ªã popup ch·ªçn n√¢ng c·∫•p k·ªπ nƒÉng
function showUpgradePopup() {
  playSound('sfx-wave-up', 0.3); // Ph√°t √¢m thanh n√¢ng c·∫•p
  const popup = document.getElementById("upgradePopup");
  const container = document.getElementById("upgradeChoices");
  container.innerHTML = "";

  // üìå B·∫£ng gi√° tr·ªã t∆∞∆°ng ·ª©ng v·ªõi t·ª´ng b·∫≠c n√¢ng c·∫•p
  const UPGRADE_VALUES = {
    B·∫°c: { iceArrow: 1, damageBoost: 0.5, hpBoost: 5, bulletSpeed: 0.25 },
    V√†ng: { iceArrow: 2, damageBoost: 1, hpBoost: 10, bulletSpeed: 0.5 },
    Kim: { iceArrow: 3, damageBoost: 1.5, hpBoost: 15, bulletSpeed: 1 },
    Rare: { moveSpeed: 0.2 } // üëü t·ªëc ƒë·ªô ch·∫°y ‚Äì b·∫≠c hi·∫øm
  };
  // üéñ M√†u vi·ªÅn t∆∞∆°ng ·ª©ng t·ª´ng b·∫≠c
  const TIER_COLORS = {
    B·∫°c: "#aaa",
    V√†ng: "gold",
    Kim: "#c770ff",
    Rare: "#3399ff" // m√†u xanh b·∫≠c hi·∫øm
  };
  // Gi·ªõi h·∫°n n√¢ng c·∫•p k·ªπ nƒÉng
  const MAX_FIRE_RATE = 21; // üèπ Ice Arrow
  const MAX_LINE_BULLETS = 10; // üî´ s·ªë l∆∞·ª£ng ƒë·∫°n
  const MAX_MOVE_SPEED = 3; // üëü t·ªëc ƒë·ªô di chuy·ªÉn t·ªëi ƒëa
  const MAX_BULLET_SPEED = 10; // üöÄ t·ªëc ƒë·ªô ƒë·∫°n t·ªëi ƒëa

  const allUpgrades = [];

  // üî™ ƒêao ‚Äì tƒÉng s·ªë l∆∞·ª£ng (t·ªëi ƒëa 20), sau ƒë√≥ tƒÉng s√°t th∆∞∆°ng
  // ƒêI·ªÄU KI·ªÜN: Ch·ªâ hi·ªÉn th·ªã n√¢ng c·∫•p khi ng∆∞·ªùi ch∆°i ƒë·∫°t level 1
  if (player.level >= 1) {
    if (skillUpgrades.bladeCount < 20) {
      const tier = randomTier();
      const value = { B·∫°c: 1, V√†ng: 2, Kim: 3 }[tier];
      allUpgrades.push({
        name: `üî™ +${value} ƒëao xoay`,
        tier,
        effect: () => {
          skillUpgrades.bladeCount = Math.min(skillUpgrades.bladeCount + value, 20);
          showWarning(`üî™ +${value} ƒëao`);
          updateStatsOverlay();
        }
      });
    } else {
      const tier = randomTier();
      const value = { B·∫°c: 0.5, V√†ng: 1, Kim: 1.5 }[tier];
      allUpgrades.push({
        name: `üî™ +${value} Dmg ƒëao`,
        tier,
        effect: () => {
          skillUpgrades.bladeDamage += value;
          showWarning(`üî™ +${value} dmg`);
          updateStatsOverlay();
        }
      });
    }
  }

  // ‚öîÔ∏è Ki·∫øm ‚Äì tƒÉng c·∫•p (t·ªëi ƒëa 10), sau ƒë√≥ tƒÉng s√°t th∆∞∆°ng
  // ƒêI·ªÄU KI·ªÜN: Ch·ªâ hi·ªÉn th·ªã n√¢ng c·∫•p khi ng∆∞·ªùi ch∆°i ƒë·∫°t level 2
  if (player.level >= 2) {
    if (skillUpgrades.swordLevel < 10) {
      const tier = randomTier();
      const value = { B·∫°c: 1, V√†ng: 2, Kim: 3 }[tier];
      allUpgrades.push({
        name: `‚öîÔ∏è +${value} c·∫•p m∆∞a ki·∫øm`,
        tier,
        effect: () => {
          skillUpgrades.swordLevel = Math.min(skillUpgrades.swordLevel + value, 10);
          showWarning(`‚öîÔ∏è +${value} c·∫•p ki·∫øm`);
          updateStatsOverlay();
        }
      });
    } else {
      const tier = randomTier();
      const value = { B·∫°c: 0.5, V√†ng: 1, Kim: 1.5 }[tier];
      allUpgrades.push({
        name: `‚öîÔ∏è +${value} Dmg ki·∫øm`,
        tier,
        effect: () => {
          skillUpgrades.swordDamage += value;
          showWarning(`‚öîÔ∏è +${value} dmg`);
          updateStatsOverlay();
        }
      });
    }
  }

  // üî• L·ª≠a ‚Äì tƒÉng s·ªë l∆∞·ª£ng (t·ªëi ƒëa 10), sau ƒë√≥ tƒÉng s√°t th∆∞∆°ng
  // ƒêI·ªÄU KI·ªÜN: Ch·ªâ hi·ªÉn th·ªã n√¢ng c·∫•p khi ng∆∞·ªùi ch∆°i ƒë·∫°t level 3
  if (player.level >= 3) {
    if (skillUpgrades.fireCount < 10) {
      const tier = randomTier();
      const value = { B·∫°c: 1, V√†ng: 2, Kim: 3 }[tier];
      allUpgrades.push({
        name: `üî• +${value} c·∫ßu l·ª≠a`,
        tier,
        effect: () => {
          skillUpgrades.fireCount = Math.min(skillUpgrades.fireCount + value, 10);
          showWarning(`üî• +${value} l·ª≠a`);
          updateStatsOverlay();
        }
      });
    } else {
      const tier = randomTier();
      const value = { B·∫°c: 0.5, V√†ng: 1, Kim: 1.5 }[tier];
      allUpgrades.push({
        name: `üî• +${value} Dmg l·ª≠a`,
        tier,
        effect: () => {
          skillUpgrades.fireDamage += value;
          showWarning(`üî• +${value} dmg`);
          updateStatsOverlay();
        }
      });
    }
  }

  // ‚ùÑÔ∏è BƒÉng ‚Äì tƒÉng s·ªë l∆∞·ª£ng (t·ªëi ƒëa 10), sau ƒë√≥ tƒÉng s√°t th∆∞∆°ng
  // ƒêI·ªÄU KI·ªÜN: Ch·ªâ hi·ªÉn th·ªã n√¢ng c·∫•p khi ng∆∞·ªùi ch∆°i ƒë·∫°t level 3
  if (player.level >= 3) {
    if (skillUpgrades.iceCount < 10) {
      const tier = randomTier();
      const value = { B·∫°c: 1, V√†ng: 2, Kim: 3 }[tier];
      allUpgrades.push({
        name: `‚ùÑÔ∏è +${value} c·∫ßu bƒÉng`,
        tier,
        effect: () => {
          skillUpgrades.iceCount = Math.min(skillUpgrades.iceCount + value, 10);
          showWarning(`‚ùÑÔ∏è +${value} bƒÉng`);
          updateStatsOverlay();
        }
      });
    } else {
      const tier = randomTier();
      const value = { B·∫°c: 0.5, V√†ng: 1, Kim: 1.5 }[tier];
      allUpgrades.push({
        name: `‚ùÑÔ∏è +${value} Dmg bƒÉng`,
        tier,
        effect: () => {
          skillUpgrades.iceDamage += value;
          showWarning(`‚ùÑÔ∏è +${value} dmg`);
          updateStatsOverlay();
        }
      });
    }
  }
  
  // üîµ L√¥i ‚Äì tƒÉng s·ªë l∆∞·ª£ng (t·ªëi ƒëa 6), sau ƒë√≥ tƒÉng s√°t th∆∞∆°ng
  // ƒêI·ªÄU KI·ªÜN: Ch·ªâ hi·ªÉn th·ªã n√¢ng c·∫•p khi ng∆∞·ªùi ch∆°i ƒë·∫°t level 5
  if (player.level >= 5) {
    if (skillUpgrades.thunderCount < 6) {
      const tier = randomTier();
      const value = 1;
      allUpgrades.push({
        name: `üîµ +${value} c·∫ßu l√¥i`,
        tier,
        effect: () => {
          skillUpgrades.thunderCount = Math.min(skillUpgrades.thunderCount + value, 6);
          showWarning(`üîµ +${value} c·∫ßu l√¥i`);
          updateStatsOverlay();
        }
      });
    } else {
      const tier = randomTier();
      const value = { B·∫°c: 1, V√†ng: 2, Kim: 3 }[tier];
      allUpgrades.push({
        name: `üîµ +${value} Dmg l√¥i`,
        tier,
        effect: () => {
          skillUpgrades.thunderDamage += value;
          showWarning(`üîµ +${value} dmg l√¥i`);
          updateStatsOverlay();
        }
      });
    }
  }

  // üèπ Ice Arrow ‚Äì n·∫øu ch∆∞a max
  if (playerUpgrades.iceArrow < MAX_FIRE_RATE) {
    const tier = randomTier();
    const value = UPGRADE_VALUES[tier].iceArrow;
    allUpgrades.push({
      name: "üèπ Ice Arrow",
      key: "iceArrow",
      tier,
      value,
      effect: () => {
        const added = Math.min(playerUpgrades.iceArrow + value, MAX_FIRE_RATE) - playerUpgrades.iceArrow;
        playerUpgrades.iceArrow += added;
        showWarning(`üèπ +${added} Ice Arrow`);
        updateStatsOverlay();
      }
    });
  }

  // üí• S√°t th∆∞∆°ng ‚Äì lu√¥n c√≥ th·ªÉ n√¢ng
  {
    const tier = randomTier();
    const value = UPGRADE_VALUES[tier].damageBoost;
    allUpgrades.push({
      name: "üí• S√°t th∆∞∆°ng",
      key: "damageBoost",
      tier,
      value,
      effect: () => {
        playerUpgrades.damageBoost += value;
        showWarning(`üí• +${value} s√°t th∆∞∆°ng`);
        updateStatsOverlay();
      }
    });
  }

  // ‚ù§Ô∏è M√°u ‚Äì lu√¥n c√≥ th·ªÉ n√¢ng
  {
    const tier = randomTier();
    const value = UPGRADE_VALUES[tier].hpBoost;
    allUpgrades.push({
      name: "‚ù§Ô∏è TƒÉng m√°u",
      key: "hpBoost",
      tier,
      value,
      effect: () => {
      player.maxHearts += value; // 1. TƒÉng gi·ªõi h·∫°n m√°u t·ªëi ƒëa
      player.hearts = Math.min(player.maxHearts, player.hearts + value); // 2. H·ªìi m√°u ngay l·∫≠p t·ª©c
        showWarning(`‚ù§Ô∏è +${value}`);
        updateUI();
        updateStatsOverlay();
      }
    });
  }

  // üí® T·ªëc ƒë·ªô ƒë·∫°n t·ªëi ƒëa 10
  if (playerUpgrades.bulletSpeed < MAX_BULLET_SPEED) {
    const tier = randomTier();
    const value = UPGRADE_VALUES[tier].bulletSpeed;
    allUpgrades.push({
      name: "üí® T·ªëc ƒë·ªô ƒë·∫°n",
      key: "bulletSpeed",
      tier,
      value,
      effect: () => {
        const added = Math.min(playerUpgrades.bulletSpeed + value, MAX_BULLET_SPEED) - playerUpgrades.bulletSpeed;
        playerUpgrades.bulletSpeed += added;
        showWarning(`üí® +${added.toFixed(1)} t·ªëc ƒë·ªô ƒë·∫°n`);
        updateStatsOverlay();
      }
    });
  }

  // üß® S·ªë l∆∞·ª£ng ƒë·∫°n ‚Äì n·∫øu ch∆∞a max
  if (playerUpgrades.lineBulletCount < MAX_LINE_BULLETS) {
    const tier = randomTier();
    const value = 1;
    allUpgrades.push({
      name: "üß® s·ªë l∆∞·ª£ng ƒë·∫°n",
      key: "lineBulletCount",
      tier,
      value,
      effect: () => {
        playerUpgrades.lineBulletCount += value;
        showWarning(`üß® +${value} vi√™n m·ªói h√†ng`);
        updateStatsOverlay();
      }
    });
  }

  // üëü T·ªëc ƒë·ªô ch·∫°y ‚Äì hi·∫øm v√† ch·ªâ 1 c·∫•p (n·∫øu ch∆∞a max)
  if (player.speed < MAX_MOVE_SPEED) {
    const value = UPGRADE_VALUES.Rare.moveSpeed;
    allUpgrades.push({
      name: "üëü T·ªëc ƒë·ªô ch·∫°y",
      key: "moveSpeed",
      tier: "Rare",
      value,
      effect: () => {
        player.speed = Math.min(player.speed + value, MAX_MOVE_SPEED);
        showWarning(`üëü +${value.toFixed(1)} t·ªëc ƒë·ªô`);
        updateStatsOverlay();
      }
    });
  }
  
  // --- N√¢ng c·∫•p k·ªπ nƒÉng Fairy ---
  // ƒêI·ªÄU KI·ªÜN: Ch·ªâ hi·ªÉn th·ªã n√¢ng c·∫•p khi ng∆∞·ªùi ch∆°i ƒë·∫°t level 7
  if (player.level >= 7) {
    if (skillUpgrades.fairyCount < 3) {
      allUpgrades.push({
        name: `ü¶ã +1 Fairy (T·ªëi ƒëa 3)`,
        tier: "Kim",
        effect: () => {
          skillUpgrades.fairyCount++;
          showWarning(`ü¶ã S·ªë l∆∞·ª£ng Fairy: ${skillUpgrades.fairyCount}`);
        }
      });
    } else {
      // Khi ƒë√£ ƒë·ªß 3 Fairy, b·∫Øt ƒë·∫ßu n√¢ng c·∫•p ch·ªâ s·ªë
      // N√¢ng c·∫•p h·ªìi m√°u
      const healTier = randomTier();
      const healValue = { B·∫°c: 1, V√†ng: 2, Kim: 3 }[healTier];
      allUpgrades.push({
        name: `ü¶ã +${healValue} H·ªìi m√°u/gi√¢y`,
        tier: healTier,
        effect: () => {
          skillUpgrades.fairyHealLevel += healValue;
          showWarning(`ü¶ã N√¢ng c·∫•p h·ªìi m√°u!`);
        }
      });

      // N√¢ng c·∫•p s√°t th∆∞∆°ng
      const dmgTier = randomTier();
      const dmgValue = { B·∫°c: 1, V√†ng: 2, Kim: 3 }[dmgTier];
      allUpgrades.push({
        name: `ü¶ã +${dmgValue} S√°t th∆∞∆°ng`,
        tier: dmgTier,
        effect: () => {
          skillUpgrades.fairyDamageLevel += dmgValue;
          showWarning(`ü¶ã N√¢ng c·∫•p s√°t th∆∞∆°ng!`);
        }
      });
    }
  }
  
  // --- N√¢ng c·∫•p H·ªìi m√°u cho H√†o quang ---
  // ƒêI·ªÄU KI·ªÜN: Ch·ªâ hi·ªÉn th·ªã n√¢ng c·∫•p khi ng∆∞·ªùi ch∆°i ƒë·∫°t level 6
  if (player.level >= 6) {
    const currentAuraHeal = 1 + skillUpgrades.auraHealLevel;
    if (currentAuraHeal < 5) { // Ch·ªâ hi·ªÉn th·ªã n·∫øu ch∆∞a ƒë·∫°t t·ªëi ƒëa
      const tier = randomTier();
      const value = { B·∫°c: 1, V√†ng: 2, Kim: 3 }[tier];

      allUpgrades.push({
        name: `‚ú® +${value} H·ªìi m√°u`,
        tier: tier,
        effect: () => {
          skillUpgrades.auraHealLevel += value;
          const finalHeal = Math.min(1 + skillUpgrades.auraHealLevel, 5);
          showWarning(`‚ú® H·ªìi m√°u: ${finalHeal} HP/3s`);
          updateStatsOverlay(); // C·∫≠p nh·∫≠t b·∫£ng th·ªëng k√™ n·∫øu c√≥
        }
      });
    }
  }

  // üé≤ X√°o tr·ªôn v√† ch·ªçn ng·∫´u nhi√™n 3 n√¢ng c·∫•p
  const choices = allUpgrades.sort(() => Math.random() - 0.5).slice(0, 3);
  // üñ±Ô∏è T·∫°o n√∫t cho t·ª´ng n√¢ng c·∫•p
  choices.forEach(up => {
    const btn = document.createElement("button");
    btn.innerText = up.name;
    btn.style.borderColor = TIER_COLORS[up.tier];
    btn.onclick = () => {
      playSound('sfx-upgrade-select'); // √ÇM THANH KHI CLICK
      up.effect();
      popup.classList.remove('visible'); // <-- D√πng class ƒë·ªÉ ·∫©n popup
      isPaused = false;
      lastWaveTime = Date.now();

      if (pendingWave !== null) {
        setTimeout(() => {
          showWavePopup();
          pendingWave = null;
        }, 500);
      }
    };
    container.appendChild(btn);
  });

  popup.classList.add('visible'); // <-- D√πng class ƒë·ªÉ hi·ªán popup
  isPaused = true;
}
// üõ†Ô∏è Hi·ªÉn th·ªã th√¥ng b√°o khi n√¢ng c·∫•p th√†nh c√¥ng
// üé≤ Ch·ªçn b·∫≠c n√¢ng c·∫•p ng·∫´u nhi√™n theo t·ª∑ l·ªá
function randomTier() {
  const tiers = ["B·∫°c", "V√†ng", "Kim"];
  const weights = [0.7, 0.25, 0.05]; // t·ª∑ l·ªá g·∫∑p: 60% B·∫°c, 30% V√†ng, 10% Kim
  const r = Math.random();
  let sum = 0;
  for (let i = 0; i < tiers.length; i++) {
    sum += weights[i];
    if (r < sum) return tiers[i];
  }
  return "B·∫°c"; // fallback n·∫øu c√≥ l·ªói
}

// üåü Hi·ªÉn th·ªã popup ch·ªçn k·ªπ nƒÉng khi tƒÉng level
/* ========= C·∫§U H√åNH ========= */
const MAX_LV = {                         // gi·ªõi h·∫°n s·ªë-l∆∞·ª£ng
  ufo        : 3,                        // UFO t·∫•n c√¥ng
  missile    : 5,                        // t√™n l·ª≠a F18
  lightning  : 5,                        // tia s√©t di·ªán r·ªông
  satellite  : 2,                        // v·ªá tinh laze
  blackhole  : 2,                        // H·ªë ƒëen
  bloodorb   : 2
};

/* t√™n ng·∫Øn ‚Üí regex nh·∫≠n di·ªán chu·ªói n√¢ng c·∫•p */
const UP_RX = {
  ufo       : /\+1 UFO/i,
  missile   : /\+1 t√™n l·ª≠a/i,
  lightning : /\+1 tia s√©t/i,
  satellite : /\+1 v·ªá tinh/i,
  blackhole : /\+1 h·ªë ƒëen/i,
  bloodorb  : /\+1 qu·∫£ c·∫ßu/i
};

/* ========= TR·ª¢ GI√öP ========= */
const rand    = arr => arr[Math.random() * arr.length | 0];          // pickRandom
const shuffle = a => a.sort(() => Math.random() - .5);               // Fisher‚ÄìYates 1-liner

/* ki·ªÉm tra 1 n√¢ng c·∫•p c√≥ ‚Äúh·∫øt ƒë√°t‚Äù ch∆∞a */
function isOverLimit(upgrade){
  const key = Object.keys(UP_RX).find(k => UP_RX[k].test(upgrade.name));
  if (!key) return false;                                            // g√≥i s√°t th∆∞∆°ng, v.v.
  const active = activeSkills.find(s => s.name === upgrade.skillName);
  return active && (active.level || 0) >= MAX_LV[key];
}

/* ========= POPUP ========= */
function showSkillLevelUpPopup() {
    isPaused = true;
    const popup = document.getElementById('skillPopup');
    const container = document.getElementById('skillChoices');
    container.innerHTML = '';

    const newSkills = [];
    const upgradesBySkill = {};

    // 1. Duy·ªát qua T·∫§T C·∫¢ k·ªπ nƒÉng trong m·ªôt v√≤ng l·∫∑p duy nh·∫•t ƒë·ªÉ thu th·∫≠p c√°c l·ª±a ch·ªçn
    for (const skill of skillsData) {
        // Ki·ªÉm tra k·ªπ nƒÉng m·ªõi c√≥ th·ªÉ h·ªçc
        const requiredLevel = skillsData.indexOf(skill) + 1;
        if (!activeSkills.includes(skill) && player.level >= requiredLevel) {
            newSkills.push(skill);
        }

        // L·∫•y c√°c n√¢ng c·∫•p c·ªßa k·ªπ nƒÉng ƒë√£ h·ªçc
        const activeSkill = activeSkills.find(s => s.name === skill.name);
        if (activeSkill && skill.upgrades) {
            upgradesBySkill[skill.name] = upgradesBySkill[skill.name] || [];
            for (const upgrade of skill.upgrades) {
                if (!isOverLimit(upgrade)) {
                    upgradesBySkill[skill.name].push({ ...upgrade, skillName: skill.name });
                }
            }
        }
    }

    // 2. Ch·ªçn 3 l·ª±a ch·ªçn t·ª´ c√°c pool ƒë√£ thu th·∫≠p
    let choices = [];
    if (newSkills.length > 0) {
        // ∆Øu ti√™n 1 k·ªπ nƒÉng m·ªõi
        const newSkillIndex = Math.floor(Math.random() * newSkills.length);
        const pickNew = newSkills[newSkillIndex];
        choices.push(pickNew);

        // T·∫°o pool ƒë·ªÉ ch·ªçn 2 n√¢ng c·∫•p c√≤n l·∫°i
        const pool = [];
        // Th√™m c√°c k·ªπ nƒÉng m·ªõi c√≤n l·∫°i v√†o pool
        for (let i = 0; i < newSkills.length; i++) {
            if (i !== newSkillIndex) {
                pool.push(newSkills[i]);
            }
        }
        // Th√™m c√°c n√¢ng c·∫•p v√†o pool
        for (const skillName in upgradesBySkill) {
            const upgrades = upgradesBySkill[skillName];
            if (upgrades.length > 0) {
                const randomUpgrade = upgrades[Math.floor(Math.random() * upgrades.length)];
                pool.push(randomUpgrade);
            }
        }
        shuffle(pool).slice(0, 2).forEach(choice => choices.push(choice));

    } else {
        // N·∫øu kh√¥ng c√≥ k·ªπ nƒÉng m·ªõi, ch·ªçn ng·∫´u nhi√™n 3 n√¢ng c·∫•p
        const uniqueUpgrades = Object.values(upgradesBySkill).map(upgrades => upgrades[Math.floor(Math.random() * upgrades.length)]);
        choices = shuffle(uniqueUpgrades).slice(0, 3);
    }

    // 3. Render n√∫t b·∫•m
    choices.forEach(ch => {
        const btn = document.createElement('button');
        if (ch.icon) { // ƒê√¢y l√† k·ªπ nƒÉng m·ªõi
            btn.textContent = `${ch.icon} ${ch.name}`;
            btn.onclick = () => {
                playSound('sfx-upgrade-select');
                learnSkill(skillsData.indexOf(ch));
                popup.style.display = 'none';
                isPaused = false;
            };
        } else { // ƒê√¢y l√† n√¢ng c·∫•p
            btn.textContent = ch.name;
            btn.style.borderColor = { B·∫°c: '#aaa', V√†ng: 'gold', Kim: '#c770ff', ƒê·ªè: 'red' }[ch.tier] || '#ccc';
            btn.onclick = () => {
                playSound('sfx-upgrade-select');
                ch.effect?.();
                showWarning(` ${ch.name}`);
                popup.style.display = 'none';
                isPaused = false;
            };
        }
        container.appendChild(btn);
    });

    popup.style.display = 'block';
}

// üßæ C·∫≠p nh·∫≠t th√¥ng tin th·ªëng k√™ trong overlay
function updateStatsOverlay() {
  /* üëá 1. T√≠nh l·∫°i t·ªïng m·ªói l·∫ßn v·∫Ω */
  const alive  = zombies.length;      // ƒëang c√≤n tr√™n b·∫£n ƒë·ªì
  const killed = zombieKillCount;     // ƒë√£ ti√™u di·ªát
  const total  = alive + killed;      // t·ªïng th·ª±c
const now = Date.now();
  document.getElementById("stat-damage").innerText =
  `üí• Dmg: ${(playerUpgrades.damageBoost || 1).toFixed(1)} | Crit: ${Math.round(getCritRate(now)*100)}% | x ${(1+getCritDmg(now)).toFixed(2)}`;
  document.getElementById("stat-spawned").innerText = `üßü T·ªïng s·ªë zombie: ${total}`;
  document.getElementById("stat-alive").innerText   = `üßü ƒêang c√≤n s·ªëng: ${alive}`;
  document.getElementById("stat-total").innerText   = `üßü ƒê√£ ti√™u di·ªát: ${killed}`;
  document.getElementById("stat-speed").innerText =
  `üí® Att.speed: ${playerUpgrades.bulletSpeed.toFixed(1)} | üèπ: ${getIceArrowSpeed().toFixed(1)}`;
  document.getElementById("stat-iceArrow").innerText =
  `üèπ Ice Arrow: ${playerUpgrades.iceArrow} | +${getIceArrowBonusDamage().toFixed(1)} dmg | ${getIceArrowRate().toFixed(1)}x `;
  document.getElementById("stat-lineCount").innerText = `üß® S·ªë l∆∞·ª£ng ƒë·∫°n: ${playerUpgrades.lineBulletCount}`;
  document.getElementById("stat-moveSpeed").innerText = `üëü T·ªëc ƒë·ªô ch·∫°y: ${player.speed.toFixed(1)}`;
  // üî™ Th·ªëng k√™ k·ªπ nƒÉng m·∫∑c ƒë·ªãnh
  document.getElementById("stat-blade").innerText = `üî™ ƒêao: ${skillUpgrades.bladeCount} ƒëao, ${skillUpgrades.bladeDamage.toFixed(1)} dmg`;
  document.getElementById("stat-sword").innerText = `‚öîÔ∏è Ki·∫øm: Lv${skillUpgrades.swordLevel}, ${skillUpgrades.swordDamage.toFixed(1)} dmg`;
  document.getElementById("stat-fire").innerText = `üî• L·ª≠a: ${skillUpgrades.fireCount} l·ª≠a, ${skillUpgrades.fireDamage.toFixed(1)} dmg`;
  document.getElementById("stat-ice").innerText = `‚ùÑÔ∏è BƒÉng: ${skillUpgrades.iceCount} bƒÉng, ${skillUpgrades.iceDamage.toFixed(1)} dmg`;
  document.getElementById("stat-thunder").innerText = `üîµ L√¥i: ${skillUpgrades.thunderCount} c·∫ßu, ${skillUpgrades.thunderDamage.toFixed(1)} dmg`;
// K·ªπ nƒÉng kh√°c
const skillText = Object.entries(skillStats)
  .map(([key, value]) => `${key}: ${value}`)
  .join("<br>");
  document.getElementById("stat-skills").innerHTML = skillText;

// üßü Zombie theo c·∫•p: ch·ªâ hi·ªÉn th·ªã t·ª´ C·∫•p 1 ‚Üí 10
  let breakdown = "";
  for (let i = 1; i <= 10; i++) {
    breakdown += `<div>üßü C·∫•p ${i}: ${zombieByLevel[i] || 0}</div>`;
  }

// üíÄ Th·ªëng k√™ Mini Boss & Boss ·ªü cu·ªëi
  const miniBossLine = `<div>üíÄ Mini Boss: ${zombieByLevel.miniBoss || 0}</div>`;
  const bossLine = `<div>üíÄ Boss: ${zombieByLevel.boss || 0}</div>`;
  const bigBossLine = `<div>üíÄ BigBoss: ${zombieByLevel.bigBoss || 0}</div>`;
  document.getElementById("stat-breakdown").innerHTML =
  breakdown + miniBossLine + bossLine + bigBossLine;
}
const activeSkills = [];

// K·ªπ nƒÉng m·∫´u
const skillsData = [
  {
    name: "Khi√™n b·∫£o v·ªá",
    icon: "üõ°Ô∏è",
    manaCost: 10,
    duration: 60000,
    description: "T·∫°o m·ªôt v√≤ng b·∫£o v·ªá ho√†n h·∫£o ch·∫Øn m·ªçi s√°t th∆∞∆°ng."
  },
  {
    name: "V·ªá tinh laze",
    icon: "üõ∞Ô∏è",
    manaCost: 20,
    duration: 30000,
    baseDamage: 3,
    description: "Tri·ªáu h·ªìi 1~2 v·ªá tinh xoay quanh v√† b·∫Øn laze xuy√™n zombie."
  },
{
  name: "T√™n l·ª≠a F18",
  icon: "üöÄ",
  manaCost: 25,
  duration: 30000,
  baseDamage: 6,
  description: "G·ªçi 1~5 t√™n l·ª≠a truy t√¨m v√† ti√™u di·ªát zombie.",
  upgrades: []
},
{
  name: "UFO t·∫•n c√¥ng",
  icon: "üõ∏",
  manaCost: 30,
  duration: 30000,
  baseDamage: 5,
  description: "G·ªçi UFO h·ªó tr·ª£ b·∫Øn laze ƒë·ªè ti√™u di·ªát zombie xung quanh.",
  upgrades: []
},
{
  name: "B√£o s√©t",
  icon: "üå©Ô∏è",
  manaCost: 35,
  duration: 33000,
  baseDamage: 8,
  description: "G·ªçi 1~5 tia s√©t ng·∫´u nhi√™n ƒë√°nh quanh b·∫£n ƒë·ªì.",
  upgrades: []
},
{
  name: "Bom B52",
  icon: "üí£",
  manaCost: 52,
  duration: 52000,
  baseDamage: 10,
  description: "M√°y bay mang theo Bom B52 th·∫£ h√†ng lo·∫°t ti√™u di·ªát zombie."
},
  {
    name: "·∫¢o ·∫£nh ph√¢n th√¢n",
    icon: "üé≠",
    manaCost: 20,
    duration: 45000,
    baseDamage: 5,
    description: "Tri·ªáu h·ªìi 2 b·∫£n sao h·ªó tr·ª£ b·∫Øn."
  },
  {
    name: "H·ªë ƒëen",
    icon: "üï≥Ô∏è",
    manaCost: 60,
    duration: 30000,
    baseDamage: 50,
    description: "T·∫°o m·ªôt h·ªë ƒëen h√∫t zombie xung quanh."
  },
  {
    name: "Bi·∫øn h√¨nh",
    icon: "üê∏",
    manaCost: 5,
    duration: 10000,
    description: "Gi·∫£ d·∫°ng th√†nh ·∫øch ƒë·ªìng th·ªùi tƒÉng t·ªëc, zombie s·∫Ω b·ªè ƒëi kh√¥ng t·∫•n c√¥ng."
  },
  {
    name: "Boom h·∫°t nh√¢n",
    icon: "‚ò¢Ô∏è",
    manaCost: 100,
    duration: 20000,
    baseDamage: 100,
    description: "Bom h·∫°t nh√¢n ph√°t n·ªï to√†n b·∫£n ƒë·ªì, s√°t th∆∞∆°ng c·ª±c l·ªõn."
  },
{
    name: "Qu·∫£ c·∫ßu h·∫•p huy·∫øt",
    icon: "ü©∏",
    manaCost: 25,
    duration: 25000,
    baseDamage: 2,
    description: "Tri·ªáu h·ªìi 1~2 qu·∫£ c·∫ßu ƒë·ªè.\nM·ªói gi√¢y h√∫t m√°u zombie g·∫ßn nh·∫•t, g√¢y s√°t th∆∞∆°ng v√† h·ªìi 1 HP.",
    upgrades: []
},
{
    name: "C·ªïng Kh√¥ng Gian",
    icon: "üåÄ",
    manaCost: 50,
    duration: 30000,
    baseDamage: 10,
    description: "M·ªü m·ªôt c·ªïng d·ªãch chuy·ªÉn ƒë∆∞a b·∫°n ƒë·∫øn m·ªôt v·ªã tr√≠ ng·∫´u nhi√™n an to√†n tr√™n b·∫£n ƒë·ªì."
  },
];
/* ƒë·∫∑t sau khai b√°o skillsData */
const skillTooltipMap = Object.fromEntries(
  skillsData.map(sk => [
    sk.name,
    `${sk.icon} ${sk.name}\n‚îÄ Mana ${sk.manaCost}üí†, ${sk.duration/1000}s\n${sk.description}`
  ])
);

// üß™ Th√™m n√¢ng c·∫•p cho t·ª´ng k·ªπ nƒÉng c√≥ baseDamage
skillsData.forEach(skill => {
  if (skill.baseDamage !== undefined) {
      skill.upgrades = [
{
        name: `${skill.icon} +1 s√°t th∆∞∆°ng`,
        tier: "B·∫°c",
        effect: () => { skill.baseDamage += 1; 
        updateSkillsList(); 
}
},
{
      name: `${skill.icon} +2 s√°t th∆∞∆°ng`,
      tier: "V√†ng",
      effect: () => { skill.baseDamage += 2;
      updateSkillsList();
}
},
{
        name: `${skill.icon} +3 s√°t th∆∞∆°ng`,
        tier: "Kim",
        effect: () => { skill.baseDamage += 3;
        updateSkillsList();
}
}
];

    if (skill.name === "B√£o s√©t") {
    skill.upgrades.push({
    name: "üå©Ô∏è +1 tia s√©t (t·ªëi ƒëa 5)",
    tier: "ƒê·ªè",
    effect: () => {
  const skill = activeSkills.find(s => s.name === "B√£o s√©t");
  if (skill) {
    skill.level = (skill.level || 0) + 1;
    showWarning("üå©Ô∏è +1 tia s√©t!");
    updateSkillsList();
}
}
});
}
if (skill.name === "H·ªë ƒëen") {
  skill.upgrades.push({
    name: "üï≥Ô∏è +1 h·ªë ƒëen (t·ªëi ƒëa 2)",
    tier: "ƒê·ªè",
    effect: () => {
      const skill = activeSkills.find(s => s.name === "H·ªë ƒëen");
      if (skill) {
        skill.level = Math.min((skill.level || 0) + 1, 2); // +1 t·ªõi t·ªëi ƒëa 2 h·ªë ƒëen
        showWarning("üï≥Ô∏è +1 h·ªë ƒëen!");
        updateSkillsList();
      }
    }
  });
}

if (skill.name === "V·ªá tinh laze") {
  skill.upgrades.push({
    name: "üõ∞Ô∏è +1 v·ªá tinh (t·ªëi ƒëa 2)",
    tier: "ƒê·ªè",
    effect: () => {
      const skill = activeSkills.find(s => s.name === "V·ªá tinh laze");
      if (skill) {
        skill.level = Math.min((skill.level || 0) + 1, 2); // +1 t·ªõi t·ªëi ƒëa 2 v·ªá tinh
        showWarning("üõ∞Ô∏è +1 v·ªá tinh!");
        updateSkillsList();
}
}
});
}

if (skill.name === "UFO t·∫•n c√¥ng") {
  skill.upgrades.push({
    name: "üõ∏ +1 UFO (t·ªëi ƒëa 3)",
    tier: "ƒê·ªè",
effect: () => {
  const skill = activeSkills.find(s => s.name === "UFO t·∫•n c√¥ng");
  if (skill) {
    skill.level = (skill.level || 0) + 1;
    showWarning("üõ∏ +1 UFO!");
    updateSkillsList();
}
}
});
}

// üéØ N·∫øu l√† k·ªπ nƒÉng T√™n l·ª≠a th√¨ th√™m n√¢ng c·∫•p s·ªë l∆∞·ª£ng
    if (skill.name === "T√™n l·ª≠a F18") {
      skill.upgrades.push({
        name: `${skill.icon} +1 t√™n l·ª≠a (t·ªëi ƒëa 5)`,
        tier: "ƒê·ªè",
effect: () => {
  const skill = activeSkills.find(s => s.name === "T√™n l·ª≠a F18");
  if (skill) {
    skill.level = (skill.level || 0) + 1;
    showWarning("üöÄ +1 t√™n l·ª≠a!");
    updateSkillsList();
}
}
});
}
if (skill.name === "Qu·∫£ c·∫ßu h·∫•p huy·∫øt") {
    skill.upgrades.push({
        name: "ü©∏ +1 qu·∫£ c·∫ßu (t·ªëi ƒëa 2)",
        tier: "ƒê·ªè",
        effect: () => {
            const skill = activeSkills.find(s => s.name === "Qu·∫£ c·∫ßu h·∫•p huy·∫øt");
            if (skill) {
                skill.level = Math.min((skill.level || 0) + 1, 2);
                showWarning("ü©∏ +1 Qu·∫£ c·∫ßu!");
                updateSkillsList();
            }
        }
    });
}
}
});
// üîç Gh√©p m√¥ t·∫£ chi ti·∫øt cho m·ªói skill
function buildSkillTooltip(skill) {
  const secs = (skill.duration ?? 0) / 1000;
  const rows = [
    `${skill.icon} ${skill.name}`,
    `Mana: ${skill.manaCost}üí†  ‚Ä¢  Th·ªùi gian: ${secs ? secs + " s" : "t·ª©c th√¨"}`,
  ];

  // --- S√°t th∆∞∆°ng hi·ªán t·∫°i (n·∫øu c√≥) ---
  if (skill.baseDamage !== undefined)
    rows.push(`S√°t th∆∞∆°ng: ${skill.baseDamage}`);

  // --- Level hi·ªán t·∫°i c·ªßa c√°c n√¢ng c·∫•p ƒë·ªè ---
  if (skill.level !== undefined)
    rows.push(`C·∫•p hi·ªán t·∫°i: ${skill.level}`);

  // --- Danh s√°ch n√¢ng c·∫•p kh·∫£ d·ª•ng ---
  /*if (skill.upgrades?.length) {
    rows.push("N√¢ng c·∫•p:");
    skill.upgrades.forEach(u => rows.push(`‚Ä¢ ${u.name}  [${u.tier}]`));
  }*/

  // --- M√¥ t·∫£ g·ªëc --- "", ch√®n tr∆∞·ªõc m√¥ t·∫£ n·∫øu c√≥
  if (skill.description) rows.push(`M√¥ t·∫£: ${skill.description}`);

  return rows.join("\n");
}
// üß™ H√†m h·ªçc k·ªπ nƒÉng m·ªõi
function updateSkillsList() {
    const list = document.getElementById('skills-list');
    list.innerHTML = '';
    
    // Ch·ªâ t·∫°o l·∫°i c√°c item trong danh s√°ch k·ªπ nƒÉng
    activeSkills.forEach(skill => {
        const div = document.createElement('div');
        div.className = 'skill-item';
        div.dataset.tooltip = buildSkillTooltip(skill);

        // Lu√¥n hi·ªÉn th·ªã th√¥ng tin c∆° b·∫£n
        div.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${skill.manaCost}üí†`;

        // G√°n s·ª± ki·ªán click tr·ª±c ti·∫øp
      div.onclick = () => {
          // üîí Kh√≥a click ·ªü safe zone
          if (window.isPlayerInSafeZone || safeZones.some(zone => distance(player, zone) < zone.radius)) {
              // (Kh√¥ng l√†m g√¨ c·∫£ ƒë·ªÉ tr√°nh spam)
              return;
          }
          if (player.mana >= skill.manaCost && (!skill.endTime || Date.now() > skill.endTime)) {
              activateSkill(skill);
          }
      };

      // ƒê·ªìng b·ªô tr·∫°ng th√°i disable ngay khi render
      if (window.isPlayerInSafeZone) {
          div.classList.add('disabled');
      }
        list.appendChild(div);
    });

    // G√°n l·∫°i s·ª± ki·ªán cho tooltip (gi·ªØ nguy√™n logic g·ªëc c·ªßa b·∫°n)
    document.querySelectorAll('#skills-list .skill-item[data-tooltip]').forEach(it => {
        it.addEventListener('mouseenter', () => {
            const ln = (it.dataset.tooltip.match(/\n/g)?.length || 0) + 1;
            const hTip = ln * 18 + 12;
            const r = it.getBoundingClientRect();
            const gap = 8;
            const overTop = Math.max(gap - r.top, 0);
            const overBottom = Math.max((r.top + hTip) - (innerHeight - gap), 0);
            const shiftValue = overTop - overBottom;
            it.style.setProperty('--tip-shift', `${shiftValue}px`);
        });

        it.addEventListener('mouseleave', () => {
            it.style.removeProperty('--tip-shift');
        });
    });
}

// üß™ Test: Th√™m k·ªπ nƒÉng b·∫•t k·ª≥ b·∫±ng ph√≠m s·ªë 1‚Äì9, 0
document.addEventListener("keydown", (e) => {
    // N·∫øu ng∆∞·ªùi d√πng ƒëang g√µ trong m·ªôt √¥ INPUT, h√£y tho√°t ra ngay v√† kh√¥ng l√†m g√¨ c·∫£.
    if (e.target.tagName === 'INPUT') {
        return;
    }

    const keys = "1234567890-=";
    const index = keys.indexOf(e.key);

    // N·∫øu ph√≠m ƒë∆∞·ª£c nh·∫•n n·∫±m trong danh s√°ch ph√≠m test
    if (index >= 0 && skillsData[index]) {
        // G·ªçi tr·ª±c ti·∫øp h√†m learnSkill ƒë·ªÉ ƒë·∫£m b·∫£o logic ƒë·ªìng nh·∫•t
        learnSkill(index);
    }
});

function activateSkill(skill) {
  // Ki·ªÉm tra n·∫øu kh√¥ng ƒë·ªß mana ho·∫∑c k·ªπ nƒÉng ƒëang h·ªìi chi√™u
  if (!skill || player.mana < skill.manaCost || (skill.endTime && Date.now() < skill.endTime)) {
    return;
  }
  playSound('sfx-ui-click', 0.2); // Ph√°t √¢m thanh khi k√≠ch ho·∫°t k·ªπ nƒÉng
  player.mana -= skill.manaCost;
  // G√°n th·ªùi gian k·∫øt th√∫c h·ªìi chi√™u v√†o ch√≠nh ƒë·ªëi t∆∞·ª£ng skill
  skill.endTime = Date.now() + skill.duration;

  // Logic k√≠ch ho·∫°t hi·ªáu ·ª©ng c·ªßa k·ªπ nƒÉng
  switch (skill.name) {
    case "Khi√™n b·∫£o v·ªá": activateShield(skill); break;
    case "V·ªá tinh laze":
      // --- B·∫ÆT ƒê·∫¶U ƒêO·∫†N M√É M·ªöI ---
      satelliteActive = true;
      satelliteEndTime = Date.now() + skill.duration;
      
      const satCount = Math.min(skill.level || 1, 2);
      const orbitRadius = 60; // ch·ªânh b√°n k√≠nh quay ·ªü ƒë√¢y
      const orbitSpeed = 0.002; // ch·ªânh t·ªëc ƒë·ªô quay ·ªü ƒë√¢y

      satellites = [];
      for (let i = 0; i < satCount; i++) {
          satellites.push({
              // G√°n cho m·ªói v·ªá tinh m·ªôt g√≥c ban ƒë·∫ßu ƒë·ªÉ ch√∫ng c√°ch ƒë·ªÅu nhau
              angle: (2 * Math.PI / satCount) * i, 
              orbitRadius: orbitRadius,
              orbitSpeed: orbitSpeed
          });
      }
      showWarning(`${skill.icon} ${skill.name}!`); // Gi·ªØ l·∫°i th√¥ng b√°o
      // --- K·∫æT TH√öC ƒêO·∫†N M√É M·ªöI ---
      break;
    case "T√™n l·ª≠a F18": activateTwinMissiles(skill); break;
    case "UFO t·∫•n c√¥ng": activateUFO(skill); break;
    case "B√£o s√©t": activateLightning(skill); break;
    case "Bom B52": activateBombs(skill); break;
    case "·∫¢o ·∫£nh ph√¢n th√¢n": activateClones(skill); break;
    case "H·ªë ƒëen": activateBlackHole(skill); break;
    case "Bi·∫øn h√¨nh": activateDisguise(skill); break;
    case "Boom h·∫°t nh√¢n": activateNuclearBomb(skill); break;
    case "Qu·∫£ c·∫ßu h·∫•p huy·∫øt": activateBloodOrb(skill); break;
    case "C·ªïng Kh√¥ng Gian": activateSpaceGate(skill); break;
  }

// L√†m s√°ng n√∫t k·ªπ nƒÉng t∆∞∆°ng ·ª©ng v√† ƒë·∫øm ng∆∞·ª£c
const list = document.getElementById('skills-list').children;
for (let i = 0; i < list.length; i++) {
  const item = list[i];
  if (item.textContent.includes(skill.name)) {
    item.classList.add("active");
    const endTime = Date.now() + skill.duration;
    const interval = setInterval(() => {
      const remain = Math.ceil((endTime - Date.now()) / 1000);
      if (remain > 0) {
        item.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${remain}s`;
} else {
        item.classList.remove("active");
        item.innerHTML = `<span class="skill-icon">${skill.icon}</span> ${skill.name} - ${skill.manaCost}üí†`;
        clearInterval(interval);
}
}, 1000);
break;
}
}
// Hi·ªÉn th·ªã th√¥ng b√°o k·ªπ nƒÉng ƒë√£ k√≠ch ho·∫°t
  showWarning(`${skill.icon} ${skill.name}!`);
}
// üßü‚Äç‚ôÇÔ∏è K·ªπ nƒÉng: T·∫°o c√°c k·ªπ nƒÉng ƒë·∫∑c bi·ªát cho ng∆∞·ªùi ch∆°i
// üõ°Ô∏è Khi√™n b·∫£o v·ªá: T·∫°o l·ªõp ch·∫Øn ch·∫∑n s√°t th∆∞∆°ng v√† hi·ªÉn th·ªã hi·ªáu ·ª©ng
function activateShield(skill) {
  player.shieldActive = true;
  player.shieldEndTime = Date.now() + skill.duration;

  setTimeout(() => {
    player.shieldActive = false;
}, skill.duration);
}

// üöÄ T√™n l·ª≠a F18: 2 t√™n l·ª≠a bay quanh ng∆∞·ªùi ch∆°i, xuy√™n v√† g√¢y s√°t th∆∞∆°ng zombie
// ===== Twin Missiles (t·ªëi ∆∞u, kh√¥ng filter/sort) =====

// Buffer t·∫°m d√πng l·∫°i cho l·∫ßn g·ªçi sau (gi·∫£m GC):
const twinTmpTargets = []; // s·∫Ω ch·ªâ ch·ª©a t·ªëi ƒëa K ph·∫ßn t·ª≠ { z, d2 }

// Ch·ªçn t·ªëi ƒëa K zombie xa ng∆∞·ªùi ch∆°i nh·∫•t trong b√°n k√≠nh TWIN_R (m·ªôt pass, kh√¥ng sort)
function selectFarthestKZombies(K, R, outArr) {
  outArr.length = 0;                // t√°i d√πng m·∫£ng, kh√¥ng c·∫•p ph√°t m·∫£ng m·ªõi
  const R2 = R * R;

  for (let i = 0; i < zombies.length; i++) {
    const z = zombies[i];
    if (!z || !z.active) continue;

    const dx = z.x - player.x, dy = z.y - player.y;
    const d2 = dx * dx + dy * dy;
    if (d2 > R2) continue;          // ngo√†i t·∫ßm ‚Üí b·ªè

    // chen v√†o outArr (s·∫Øp x·∫øp gi·∫£m d2) v·ªõi k√≠ch th∆∞·ªõc t·ªëi ƒëa K
    if (outArr.length < K) {
      // ch√®n gi·ªØ th·ª© t·ª± gi·∫£m d2
      let j = outArr.length - 1;
      outArr.push(null);            // m·ªü r·ªông m·∫£ng tr∆∞·ªõc khi d·ªãch
      while (j >= 0 && outArr[j].d2 < d2) { outArr[j + 1] = outArr[j]; j--; }
      outArr[j + 1] = { z, d2 };    // (t·ªëi ƒëa K entry ‚Üí c·∫•p ph√°t t·ªëi ƒëa K object)
    } else if (outArr[outArr.length - 1].d2 < d2) {
      // l·ªõn h∆°n ph·∫ßn t·ª≠ nh·ªè nh·∫•t hi·ªán c√≥ ‚Üí ch√®n v√†o ƒë√∫ng v·ªã tr√≠
      let j = outArr.length - 1;
      while (j > 0 && outArr[j - 1].d2 < d2) { outArr[j] = outArr[j - 1]; j--; }
      outArr[j] = { z, d2 };
    }
  }
}

function activateTwinMissiles(skill) {
  const K = Math.min(skill.level || 1, 5); // t·ªëi ƒëa 5 m·ª•c ti√™u/ƒë·ª£t
  const TWIN_R = 360;                      // b√°n k√≠nh qu√©t m·ª•c ti√™u
  const MISSILE_RADIUS = 40;               // b√°n ra v√≤ng tr√≤n quanh player
  const SPAWN_DELAY = 2000;                // ms gi·ªØa c√°c ƒë·ª£t
  const LIFE_TIME = skill.duration;        // t·ªïng th·ªùi gian hi·ªáu l·ª±c

  // H√†m t·∫°o 1 ƒë·ª£t t√™n l·ª≠a
  const spawnWave = () => {
    selectFarthestKZombies(K, TWIN_R, twinTmpTargets);
    const count = twinTmpTargets.length;
    if (count === 0) return;

    for (let i = 0; i < count; i++) {
      const target = twinTmpTargets[i].z;

      // v·ªã tr√≠ xu·∫•t ph√°t ng·∫´u nhi√™n quanh player (bo tr√≤n nh·∫π)
      const ang = Math.random() * Math.PI * 2;
      const x = player.x + Math.cos(ang) * MISSILE_RADIUS;
      const y = player.y + Math.sin(ang) * MISSILE_RADIUS;

      missiles.push({
        x, y,
        dx: 0, dy: 0,
        target,                 // m·ª•c ti√™u ri√™ng cho missile n√†y
        damage: skill.baseDamage,
        delay: 120,             // gi·ªØ logic delay c·ªßa b·∫°n
        state: "delay",
        startX: x,
        startY: y,
        hitSet: new Set(),      // c·∫ßn theo d√µi ƒë√£ ch·∫°m ai; n·∫øu kh√¥ng c·∫ßn, b·ªè ƒë·ªÉ gi·∫£m c·∫•p ph√°t
      });
    }
  };

  // üîµ T·∫°o ngay 1 ƒë·ª£t ƒë·∫ßu
  spawnWave();

  // ‚è± L·∫∑p l·∫°i ƒë·∫øn khi h·∫øt th·ªùi gian k·ªπ nƒÉng
  const intervalId = setInterval(spawnWave, SPAWN_DELAY);
  setTimeout(() => clearInterval(intervalId), LIFE_TIME);
}

// UFO t·∫•n c√¥ng
function activateUFO(skill) {
  ufoActive = true;
  ufoEndTime = Date.now() + skill.duration;
  
  // X√°c ƒë·ªãnh s·ªë l∆∞·ª£ng UFO d·ª±a tr√™n c·∫•p k·ªπ nƒÉng
  const ufoCount = Math.min(skill.level || 3, 3); // T·ªëi ƒëa 3 UFO
  const damage = skill.baseDamage;

ufos = Array.from({ length: ufoCount }, (_, i) => {
    // Th·ªùi gian ng·∫´u nhi√™n t·ª´ 1-3 gi√¢y cho m·ªói l·∫ßn ƒë·ªïi h∆∞·ªõng
    const interval = 1000 + Math.random() * 2000; 

    return {
        relativeX: 80 + Math.random() * 120,
        relativeY: 120 + Math.random() * 120,
        speedX: (Math.random() - 0.5) * 2,
        speedY: (Math.random() - 0.5) * 1.5,
        directionChangeInterval: interval, // Kho·∫£ng th·ªùi gian gi·ªØa 2 l·∫ßn ƒë·ªïi h∆∞·ªõng
        nextDirectionChangeTime: Date.now() + interval, // M·ªëc th·ªùi gian ƒë·ªÉ ƒë·ªïi h∆∞·ªõng ti·∫øp theo
        damage,
        laserCooldown: Date.now() + Math.random() * 1000, // Th·ªùi gian b·∫Øn ng·∫´u nhi√™n l√∫c ƒë·∫ßu
        laserLife: 0,
        angle: 0
};
});
  // X√≥a UFO sau khi h·∫øt th·ªùi gian k·ªπ nƒÉng
  setTimeout(() => {
    ufoActive = false;
    ufos = [];
  }, skill.duration);
}

// === Helper: v·∫Ω ƒë∆∞·ªùng s√©t ngo·∫±n ngo√®o =========================
function getZigZag(start, target, segments = 8, jitter = 20) {
  const pts = [start];                         // ƒëi·ªÉm ƒë·∫ßu l√† ƒë√°m m√¢y
  for (let i = 1; i < segments; i++) {
    const t = i / segments;                    // n·ªôi suy tuy·∫øn t√≠nh
    pts.push({
      x: start.x + (target.x - start.x) * t + (Math.random() - 0.5) * jitter,
      y: start.y + (target.y - start.y) * t + (Math.random() - 0.5) * jitter
    });
  }
    pts.push({
      x: target.x + (Math.random() - 0.5) * jitter,
      y: target.y + (Math.random() - 0.5) * jitter
});
  return pts;                                  // m·∫£ng [{x,y}, ‚Ä¶]
}

// üå©Ô∏è b√£o s√©t: G·ªçi s√©t ng·∫´u nhi√™n g√¢y s√°t th∆∞∆°ng di·ªán r·ªông
function activateLightning(skill) {
    lightningActive = true;
    lightningStartTime = Date.now(); // S·ª≠ d·ª•ng bi·∫øn n√†y l√†m m·ªëc th·ªùi gian b·∫Øt ƒë·∫ßu
    lightningEndTime = lightningStartTime + skill.duration;

    const boltCount = Math.min(skill.level || 5, MAX_LV.lightning);
    lightningBolts = []; // Reset l·∫°i c√°c ƒë√°m m√¢y
    for (let i = 0; i < boltCount; i++) {
    lightningBolts.push({
        // ƒê√£ x√≥a offsetX
        damage: skill.baseDamage,
        nextZapTime: Date.now() + Math.random() * 1000 // Th·ªùi gian cho l·∫ßn ph√≥ng s√©t ti·∫øp theo
        });
    }
    
    // H·∫πn gi·ªù ƒë·ªÉ t·∫Øt k·ªπ nƒÉng
    setTimeout(() => {
        lightningActive = false;
        lightningBolts = [];
    }, skill.duration);
}

// K√≠ch ho·∫°t k·ªπ nƒÉng Bom B52 - t√°i s·ª≠ d·ª•ng h√†m activateBombs
function spawnPlanes(skill, amount = 3) {
  const planeYBase = player.y - 180; // V·ªã tr√≠ m√°y bay b·∫Øt ƒë·∫ßu

  for (let i = 0; i < amount; i++) {
    const plane = {
      x: -100,
      y: planeYBase - i * 20,
      targetY: planeYBase - i * 20,
      vx: 1.5 + i * 0.5,
      lastDropTime: Date.now(),
      nextDropDelay: 5000 + i * 500 + Math.random() * 300,

      // üëá Hi·ªáu ·ª©ng bi·∫øn m·∫•t
      scale: 1,
      opacity: 1,
      disappearing: false
    };

    activePlanes.push(plane);

    // ‚úÖ C·∫≠p nh·∫≠t t·ªëc ƒë·ªô ngang m·ªói 1‚Äì5 gi√¢y
    function schedulePlaneSpeedAdjust() {
      const delay = Math.random() * (5000 - 1000) + 1000;
      plane._speedTimeout = setTimeout(() => {
        plane.vx = Math.random() * (5 - 0.5) + 0.5;
        schedulePlaneSpeedAdjust(); // G·ªçi l·∫°i ƒë·ªÉ l·∫∑p
      }, delay);
    }

    // ‚úÖ C·∫≠p nh·∫≠t ƒë·ªô cao dao ƒë·ªông m·ªói 1‚Äì5 gi√¢y
    function schedulePlaneHeightAdjust() {
      const delay = Math.random() * (5000 - 1000) + 1000;
      plane._heightTimeout = setTimeout(() => {
        plane.targetY += (Math.random() - 0.5) * 40; // dao ƒë·ªông ¬±20
        schedulePlaneHeightAdjust(); // L·∫∑p ti·∫øp
      }, delay);
    }

    // üîÑ K√≠ch ho·∫°t 2 chu k·ª≥ ƒëi·ªÅu ch·ªânh
    schedulePlaneSpeedAdjust();
    schedulePlaneHeightAdjust();

    // üéÆ C·∫≠p nh·∫≠t chuy·ªÉn ƒë·ªông v√† th·∫£ bom ƒë·ªãnh k·ª≥
    const planeInterval = setInterval(() => {
      const now = Date.now();

      // ‚û° Di chuy·ªÉn theo t·ªëc ƒë·ªô hi·ªán t·∫°i
      plane.x += plane.vx;

      // üìà Bay m∆∞·ª£t ƒë·∫øn targetY
      plane.y += (plane.targetY - plane.y) * 0.05;

      // üí£ Th·∫£ bom n·∫øu ƒë·∫øn th·ªùi ƒëi·ªÉm
      if (now - plane.lastDropTime > plane.nextDropDelay) {
        plane.lastDropTime = now;
        plane.nextDropDelay = 1000 + Math.random() * 2000; // t·ª´ 1‚Äì3s

        const targetY = plane.y + 100 + Math.random() * (canvas.height * 0.9); // 90%
        bombsB52.push({
          x: plane.x,
          y: plane.y,
          vy: 3,
          exploded: false,
          landed: false,
          finalY: targetY,
          timerAfterLand: 180,
          radius: 15,
          damage: skill.baseDamage
        });
      }

      // üåÄ Khi g·∫ßn r√¨a map th√¨ b·∫Øt ƒë·∫ßu bi·∫øn m·∫•t
      if (!plane.disappearing && plane.x > worldWidth - 180) {
        plane.disappearing = true;
      }

      // üßº Hi·ªáu ·ª©ng thu nh·ªè v√† xo√° m√°y bay
      if (plane.disappearing) {
        plane.scale *= 0.95;
        plane.opacity -= 0.05;

        if (plane.scale < 0.1 || plane.opacity <= 0) {
          clearInterval(planeInterval);
          clearTimeout(plane._speedTimeout);
          clearTimeout(plane._heightTimeout);
          activePlanes.splice(activePlanes.indexOf(plane), 1);
        }
      }
    }, 50);
  }
}
const planeWaves = [
  { delay: 0, amount: 1 },      // t·∫°o 3 m√°y bay ngay l·∫≠p t·ª©c
  { delay: 3000, amount: 1 },  // t·∫°o 5 m√°y bay sau 30s
  { delay: 6000, amount: 1 },
  { delay: 9000, amount: 1 },  // t·∫°o 2 m√°y bay sau 60s
];
// üí£ Bom B52: r∆°i xu·ªëng, n·ªï khi tr√∫ng zombie, n·∫øu kh√¥ng tr√∫ng th√¨ n·ªï sau 5s khi ch·∫°m ƒë·∫•t
function activateBombs(skill) {
  const skillEndTime = Date.now() + skill.duration;

  planeWaves.forEach(wave => {
    setTimeout(() => {
      spawnPlanes(skill, wave.amount);
    }, wave.delay);
  });
  // üí£ Update bom r∆°i
  const updateInterval = setInterval(() => {
    for (let i = bombsB52.length - 1; i >= 0; i--) {
      const bomb = bombsB52[i];
      if (bomb.exploded) continue;

      if (!bomb.landed) {
        bomb.y += bomb.vy;
        for (let z of zombies) {
          if (z.active && distance(bomb, z) < bomb.radius + z.radius) {
            explodeB52Bomb(bomb);
            bombsB52.splice(i, 1);
            break;
          }
        }
        if (bomb.y >= bomb.finalY) {
          bomb.y = bomb.finalY;
          bomb.landed = true;
        }
      } else {
        bomb.timerAfterLand--;
        if (bomb.timerAfterLand <= 0) {
          explodeB52Bomb(bomb);
          bombsB52.splice(i, 1);
        }
      }
    }

    if (Date.now() > skillEndTime && bombsB52.length === 0) {
      clearInterval(updateInterval);
    }
  }, 1000 / 60);

function explodeB52Bomb(bomb) {
    bomb.exploded = true;

    // ‚ú® B·∫ÆT ƒê·∫¶U PH·∫¶N C·∫¢I TI·∫æN ‚ú®
    // 1. V·ª• n·ªï ch√≠nh (100% s√°t th∆∞∆°ng)
    zombies.forEach(z => {
        if (z.active && distance(bomb, z) < 200) { // B√°n k√≠nh n·ªï 200px
            dealDamageToZombie(z, bomb.damage);
        }
    });
    createParticleExplosion(bomb.x, bomb.y, 50, 'fire'); // Hi·ªáu ·ª©ng n·ªï ch√≠nh

    // 2. V·ª• n·ªï ph·ª• (50% s√°t th∆∞∆°ng) sau 0.2 gi√¢y
    setTimeout(() => {
        zombies.forEach(z => {
            if (z.active && distance(bomb, z) < 200) {
                // G√¢y th√™m 50% s√°t th∆∞∆°ng
                dealDamageToZombie(z, bomb.damage * 0.5); 
            }
        });
        // T·∫°o m·ªôt v·ª• n·ªï nh·ªè h∆°n ƒë·ªÉ b√°o hi·ªáu
        const secondaryExplosion = getExplosion(bomb.x, bomb.y);
        secondaryExplosion.life = 15;
        explosions.push(secondaryExplosion);
    }, 200); // 200ms = 0.2 gi√¢y
    // ‚ú® K·∫æT TH√öC PH·∫¶N C·∫¢I TI·∫æN ‚ú®
}
}
// üé≠ ·∫¢o ·∫£nh ph√¢n th√¢n: T·∫°o 2 b·∫£n sao b·∫Øn ƒë·∫°n h·ªó tr·ª£
function activateClones(skill) {
  clonesActive = true;
  clonesEndTime = Date.now() + skill.duration;
  clones = [];

  const moveAngle = Math.random() * Math.PI * 2; // h∆∞·ªõng di chuy·ªÉn chung

  for (let i = 0; i < 2; i++) {
    const offset = (i === 0 ? -40 : 40); // clone tr√°i v√† ph·∫£i c√°ch nhau 80px
    clones.push({
      x: player.x + Math.cos(moveAngle + Math.PI / 2) * offset,
      y: player.y + Math.sin(moveAngle + Math.PI / 2) * offset,
      moveAngle: moveAngle,
      moveSpeed: 1.2,                     // T·ªëc ƒë·ªô di chuy·ªÉn clone
      baseDamage: skill.baseDamage || 5, // S√°t th∆∞∆°ng ri√™ng
      lastShot: 0,
      id: Date.now() + i, // T·∫°o 1 ID tia lazer
      shotCount: 0
    });
  }
}
// üï≥Ô∏è H·ªë ƒëen: H√∫t zombie v√†o t√¢m v√† g√¢y s√°t th∆∞∆°ng li√™n t·ª•c
function activateBlackHole(skill) {
  const holeCount = Math.min(skill.level || 2, 2);
  
  // T√°ch bi·ªát k√≠ch th∆∞·ªõc v√† ph·∫°m vi h√∫t
  const VISUAL_RADIUS = 150;  // K√≠ch th∆∞·ªõc h·ªë ƒëen s·∫Ω ƒë∆∞·ª£c v·∫Ω tr√™n m√†n h√¨nh
  const PULL_RADIUS = 200; // Ph·∫°m vi h√∫t zombie xung quanh

  const firstAngle = Math.random() * Math.PI * 2;

  for (let i = 0; i < holeCount; i++) {
    const angle = firstAngle + (i * Math.PI);
    const distance = 80 + Math.random() * 80;

    const x = player.x + Math.cos(angle) * distance;
    const y = player.y + Math.sin(angle) * distance;

    blackHoles.push({
      x: x,
      y: y,
      radius: VISUAL_RADIUS,     // G√°n k√≠ch th∆∞·ªõc V·∫º
      pullRadius: PULL_RADIUS,   // G√°n ph·∫°m vi H√öT
      damage: skill.baseDamage,
      pullSpeed: 3.5,
      tick: 0,
      endTime: Date.now() + skill.duration,
      dx: (Math.random() - 0.5) * 0.1,
      dy: (Math.random() - 0.5) * 0.1
    });
  }
}

// üê∏ Bi·∫øn h√¨nh: Zombie t·∫°m th·ªùi kh√¥ng ph√°t hi·ªán ng∆∞·ªùi ch∆°i (·∫©n th√¢n)
function activateDisguise(skill) {
  disguiseActive = true;
  disguiseEndTime = Date.now() + skill.duration;

  // (M·ªöI) Buff t·∫°m th·ªùi khi k√≠ch ho·∫°t
  player.hearts = Math.min(player.maxHearts, player.hearts + 20);
  showWarning("üê∏ Bi·∫øn h√¨nh! +20 HP & TƒÉng t·ªëc!");

  zombies.forEach(z => {
    if (!z.isBoss) {
      z.state = "wandering";
      z.wanderTime = Date.now() + 6000 + Math.random() * 4000;// Th·ªùi gian ƒëi lang thang ng·∫´u nhi√™n t·ª´ 6s ƒë·∫øn 10s
      z.wanderAngle = Math.random() * Math.PI * 2;

      // üí¨ Bi·ªÉu c·∫£m ng·∫´u nhi√™n n·∫øu kh√¥ng ph·∫£i boss
      if (Math.random() < 0.6) {
        const expressions = ["üòï", "ü§¢", "üò¥", "üò≥", "ü§Æ"];
        z.iconToDraw = expressions[Math.floor(Math.random() * expressions.length)];
        setTimeout(() => { z.iconToDraw = null; }, 5000); // Bi·ªÉu c·∫£m bi·∫øn m·∫•t sau 5s
      }
    }
  });
// Khi h·∫øt th·ªùi gian
setTimeout(() => {
    disguiseActive = false;
    player.hearts = Math.max(1, player.hearts - 20);
    showWarning("üê∏ H·∫øt bi·∫øn h√¨nh!");

    // --- LOGIC BOM KH√ìI ---
    // 1. T·∫°o hi·ªáu ·ª©ng kh√≥i h√¨nh ·∫£nh
    createParticleExplosion(player.x, player.y, 70, 'smoke');

    // 2. ƒê·∫©y l√πi v√† l√†m cho√°ng zombie ·ªü g·∫ßn
    const pushRadius = 300;
    const pushForce = 30;

    zombies.forEach(z => {
        if (z.active && distance(player, z) < pushRadius) {
            const angle = Math.atan2(z.y - player.y, z.x - player.x);
            z.x += Math.cos(angle) * pushForce;
            z.y += Math.sin(angle) * pushForce;
            z.state = "wandering"; // Bu·ªôc zombie ƒëi lang thang
        }
    });

}, skill.duration);

}
// M√†u cho bom h·∫°t nh√¢n khi ph√°t n·ªï
const colors = [
    "rgba(255,255,255,0.7)", // tr·∫Øng
    "rgba(255,0,0,0.7)",     // ƒë·ªè
    "rgba(0,255,0,0.7)",     // xanh l√°
    "rgba(0,200,255,0.7)",   // cyan
    "rgba(255,200,0,0.7)",   // v√†ng
    "rgba(255,0,255,0.7)"    // t√≠m
];
// ‚ò¢Ô∏è Bom H·∫°t Nh√¢n: R∆°i xu·ªëng gi·ªØa m√†n h√¨nh, ƒë·∫øm ng∆∞·ª£c 5s r·ªìi t·∫°o v√≤ng n·ªï lan r·ªông
function activateNuclearBomb(skill) {
    if (nuclearBombs.length >= 1) return;
    document.getElementById('sfx-nuke-fall').play(); // Ph√°t √¢m thanh bom r∆°i
    nuclearBombs.push({
        x: player.x,
        y: 100,
        vy: 3.5,
        exploded: false,
        landed: false,
        timerAfterLand: 5 * 60,
        damage: skill.baseDamage * 10,
        radius: 22,
        finalY: player.y,
        shockwave: false,
        shockwaveRadius: 0,
        shockwaveSpeed: 2
    });
    const updateInterval = setInterval(() => {
        if (nuclearBombs.length === 0) {
            clearInterval(updateInterval);
            return;
        }

        const bomb = nuclearBombs[0];
        if (bomb.exploded && !bomb.shockwave) return;
        // üí® Khi bom ch·∫°m ƒë·∫•t ‚Äì t·∫°o h·∫°t b·ª•i bay v√†o t√¢m bom
        if (bomb.landed && !bomb.exploded) {
        for (let i = 0; i < 2; i++) {
        createSuctionDust(bomb.x, bomb.y, 0.6); // T·ªëc ƒë·ªô tan nhanh ch·∫≠m
        }
        }
        // Bom r∆°i xu·ªëng
        if (!bomb.landed) {
            bomb.y += bomb.vy;
            if (bomb.y >= bomb.finalY) {
                bomb.landed = true;
                bomb.y = bomb.finalY;
                playSound('sfx-nuke-time', 0.8); // Ph√°t √¢m thanh ƒë·∫øm gi·ªù
            }
        }
        // ƒê·∫øm ng∆∞·ª£c n·ªï
        else if (!bomb.exploded) {
            bomb.timerAfterLand--;
            if (bomb.timerAfterLand <= 0) {
                explodeNuclearBomb(bomb);
            }
        }

        // S√≥ng xung k√≠ch sau khi n·ªï
        if (bomb.exploded && bomb.shockwave) {
            bomb.shockwaveRadius += bomb.shockwaveSpeed;
            zombies.forEach(z => {
                if (z.active && distance(bomb, z) < bomb.shockwaveRadius) {
                    // Ch·ªâ g√¢y s√°t th∆∞∆°ng n·∫øu zombie kh√¥ng c√≥ cooldown
                    if (!z.nukeCooldown || Date.now() > z.nukeCooldown) {
                        dealDamageToZombie(z, bomb.damage);
                        
                        // ƒê·∫∑t l·∫°i cooldown 1 gi√¢y cho con zombie n√†y
                        z.nukeCooldown = Date.now() + 1000; // 1s m·ªõi nh·∫≠n l·∫°i s√°t th∆∞∆°ng
                    }
                }
            });
            enemyBullets.forEach(b => {
                if (!b.active) return;
                if (distance(bomb, b) < bomb.shockwaveRadius) {
                    releaseEnemyBullet(b);
                    explosions.push(getExplosion(b.x, b.y));
                }
            });
            if (bomb.shockwaveRadius > Math.max(canvas.width, canvas.height) * 1.4) {
                nuclearBombs.shift();
                bomb.shockwave = false;
            }
        }
    }, 1000 / 60);
    // H√†m ph√°t n·ªï
    function explodeNuclearBomb(bomb) {
        // D·ª´ng √¢m thanh c√≤i h√∫/r∆°i
        const fallSound = document.getElementById('sfx-nuke-fall');
        if (fallSound) {
            fallSound.pause();
            fallSound.currentTime = 0; // Reset ƒë·ªÉ l·∫ßn sau c√≥ th·ªÉ ph√°t l·∫°i t·ª´ ƒë·∫ßu
        }
        // Ph√°t √¢m thanh n·ªï
        playSound('sfx-nuke-explode', 1.0); // Ph√°t ·ªü 100% √¢m l∆∞·ª£ng

        bomb.exploded = true;
        bomb.shockwave = true;
        bomb.shockwaveRadius = 0;
        explosions.push(getExplosion(bomb.x, bomb.y)); // üí• hi·ªáu ·ª©ng n·ªï nh·ªè trung t√¢m
        // üåä Th√™m 2 v√≤ng n·ªï ph·ª• m·ªói 2 gi√¢y
        setTimeout(() => {
            extraShockwaves.push({
                x: bomb.x,
                y: bomb.y,
                radius: 0,
                maxRadius: 300,
                color: "red",
                alpha: 1
            });
        }, 2000);
        setTimeout(() => {
            extraShockwaves.push({
                x: bomb.x,
                y: bomb.y,
                radius: 0,
                maxRadius: 400,
                color: "cyan",
                alpha: 1
            });
        }, 4000);
        // üí® H·∫°t b·ª•i bay ra khi bom ph√°t n·ªï
        for (let i = 0; i < 60; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 1 + 0.5;
    const color = colors[Math.floor(Math.random() * colors.length)]; // m√†u ng·∫´u nhi√™n
    particles.push({
        x: bomb.x,
        y: bomb.y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: Math.random() * 3 + 1,
        color: color,
        alpha: 1
    });
}
}
}
// ü©∏ Qu·∫£ c·∫ßu h·∫•p huy·∫øt
function activateBloodOrb(skill) {
    bloodOrbActive = true;
    bloodOrbEndTime = Date.now() + skill.duration;

    // X√°c ƒë·ªãnh s·ªë l∆∞·ª£ng qu·∫£ c·∫ßu theo level (t·ªëi ƒëa 2)
    const maxCount = Math.min(skill.level || 2, 2); // T·ªëi ƒëa 2 qu·∫£ c·∫ßu h·∫•p huy·∫øt
    bloodOrbCount = maxCount;

    bloodOrbs = Array.from({ length: maxCount }, (_, i) => ({
        angle: (2 * Math.PI / maxCount) * i,
        radius: 60,
        x: player.x,
        y: player.y
    }));
}
// ================== C·ªîNG KH√îNG GIAN ==================

// H√†m t√¨m m·ªôt v·ªã tr√≠ an to√†n ƒë·ªÉ d·ªãch chuy·ªÉn ƒë·∫øn
function findSafeTeleportLocation() {
  let bestX = player.x, bestY = player.y;
  let lowestZombieCount = Infinity;

  const MAX_ATTEMPTS = 20;
  const padding = 100;
  const BOSS_R2   = 500 * 500;  // kho·∫£ng c√°ch t·ªëi thi·ªÉu v·ªõi boss (b√¨nh ph∆∞∆°ng)
  const ZOMBIE_R2 = 300 * 300;  // b√°n k√≠nh ƒë·∫øm zombie (b√¨nh ph∆∞∆°ng)

  for (let i = 0; i < MAX_ATTEMPTS; i++) {
    // ƒëi·ªÉm ng·∫´u nhi√™n, tr√°nh r√¨a
    const x = Math.random() * (worldWidth  - padding * 2) + padding;
    const y = Math.random() * (worldHeight - padding * 2) + padding;

    let isValid = true;
    let nearbyZombies = 0;

    // 1 v√≤ng l·∫∑p duy nh·∫•t cho c·∫£ check boss + ƒë·∫øm zombie
    for (let j = 0; j < zombies.length; j++) {
      const z = zombies[j];
      if (!z || !z.active) continue;

      const dx = x - z.x;
      const dy = y - z.y;
      const d2 = dx*dx + dy*dy;

      // g·∫ßn boss ‚Üí lo·∫°i ngay, kh√¥ng c·∫ßn ƒë·∫øm ti·∫øp
      if ((z.isBoss || z.isBigBoss) && d2 < BOSS_R2) { isValid = false; break; }
      if (d2 < ZOMBIE_R2) nearbyZombies++;
    }

    if (!isValid) continue;

    if (nearbyZombies < lowestZombieCount) {
      lowestZombieCount = nearbyZombies;
      bestX = x; bestY = y;
      if (nearbyZombies === 0) break; // t√¨m ƒë∆∞·ª£c ch·ªó ‚Äútr·ªëng‚Äù ‚Üí tho√°t s·ªõm
    }
  }

  // Kh√¥ng t√¨m ƒë∆∞·ª£c g√¨ t·ªët ‚Üí fallback h·ª£p l√Ω h∆°n: ng·∫´u nhi√™n xa ng∆∞·ªùi ch∆°i v√† tr√°nh r√¨a
  if (lowestZombieCount === Infinity) {
    const angle = Math.random() * Math.PI * 2;
    const r = Math.min(worldWidth, worldHeight) * 0.35;
    const fx = player.x + Math.cos(angle) * r;
    const fy = player.y + Math.sin(angle) * r;
    return {
      x: Math.max(padding, Math.min(worldWidth  - padding, fx)),
      y: Math.max(padding, Math.min(worldHeight - padding, fy))
    };
  }

  return { x: bestX, y: bestY };
}

// H√†m t·∫°o m·ªôt c·ªïng m·ªõi
function createNewGate(x, y) {
    const safeX = Math.max(wallThickness + 60, Math.min(worldWidth - wallThickness - 60, x));
    const safeY = Math.max(wallThickness + 60, Math.min(worldHeight - wallThickness - 60, y));
    const initialRadius = 40; // B√°n k√≠nh ban ƒë·∫ßu
    spaceGate = {
        x: safeX,
        y: safeY,
        radius: initialRadius,
        originalRadius: initialRadius, // L∆∞u l·∫°i b√°n k√≠nh g·ªëc
        damage: 2,
        rotation: 0,
        alpha: 0 // V·∫´n gi·ªØ alpha ƒë·ªÉ c·ªïng m·ªõi hi·ªán ra m∆∞·ª£t m√†
    };
}

// H√†m k√≠ch ho·∫°t ch√≠nh
function activateSpaceGate(skill) {
  // N·∫øu ƒë√£ c√≥ c·ªïng r·ªìi th√¨ kh√¥ng t·∫°o n·ªØa
  if (spaceGateActive) return;

  spaceGateActive = true;
  spaceGateEndTime = Date.now() + skill.duration;

  // T·∫°o c·ªïng ngay tr∆∞·ªõc m·∫∑t ng∆∞·ªùi ch∆°i m·ªôt kho·∫£ng
  // X√°c ƒë·ªãnh h∆∞·ªõng d·ª±a tr√™n ph√≠m ƒëang nh·∫•n, ho·∫∑c ng·∫´u nhi√™n n·∫øu ƒë·ª©ng y√™n
  const angle = (keys.a || keys.d || keys.w || keys.s) 
                ? Math.atan2((keys.s ? 1 : 0) - (keys.w ? 1 : 0), (keys.d ? 1 : 0) - (keys.a ? 1 : 0))
                : (zombies.length > 0 ? Math.atan2(zombies[0].y - player.y, zombies[0].x - player.x) : 0);
  const distance = 150;

  createNewGate(player.x + Math.cos(angle) * distance, player.y + Math.sin(angle) * distance, skill.baseDamage);
}

// H√†m t·∫°o c·ªïng m·ªõi
function createNewGate(x, y, damage) {
    // Gi·ªõi h·∫°n v·ªã tr√≠ c·ªïng kh√¥ng b·ªã t·∫°o ra ngo√†i b·∫£n ƒë·ªì
    const safeX = Math.max(wallThickness + 60, Math.min(worldWidth - wallThickness - 60, x));
    const safeY = Math.max(wallThickness + 60, Math.min(worldHeight - wallThickness - 60, y));

    spaceGate = {
        x: safeX,
        y: safeY,
        radius: 50,       // B√°n k√≠nh hi·ªáu ·ª©ng c·ªßa c·ªïng
        damage: damage,   // S√°t th∆∞∆°ng c∆° b·∫£n
        rotation: 0,
        alpha: 0,         // ƒê·ªô m·ªù ban ƒë·∫ßu (ƒë·ªÉ l√†m hi·ªáu ·ª©ng hi·ªán ra)
        particles: []     // M·∫£ng ch·ª©a c√°c h·∫°t l·ª≠a trang tr√≠
    };
}
// üìå B·∫≠t/t·∫Øt b·∫£ng k·ªπ nƒÉng b·∫±ng ph√≠m X
document.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'x') {
    document.getElementById('skillsOverlay').classList.toggle('hidden');
    updateSkillsList();
  }
});

// Th√™m k·ªπ nƒÉng m·ªõi (g·ªçi h√†m n√†y khi l√™n c·∫•p)
function learnSkill(index) {
  const skill = skillsData[index];
if (!activeSkills.includes(skill)) {
  activeSkills.push(skill);
  /* S·ª¨A kh·ªëi g√°n level */
  skill.level = 1;              // ‚Üê lu√¥n b·∫Øt ƒë·∫ßu ·ªü c·∫•p 1
if (skill.baseDamage !== undefined && skill.level === undefined) {
  skill.level = 0;
}
  updateSkillsList();
  showWarning(`üéâ H·ªçc k·ªπ nƒÉng: ${skill.icon} ${skill.name}`);
}
}

// üéØ Ph√≠m Z ƒë·ªÉ b·∫≠t/t·∫Øt b·∫£ng th·ªëng k√™
document.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "z") {
    const panel = document.getElementById("statsOverlay");
    panel.classList.toggle("hidden");
}
});

// üéØ G√°n ph√≠m ` ƒë·ªÉ b·∫≠t/t·∫Øt FPS
document.addEventListener("keydown", (e) => {
  if (e.key === "`") {
    const fpsDiv = document.getElementById("fpsCounter");
    fpsDiv.style.display = fpsDiv.style.display === "none" ? "block" : "none";
}
});
function showGuide() {
  playSound('sfx-ui-click', 0.2);
  document.getElementById("guideOverlay").style.display = "block";
}
function hideGuide() {
  playSound('sfx-ui-click', 0.2);
  document.getElementById("guideOverlay").style.display = "none";
}
function showInfo() {
  playSound('sfx-ui-click', 0.2);
  document.getElementById("infoOverlay").style.display = "block";
}
function hideInfo() {
  playSound('sfx-ui-click', 0.2);
  document.getElementById("infoOverlay").style.display = "none";
}

// --- LOGIC CHO DEBUG MENU ---

// H√†m m·ªü/ƒë√≥ng menu
function toggleDebugMenu() {
    const debugMenu = document.getElementById('debugMenu');
    if (!debugMenu) return;

    const isHidden = debugMenu.classList.toggle('hidden');
    isPaused = !isHidden;

    if (!isHidden) {
        populateDebugMenu();
    }
}

// H√ÄM C·∫¨P NH·∫¨T: ƒêi·ªÅn gi√° tr·ªã v√†o menu
function populateDebugMenu() {
    const setSliderValue = (id, value) => {
        const slider = document.getElementById(id);
        if (slider) {
            slider.value = value;
            const valueSpan = slider.nextElementSibling;
            if (valueSpan) {
                if (slider.step.includes('.')) {
                    valueSpan.textContent = parseFloat(value).toFixed(1);
                } else {
                    valueSpan.textContent = value;
                }
            }
        }
    };

    // Ch·ªâ s·ªë c∆° b·∫£n & game
    document.getElementById('debug-exp').value = player.currentLevelExp;
    setSliderValue('debug-wave', wave);
    setSliderValue('debug-dayTime', (dayTime * 24).toFixed(1));
    setSliderValue('debug-level', player.level);
    setSliderValue('debug-hp', player.hearts);
    setSliderValue('debug-mana', player.mana);
    setSliderValue('debug-energy', player.energy);
    setSliderValue('debug-moveSpeed', player.speed);
    setSliderValue('debug-damage', playerUpgrades.damageBoost);
    setSliderValue('debug-iceArrow', playerUpgrades.iceArrow);
    setSliderValue('debug-bulletSpeed', playerUpgrades.bulletSpeed);
    setSliderValue('debug-lineCount', playerUpgrades.lineBulletCount);
    setSliderValue('debug-coin', player.coins);
    
    // Ch·ªâ s·ªë k·ªπ nƒÉng passive
    setSliderValue('debug-bladeCount', skillUpgrades.bladeCount);
    setSliderValue('debug-bladeDamage', skillUpgrades.bladeDamage);
    setSliderValue('debug-swordLevel', skillUpgrades.swordLevel);
    setSliderValue('debug-swordDamage', skillUpgrades.swordDamage);
    setSliderValue('debug-fireCount', skillUpgrades.fireCount);
    setSliderValue('debug-fireDamage', skillUpgrades.fireDamage);
    setSliderValue('debug-iceCount', skillUpgrades.iceCount);
    setSliderValue('debug-iceDamage', skillUpgrades.iceDamage);
    setSliderValue('debug-thunderCount', skillUpgrades.thunderCount);
    setSliderValue('debug-thunderDamage', skillUpgrades.thunderDamage);
    setSliderValue('debug-auraHealLevel', skillUpgrades.auraHealLevel);
    setSliderValue('debug-fairyCount', skillUpgrades.fairyCount);
    setSliderValue('debug-fairyHealLevel', skillUpgrades.fairyHealLevel);
    setSliderValue('debug-fairyDamageLevel', skillUpgrades.fairyDamageLevel);

    // C·∫≠p nh·∫≠t gi√° tr·ªã cho c√°c thanh tr∆∞·ª£t k·ªπ nƒÉng active
    skillsData.forEach(skill => {
        const learnedSkill = activeSkills.find(s => s.name === skill.name);
        const currentData = learnedSkill || skill;
        const safeIdName = skill.name.replace(/\s/g, '-');

        if (document.getElementById(`debug-level-${safeIdName}`)) {
            setSliderValue(`debug-level-${safeIdName}`, currentData.level || 1);
        }
        if (document.getElementById(`debug-damage-${safeIdName}`)) {
            setSliderValue(`debug-damage-${safeIdName}`, currentData.baseDamage);
        }
    });
}

// Debug gi√° tr·ªã t·ª´ menu v√†o game
function applyDebugChanges() {
  // ƒë·ªçc gi√° tr·ªã t·ª´ UI
  const lvl   = parseInt(document.getElementById('debug-level').value) || 1;
  const expUI = parseInt(document.getElementById('debug-exp').value)   || 0;

  // 1) c·∫≠p nh·∫≠t level tr∆∞·ªõc, r·ªìi t√≠nh l·∫°i requiredExp
  player.level = lvl;
  player.requiredExp = calculateRequiredExp(player.level); // d√πng ƒë√∫ng h√†m hi·ªán c√≥„Äêturn6file9‚Ä†index.html‚Ä†L34-L47„Äë

  // 2) ƒë·ªìng b·ªô EXP: t·ªïng & EXP c·ªßa c·∫•p hi·ªán t·∫°i
  player.currentLevelExp = expUI;
  player.exp = expUI;
    // Ch·ªâ s·ªë c∆° b·∫£n & game
    player.exp = parseInt(document.getElementById('debug-exp').value);
    wave = parseInt(document.getElementById('debug-wave').value);
    dayTime = parseFloat(document.getElementById('debug-dayTime').value) / 24;
    updateWaveUI();
    player.level = parseInt(document.getElementById('debug-level').value);
    player.requiredExp = calculateRequiredExp(player.level);
    player.hearts = parseInt(document.getElementById('debug-hp').value);
    player.mana = parseInt(document.getElementById('debug-mana').value);
    player.energy = parseInt(document.getElementById('debug-energy').value);
    player.speed = parseFloat(document.getElementById('debug-moveSpeed').value);
    playerUpgrades.damageBoost = parseFloat(document.getElementById('debug-damage').value);
    playerUpgrades.iceArrow = parseInt(document.getElementById('debug-iceArrow').value);
    playerUpgrades.bulletSpeed = parseFloat(document.getElementById('debug-bulletSpeed').value);
    playerUpgrades.lineBulletCount = parseInt(document.getElementById('debug-lineCount').value);
    player.coins = parseInt(document.getElementById('debug-coin').value);

    // Ch·ªâ s·ªë k·ªπ nƒÉng passive
    skillUpgrades.bladeCount = parseInt(document.getElementById('debug-bladeCount').value);
    skillUpgrades.bladeDamage = parseFloat(document.getElementById('debug-bladeDamage').value);
    skillUpgrades.swordLevel = parseInt(document.getElementById('debug-swordLevel').value);
    skillUpgrades.swordDamage = parseFloat(document.getElementById('debug-swordDamage').value);
    skillUpgrades.fireCount = parseInt(document.getElementById('debug-fireCount').value);
    skillUpgrades.fireDamage = parseFloat(document.getElementById('debug-fireDamage').value);
    skillUpgrades.iceCount = parseInt(document.getElementById('debug-iceCount').value);
    skillUpgrades.iceDamage = parseFloat(document.getElementById('debug-iceDamage').value);
    skillUpgrades.thunderCount = parseInt(document.getElementById('debug-thunderCount').value);
    skillUpgrades.thunderDamage = parseFloat(document.getElementById('debug-thunderDamage').value);
    skillUpgrades.auraHealLevel = parseInt(document.getElementById('debug-auraHealLevel').value);
    skillUpgrades.fairyCount = parseInt(document.getElementById('debug-fairyCount').value);
    skillUpgrades.fairyHealLevel = parseInt(document.getElementById('debug-fairyHealLevel').value);
    skillUpgrades.fairyDamageLevel = parseInt(document.getElementById('debug-fairyDamageLevel').value);
    
    // --- B·∫ÆT ƒê·∫¶U S·ª¨A L·ªñI LOGIC K·ª∏ NƒÇNG ACTIVE ---
    skillsData.forEach(skill => {
        const safeIdName = skill.name.replace(/\s/g, '-');
        const levelSlider = document.getElementById(`debug-level-${safeIdName}`);
        const damageSlider = document.getElementById(`debug-damage-${safeIdName}`);
        let hasChanges = false;

        const learnedSkill = activeSkills.find(s => s.name === skill.name);
        const currentData = learnedSkill || skill;

        if (levelSlider) {
            const newLevel = parseInt(levelSlider.value);
            if (newLevel !== (currentData.level || 1)) {
                skill.level = newLevel;
                hasChanges = true;
            }
        }
        
        if (damageSlider) {
            const newDamage = parseFloat(damageSlider.value);
            if (newDamage !== currentData.baseDamage) {
                skill.baseDamage = newDamage;
                hasChanges = true;
            }
        }
        
        // N·∫øu c√≥ thay ƒë·ªïi v√† k·ªπ nƒÉng ch∆∞a ƒë∆∞·ª£c h·ªçc -> t·ª± ƒë·ªông h·ªçc
        if (hasChanges && !activeSkills.includes(skill)) {
            // ƒê·∫£m b·∫£o g√°n level 1 khi h·ªçc l·∫ßn ƒë·∫ßu
            if (skill.level === undefined) {
                skill.level = 1;
            }
            activeSkills.push(skill);
        }
    });
    // --- K·∫æT TH√öC S·ª¨A L·ªñI ---

    updateUI();
    updateStatsOverlay();
    sysPickupItemsAndLevel(Date.now());
    // G·ªçi updateSkillsList() ·ªü cu·ªëi ƒë·ªÉ l√†m m·ªõi giao di·ªán k·ªπ nƒÉng v√† tooltip
    updateSkillsList(); 
    showWarning('üîß C√°c ch·ªâ s·ªë ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t!');
}

// ƒê·ª£i cho ƒë·∫øn khi to√†n b·ªô t√†i li·ªáu HTML ƒë∆∞·ª£c t·∫£i xong r·ªìi m·ªõi ch·∫°y m√£ b√™n trong
document.addEventListener('DOMContentLoaded', function () {
  // Hi·ªÉn th·ªã n√∫t "Ti·∫øp t·ª•c" n·∫øu c√≥ d·ªØ li·ªáu l∆∞u
      if (localStorage.getItem(SAVE_KEY)) {
        document.getElementById('continueBtn').style.display = 'block';
    }

    const loadingOverlay = document.getElementById('loadingOverlay');
    const loadingText = document.getElementById('loadingText');
    const startMenu = document.getElementById('startMenu');
        // l·∫•y ph·∫ßn t·ª≠ thanh loading
    const loadingBar = document.querySelector('.loading-bar');

/*
    loadingOverlay.style.display = 'none'; // ·∫®n m√†n h√¨nh loading ƒëi
    startMenu.style.display = 'flex';     // Hi·ªán menu ch√≠nh l√™n ngay l·∫≠p t·ª©c
*/
    // 1. ·∫®n menu ch√≠nh ƒëi ngay t·ª´ ƒë·∫ßu
    startMenu.style.display = 'none';

    // 2. B·∫Øt ƒë·∫ßu qu√° tr√¨nh t·∫£i audio
    initAudioPool(
        5,
        (loaded, total) => {
            loadingText.innerText = `ƒêang t·∫£i t√†i nguy√™n... (${loaded}/${total})`;
    // T√≠nh to√°n v√† c·∫≠p nh·∫≠t ƒë·ªô r·ªông c·ªßa thanh loading
            const progress = (loaded / total) * 100;
            loadingBar.style.width = `${progress}%`;
        },
        // 3. C·∫¨P NH·∫¨T LOGIC KHI T·∫¢I XONG
        () => {
            console.log("Audio resources fully loaded and ready.");
            loadingText.innerText = 'S·∫µn s√†ng!';
            // Gi·ªØ m√†n h√¨nh "S·∫µn s√†ng!" th√™m 1 gi√¢y ƒë·ªÉ audio th·ª±c s·ª± ƒë∆∞·ª£c gi·∫£i m√£
            setTimeout(() => {
                // B·∫Øt ƒë·∫ßu qu√° tr√¨nh chuy·ªÉn ƒë·ªïi
                loadingOverlay.classList.add('hidden'); // B·∫Øt ƒë·∫ßu l√†m m·ªù m√†n h√¨nh loading
                startMenu.style.display = 'flex';     // Hi·ªán menu ch√≠nh l√™n
                // Sau khi hi·ªáu ·ª©ng m·ªù k·∫øt th√∫c, ·∫©n h·∫≥n loading overlay ƒëi
                // ƒë·ªÉ kh√¥ng ch·∫∑n click chu·ªôt v√†o menu
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                }, 500); // Th·ªùi gian n√†y ph·∫£i kh·ªõp v·ªõi transition trong CSS
            }, 1000); // <-- Ch·ªù 1 gi√¢y (1000ms)
        }
    );
    // G√°n s·ª± ki·ªán nh·∫•n ph√≠m '/' v√† 'o'
    document.addEventListener('keydown', (e) => {
        switch (e.key) {
            case '/':
                e.preventDefault();
                if (debugKeyTimer === null) {
                    debugKeyTimer = setTimeout(() => {
                        toggleDebugMenu();
                        debugKeyTimer = null;
                    }, 500); // ƒê·ª£i 0.5 gi√¢y tr∆∞·ªõc khi m·ªü menu
                }
                break;

            case 'o':
                if (gameStarted && !gameOver) {
                    toggleShop();
                }
                break;
        }
    });

    // B·∫Øt s·ª± ki·ªán khi ng∆∞·ªùi d√πng TH·∫¢ ph√≠m `/` RA
    document.addEventListener('keyup', (e) => {
        if (e.key === '/') {
            if (debugKeyTimer) {
                clearTimeout(debugKeyTimer);
                debugKeyTimer = null;
            }
        }
    });

    // G√°n s·ª± ki·ªán cho c√°c n√∫t b·∫•m "√Åp d·ª•ng" v√† "ƒê√≥ng"
    const applyBtn = document.getElementById('applyDebugChanges');
    if (applyBtn) {
        applyBtn.onclick = applyDebugChanges;
    }

    const closeBtn = document.getElementById('closeDebugMenu');
    if (closeBtn) {
        closeBtn.onclick = toggleDebugMenu;
    }

    // G√°n s·ª± ki·ªán 'input' cho t·∫•t c·∫£ thanh k√©o ƒë·ªÉ c·∫≠p nh·∫≠t s·ªë hi·ªÉn th·ªã khi ng∆∞·ªùi d√πng k√©o
    const sliders = document.querySelectorAll('#debugMenu input[type="range"]');
    sliders.forEach(slider => {
        const valueSpan = slider.nextElementSibling;
        if (valueSpan) {
            slider.addEventListener('input', () => {
                if (slider.step.includes('.')) {
                    valueSpan.textContent = parseFloat(slider.value).toFixed(1);
                } else {
                    valueSpan.textContent = slider.value;
                }
            });
        }
    });

    // T·ª± ƒë·ªông ph√°t b√†i h√°t ng·∫´u nhi√™n kh√°c khi m·ªôt b√†i h√°t b√¨nh th∆∞·ªùng k·∫øt th√∫c
    normalMusicTracks.forEach(id => {
        const track = document.getElementById(id);
        if (track) {
            track.addEventListener('ended', function () {
                if (currentMusicState === 'normal') {
                    playRandomNormalMusic();
                }
            });
        }
    });
    // G√°n s·ª± ki·ªán n√∫t ƒë√≥ng Shop
    const closeShopBtn = document.getElementById('closeShopBtn');
    if (closeShopBtn) {
        closeShopBtn.onclick = toggleShop;
    }
    // B·∫Øt s·ª± ki·ªán ph√≠m ESC
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (gameStarted && !gameOver) {
                togglePauseMenu();
            }
        }
    });

    // G√°n s·ª± ki·ªán cho c√°c n√∫t trong Pause Menu
    document.getElementById('resumeBtn').onclick = togglePauseMenu;
    document.getElementById('restartBtnPause').onclick = resetGame;
    document.getElementById('guideBtnPause').onclick = showGuide;
    document.getElementById('infoBtnPause').onclick = showInfo;
    document.getElementById('exitBtn').onclick = () => location.reload();

    // G√°n s·ª± ki·ªán cho c√°c thanh tr∆∞·ª£t √¢m l∆∞·ª£ng
    const masterSlider = document.getElementById('volume-master');
    const musicSlider = document.getElementById('volume-music');
    const sfxSlider = document.getElementById('volume-sfx');

    if (masterSlider) {
        masterSlider.addEventListener('input', () => {
            masterVolume = parseFloat(masterSlider.value);
            masterSlider.nextElementSibling.textContent = `${Math.round(masterVolume*100)}%`;
            updateAllMusicVolume();
        });
    }
    if (musicSlider) {
        musicSlider.addEventListener('input', () => {
            musicVolume = parseFloat(musicSlider.value);
            musicSlider.nextElementSibling.textContent = `${Math.round(musicVolume*100)}%`;
            updateAllMusicVolume();
        });
    }
    if (sfxSlider) {
        sfxSlider.addEventListener('input', () => {
            sfxVolume = parseFloat(sfxSlider.value);
            sfxSlider.nextElementSibling.textContent = `${Math.round(sfxVolume*100)}%`;
        });
    }
        // KH·ªûI T·∫†O B·∫¢N TIN CH·∫†Y CH·ªÆ - TH√äM V√ÄO ƒê√ÇY
    if (typeof NewsTicker !== 'undefined' && NewsTicker.init) {
        NewsTicker.init();
    }
});
// --- LOGIC CHO PAUSE MENU ---
function togglePauseMenu() {
    const menu = document.getElementById('pauseMenu');
    if (!menu) return; // Th√™m ki·ªÉm tra ƒë·ªÉ tr√°nh l·ªói
    const isHidden = menu.classList.toggle('hidden');
    isPaused = !isHidden;
    // Khi m·ªü menu, c·∫≠p nh·∫≠t gi√° tr·ªã c√°c thanh tr∆∞·ª£t v·ªÅ gi√° tr·ªã hi·ªán t·∫°i
    if (!isHidden) {
        document.getElementById('volume-master').value = masterVolume;
        document.getElementById('volume-music').value = musicVolume;
        document.getElementById('volume-sfx').value = sfxVolume;
        // C·∫≠p nh·∫≠t text hi·ªÉn th·ªã %
        document.querySelector('#volume-master + .range-value').textContent = `${Math.round(masterVolume*100)}%`;
        document.querySelector('#volume-music + .range-value').textContent = `${Math.round(musicVolume*100)}%`;
        document.querySelector('#volume-sfx + .range-value').textContent = `${Math.round(sfxVolume*100)}%`;
    }
}
// T·ª± ƒë·ªông l∆∞u game khi ng∆∞·ªùi ch∆°i ƒë√≥ng tab/tr√¨nh duy·ªát
window.onbeforeunload = saveGame;
</script>
<!-- üåü Popup khi l√™n c·∫•p -->
<div id="levelUpPopup">Level Up!</div>
<!-- üåü Popup ch·ªçn n√¢ng c·∫•p -->
<div id="upgradePopup">
  <h3 class="upgradeTitle">‚è´ Ch·ªçn n√¢ng c·∫•p</h3>
  <div id="upgradeChoices" class="upgradeChoices"></div>
</div>

<!-- üìä Overlay hi·ªÉn th·ªã th·ªëng s·ªë k·ªπ nƒÉng -->
<div id="statsOverlay" class="hidden">
  <h3>üìä Th·ªëng k√™</h3>
  <div id="highScoreDisplay" style="text-align: center; font-weight: 300; margin: 2px 0; position: relative; top: -6px;">
  üèÜ K·ª∑ l·ª•c: 0
  </div>
  <div id="stat-moveSpeed">üëü T·ªëc ƒë·ªô ch·∫°y: - </div>
  <div id="stat-damage">üí• Dmg: - </div>
  <div id="stat-iceArrow">üèπ Ice Arrow: - </div>
  <div id="stat-speed">üí® T·ªëc ƒë·ªô: - </div>
  <div id="stat-lineCount">üß® S·ªë l∆∞·ª£ng ƒë·∫°n: - </div>
  <div id="stat-blade">üî™ ƒêao: -</div>
  <div id="stat-sword">‚öîÔ∏è Ki·∫øm: -</div>
  <div id="stat-fire">üî• L·ª≠a: -</div>
  <div id="stat-ice">‚ùÑÔ∏è BƒÉng: -</div>
  <div id="stat-thunder">üîµ L√¥i: -</div>
  <div id="stat-skills"></div> <!-- k·ªπ nƒÉng kh√°c -->
  <div id="stat-spawned">üßü T·ªïng s·ªë zombie: 0</div>
  <div id="stat-alive">üßü ƒêang c√≤n s·ªëng: 0</div>
  <div id="stat-total">üßü ƒê√£ ti√™u di·ªát: 0</div>
  <div id="stat-breakdown">
    <!-- s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t b·∫±ng JS -->
  </div>
</div>
<!-- üìö B·∫£ng K·ªπ NƒÉng Active m·ªü b·∫±ng ph√≠m X -->
<div id="skillsOverlay" class="hidden">
<h3>üìö K·ªπ nƒÉng Active</h3>
<div id="ui-mana" style="text-align: center; font-weight: 300; margin: -6px 0; position: relative; top: -6px;">üí† Mana: 0</div>
<div id="ui-stamina" style="text-align: center; font-weight: 300; margin: -6px 0; position: relative; top: -6px;">üîπ Stamina: 0</div>
<div id="skills-list"></div>
</div>

<!-- üéØ Hi·ªÉn th·ªã FPS realtime -->
<div id="fpsCounter" style="
  display: none;
  position: fixed;
  top: 0.2rem;
  left: 0.3rem;
  color: lime;
  background: rgba(0, 0, 0, 0);
  padding: 0.4rem 0.8rem;
  border-radius: 0.5rem;
  font-family: monospace;
  font-size: 0.9rem;
  z-index: 9999;
  pointer-events: none;
">
FPS: --
</div>
<!-- üéì Popup k·ªπ nƒÉng khi l√™n c·∫•p -->
<div id="skillPopup">
  <h3>üéì Ch·ªçn k·ªπ nƒÉng ho·∫∑c n√¢ng c·∫•p</h3>
  <div class="upgradeChoices" id="skillChoices"></div>
</div>
<div id="notificationContainer" aria-live="polite"></div>

<!-- B·∫£ng menu g·ª° l·ªói (Debug Menu) -->
<div id="debugMenu" class="infoOverlay hidden">
  <h3>üîß Debug Menu </h3>
  <div class="debug-grid">
    
    <label for="debug-level">üßë‚Äçü¶∞ Level:</label>
    <div class="range-container">
      <input type="range" id="debug-level" min="1" max="100" step="1">
      <span class="range-value">1</span>
    </div>
    <label for="debug-hp">‚ù§Ô∏è HP:</label>
    <div class="range-container">
      <input type="range" id="debug-hp" min="1" max="1000" step="1">
      <span class="range-value">10</span>
    </div>
    <label for="debug-mana">üí† Mana:</label>
    <div class="range-container">
      <input type="range" id="debug-mana" min="0" max="1000" step="1">
      <span class="range-value">10</span>
    </div>
    <label for="debug-energy">‚ö° Energy:</label>
    <div class="range-container">
      <input type="range" id="debug-energy" min="0" max="1000" step="1">
      <span class="range-value">10</span>
    </div>
    <label for="debug-coin">ü™ô Coin:</label>
    <div class="range-container">
      <input type="range" id="debug-coin" min="0" max="1000" step="1">
      <span class="range-value">10</span>
    </div>
    <label for="debug-moveSpeed">üëü Speed:</label>
    <div class="range-container">
      <input type="range" id="debug-moveSpeed" min="0.5" max="5" step="0.1">
      <span class="range-value">1.0</span>
    </div>
    <label for="debug-damage">üí• S√°t th∆∞∆°ng:</label>
    <div class="range-container">
      <input type="range" id="debug-damage" min="1" max="100" step="0.5">
      <span class="range-value">1.0</span>
    </div>
    <label for="debug-iceArrow">üèπ Ice Arrow:</label>
    <div class="range-container">
      <input type="range" id="debug-iceArrow" min="1" max="21" step="1">
      <span class="range-value">1</span>
    </div>
    <label for="debug-bulletSpeed">üí® T·ªëc ƒë·ªô ƒë·∫°n:</label>
    <div class="range-container">
      <input type="range" id="debug-bulletSpeed" min="0.5" max="10" step="0.1">
      <span class="range-value">1.0</span>
    </div>
    <label for="debug-lineCount">üß® S·ªë l∆∞·ª£ng ƒë·∫°n:</label>
    <div class="range-container">
      <input type="range" id="debug-lineCount" min="1" max="10" step="1">
      <span class="range-value">1</span>
    </div>
    <h4 class="debug-subtitle" colspan="2">Tr·∫°ng th√°i Game</h4>

    <label for="debug-exp">Exp:</label>
    <input type="number" id="debug-exp" class="custom-input" min="0" max="999999">

    <label for="debug-wave">Wave:</label>
    <div class="range-container">
      <input type="range" id="debug-wave" min="1" max="100" step="1">
      <span class="range-value">1</span>
    </div>

    <label for="debug-dayTime">Gi·ªù trong ng√†y:</label>
    <div class="range-container">
      <input type="range" id="debug-dayTime" min="0" max="23.5" step="0.5">
      <span class="range-value">6.0</span>
    </div>

    <h4 class="debug-subtitle" colspan="2">K·ªπ nƒÉng Active</h4>
    <div id="debug-active-skills-container" class="debug-skill-grid">
        
        <div class="debug-skill-wrapper">
            <h5>üõ∞Ô∏è V·ªá tinh laze</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-V·ªá-tinh-laze">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-V·ªá-tinh-laze" min="1" max="2" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-V·ªá-tinh-laze">S√°t th∆∞∆°ng:</label>
                <div class="range-container"><input type="range" id="debug-damage-V·ªá-tinh-laze" min="0" max="100" step="1" value="3"><span class="range-value">3</span></div>
            </div>
        </div>

        <div class="debug-skill-wrapper">
            <h5>üöÄ T√™n l·ª≠a F18</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-T√™n-l·ª≠a-F18">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-T√™n-l·ª≠a-F18" min="1" max="5" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-T√™n-l·ª≠a-F18">S√°t th∆∞∆°ng:</label>
                <div class="range-container"><input type="range" id="debug-damage-T√™n-l·ª≠a-F18" min="0" max="100" step="1" value="6"><span class="range-value">6</span></div>
            </div>
        </div>

        <div class="debug-skill-wrapper">
            <h5>üõ∏ UFO t·∫•n c√¥ng</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-UFO-t·∫•n-c√¥ng">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-UFO-t·∫•n-c√¥ng" min="1" max="3" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-UFO-t·∫•n-c√¥ng">S√°t th∆∞∆°ng:</label>
                <div class="range-container"><input type="range" id="debug-damage-UFO-t·∫•n-c√¥ng" min="0" max="100" step="1" value="5"><span class="range-value">5</span></div>
            </div>
        </div>
        
        <div class="debug-skill-wrapper">
            <h5>üå©Ô∏è B√£o s√©t</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-B√£o-s√©t">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-B√£o-s√©t" min="1" max="5" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-B√£o-s√©t">S√°t th∆∞∆°ng:</label>
                <div class="range-container"><input type="range" id="debug-damage-B√£o-s√©t" min="0" max="100" step="1" value="8"><span class="range-value">8</span></div>
            </div>
        </div>
        
        <div class="debug-skill-wrapper">
            <h5>üí£ Bom B52</h5>
            <div class="debug-skill-controls">
                <label for="debug-damage-Bom-B52">S√°t th∆∞∆°ng:</label>
                <div class="range-container"><input type="range" id="debug-damage-Bom-B52" min="0" max="100" step="1" value="10"><span class="range-value">10</span></div>
            </div>
        </div>

        <div class="debug-skill-wrapper">
            <h5>üé≠ ·∫¢o ·∫£nh ph√¢n th√¢n</h5>
            <div class="debug-skill-controls">
                <label for="debug-damage-·∫¢o-·∫£nh-ph√¢n-th√¢n">S√°t th∆∞∆°ng:</label>
                <div class="range-container"><input type="range" id="debug-damage-·∫¢o-·∫£nh-ph√¢n-th√¢n" min="0" max="100" step="1" value="5"><span class="range-value">5</span></div>
            </div>
        </div>

        <div class="debug-skill-wrapper">
            <h5>üï≥Ô∏è H·ªë ƒëen</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-H·ªë-ƒëen">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-H·ªë-ƒëen" min="1" max="2" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-H·ªë-ƒëen">S√°t th∆∞∆°ng:</label>
                <div class="range-container"><input type="range" id="debug-damage-H·ªë-ƒëen" min="0" max="100" step="1" value="7"><span class="range-value">7</span></div>
            </div>
        </div>

        <div class="debug-skill-wrapper">
            <h5>‚ò¢Ô∏è Boom h·∫°t nh√¢n</h5>
            <div class="debug-skill-controls">
                <label for="debug-damage-Boom-h·∫°t-nh√¢n">S√°t th∆∞∆°ng:</label>
                <div class="range-container"><input type="range" id="debug-damage-Boom-h·∫°t-nh√¢n" min="0" max="200" step="5" value="100"><span class="range-value">100</span></div>
            </div>
        </div>
        
        <div class="debug-skill-wrapper">
            <h5>ü©∏ Qu·∫£ c·∫ßu h·∫•p huy·∫øt</h5>
            <div class="debug-skill-controls">
                <label for="debug-level-Qu·∫£-c·∫ßu-h·∫•p-huy·∫øt">Level:</label>
                <div class="range-container"><input type="range" id="debug-level-Qu·∫£-c·∫ßu-h·∫•p-huy·∫øt" min="1" max="2" step="1" value="1"><span class="range-value">1</span></div>
                <label for="debug-damage-Qu·∫£-c·∫ßu-h·∫•p-huy·∫øt">S√°t th∆∞∆°ng:</label>
                <div class="range-container"><input type="range" id="debug-damage-Qu·∫£-c·∫ßu-h·∫•p-huy·∫øt" min="0" max="100" step="1" value="2"><span class="range-value">2</span></div>
            </div>
        </div>
        
        <div class="debug-skill-wrapper">
            <h5>üåÄ C·ªïng Kh√¥ng Gian</h5>
            <div class="debug-skill-controls">
                <label for="debug-damage-C·ªïng-Kh√¥ng-Gian">S√°t th∆∞∆°ng:</label>
                <div class="range-container"><input type="range" id="debug-damage-C·ªïng-Kh√¥ng-Gian" min="0" max="100" step="1" value="99"><span class="range-value">99</span></div>
            </div>
        </div>
    </div>

    <h4 class="debug-subtitle" colspan="2">N√¢ng c·∫•p K·ªπ nƒÉng</h4>

    <label for="debug-bladeCount">üî™ S·ªë l∆∞·ª£ng ƒëao:</label>
    <div class="range-container">
        <input type="range" id="debug-bladeCount" min="2" max="20" step="1">
        <span class="range-value">2</span>
    </div>
    <label for="debug-bladeDamage">üî™ Dmg ƒëao:</label>
    <div class="range-container">
        <input type="range" id="debug-bladeDamage" min="1" max="50" step="0.5">
        <span class="range-value">1.0</span>
    </div>
    <label for="debug-swordLevel">‚öîÔ∏è C·∫•p m∆∞a ki·∫øm:</label>
    <div class="range-container">
        <input type="range" id="debug-swordLevel" min="1" max="10" step="1">
        <span class="range-value">1</span>
    </div>
    <label for="debug-swordDamage">‚öîÔ∏è Dmg ki·∫øm:</label>
    <div class="range-container">
        <input type="range" id="debug-swordDamage" min="1" max="50" step="0.5">
        <span class="range-value">1.0</span>
    </div>
    <label for="debug-fireCount">üî• S·ªë l∆∞·ª£ng l·ª≠a:</label>
    <div class="range-container">
        <input type="range" id="debug-fireCount" min="2" max="10" step="1">
        <span class="range-value">2</span>
    </div>
    <label for="debug-fireDamage">üî• Dmg l·ª≠a:</label>
    <div class="range-container">
        <input type="range" id="debug-fireDamage" min="1" max="50" step="0.5">
        <span class="range-value">1.0</span>
    </div>
    <label for="debug-iceCount">‚ùÑÔ∏è S·ªë l∆∞·ª£ng bƒÉng:</label>
    <div class="range-container">
        <input type="range" id="debug-iceCount" min="2" max="10" step="1">
        <span class="range-value">2</span>
    </div>
    <label for="debug-iceDamage">‚ùÑÔ∏è Dmg bƒÉng:</label>
    <div class="range-container">
        <input type="range" id="debug-iceDamage" min="1" max="50" step="0.5">
        <span class="range-value">1.0</span>
    </div>
    <label for="debug-thunderCount">üîµ S·ªë l∆∞·ª£ng l√¥i:</label>
    <div class="range-container">
        <input type="range" id="debug-thunderCount" min="2" max="6" step="1">
        <span class="range-value">2</span>
    </div>
    <label for="debug-thunderDamage">üîµ Dmg l√¥i:</label>
    <div class="range-container">
        <input type="range" id="debug-thunderDamage" min="1" max="50" step="0.5">
        <span class="range-value">1.0</span>
    </div>
<label for="debug-auraHealLevel">‚ú® C·∫•p Heal Aura:</label>
    <div class="range-container">
        <input type="range" id="debug-auraHealLevel" min="0" max="5" step="1">
        <span class="range-value">0</span>
    </div>

    <label for="debug-fairyCount">ü¶ã S·ªë l∆∞·ª£ng Fairy:</label>
    <div class="range-container">
        <input type="range" id="debug-fairyCount" min="1" max="3" step="1">
        <span class="range-value">1</span>
    </div>

    <label for="debug-fairyHealLevel">ü¶ã C·∫•p Heal Fairy:</label>
    <div class="range-container">
        <input type="range" id="debug-fairyHealLevel" min="0" max="10" step="1">
        <span class="range-value">0</span>
    </div>
    
    <label for="debug-fairyDamageLevel">ü¶ã C·∫•p Dmg Fairy:</label>
    <div class="range-container">
        <input type="range" id="debug-fairyDamageLevel" min="0" max="10" step="1">
        <span class="range-value">0</span>
    </div>

  </div>
  <div class="debug-buttons">
    <button id="applyDebugChanges">√Åp d·ª•ng</button>
    <button id="closeDebugMenu">ƒê√≥ng</button>
  </div>
</div>

<!--Menu game ESC-->
<div id="pauseMenu" class="infoOverlay hidden">
  <h2>C√†i ƒë·∫∑t</h2>
  
  <div class="settings-section">
    <h3>√Çm thanh</h3>
    <div class="debug-grid">
      <label for="volume-master">√Çm l∆∞·ª£ng T·ªïng:</label>
      <div class="range-container">
        <input type="range" id="volume-master" min="0" max="1" step="0.05" value="1">
        <span class="range-value">100%</span>
      </div>
      
      <label for="volume-music">Nh·∫°c n·ªÅn:</label>
      <div class="range-container">
        <input type="range" id="volume-music" min="0" max="1" step="0.05" value="0.5">
        <span class="range-value">50%</span>
      </div>

      <label for="volume-sfx">Hi·ªáu ·ª©ng (SFX):</label>
      <div class="range-container">
        <input type="range" id="volume-sfx" min="0" max="1" step="0.05" value="0.8">
        <span class="range-value">80%</span>
      </div>
    </div>
  </div>

  <div class="pause-menu-buttons">
    <button id="resumeBtn">Ti·∫øp t·ª•c</button>
    <button id="restartBtnPause">Ch∆°i l·∫°i</button>
    <button id="guideBtnPause">H∆∞·ªõng d·∫´n</button>
    <button id="infoBtnPause">Th√¥ng tin</button>
    <button id="exitBtn">Menu</button>
  </div>
</div>
<!-- ‚ÑπÔ∏è Overlay Shop -->
<div id="shopOverlay" class="infoOverlay hidden">
  <h2><i class="fas fa-store"></i> C·ª≠a h√†ng Zombie Survivor </h2>
  <div class="shop-balance">Xu: <span id="shopCoinBalance">0</span> ü™ô</div>
  
  <div id="shopItemsContainer" class="shop-grid">
    </div>

  <div class="shop-buttons">
    <button id="closeShopBtn">ƒê√≥ng</button>
  </div>
</div>
<!-- Hi·ªÉn th·ªã ƒë·∫°n -->
<div id="ammoDisplay"></div>
<!-- üéµ √Çm thanh n·ªÅn v√† hi·ªáu ·ª©ng √¢m thanh -->
<audio id="music-background" src="sounds/background-music.mp3"></audio>
<audio id="music-background-2" src="sounds/background-music-2.mp3"></audio>
<audio id="music-background-3" src="sounds/background-music-3.mp3"></audio>
<audio id="music-boss" src="sounds/boss-music.mp3" loop></audio>

<audio id="sfx-shoot" src="sounds/shoot.mp3"></audio>
<audio id="sfx-zombie-die" src="sounds/zombie-die.mp3"></audio>
<audio id="sfx-pickup" src="sounds/pickup.mp3"></audio>
<audio id="sfx-pickup-coin" src="sounds/pickup-coin.mp3"></audio>
<audio id="sfx-level-up" src="sounds/level-up.mp3"></audio>
<audio id="sfx-laser" src="sounds/laser.mp3"></audio>
<audio id="sfx-bigboss-laser" src="sounds/bigboss-laser.mp3" loop></audio>
<audio id="sfx-nuke-fall" src="sounds/nuke-fall.mp3"></audio>
<audio id="sfx-nuke-explode" src="sounds/nuke-explode.mp3"></audio>
<audio id="sfx-lazer-charging" src="sounds/lazer-charging.mp3" loop></audio>
<audio id="sfx-shield-block" src="sounds/shield-block.mp3"></audio>
<audio id="sfx-game-over" src="sounds/game-over.mp3"></audio>
<audio id="sfx-player-hurt" src="sounds/player-hurt.mp3"></audio>
<audio id="sfx-player-explode" src="sounds/player-explode.mp3"></audio>
<audio id="sfx-powerup" src="sounds/powerup.mp3"></audio>
<audio id="sfx-game-start" src="sounds/game-start.mp3"></audio>
<audio id="sfx-ui-click" src="sounds/ui-click.mp3"></audio>
<audio id="sfx-lucky-loop" src="sounds/lucky-active-loop.mp3" loop></audio>
<audio id="sfx-power-loop" src="sounds/power-active-loop.mp3" loop></audio>
<audio id="sfx-upgrade-select" src="sounds/upgrade-select.mp3"></audio>
<audio id="sfx-wave-up" src="sounds/wave-up.mp3"></audio>
<audio id="sfx-nuke-time" src="sounds/nuke-time.mp3"></audio>
<audio id="sfx-crazy-loop" src="sounds/crazy-active-loop.mp3" loop></audio>
<audio id="sfx-exp-loop" src="sounds/exp-active-loop.mp3" loop></audio>
<audio id="sfx-supply-drop-item" src="sounds/supply-drop-item.mp3"></audio>

<!-- üåê C√°c t·ªáp JavaScript ch√≠nh -->
<script src="equipment_drop.js"></script>
<script src="character_panel.js"></script>
<script src="news_ticker.js"></script> </body>

</body>
</html>
